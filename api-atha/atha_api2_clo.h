/* KAAPI public interface */
// KAAPI library source
// -----------------------------------------
// by Thierry Gautier
//(c) INRIA, projet MOAIS, 2006-2009
//
// **********************************************************
// WARNING! This file has been automatically generated by M4
// Mer 16 dÃ©c 2009 16:04:53 CET
// *********************************************************









// --------------------------------------------------------------------
/* 0 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<0> {
  
  struct Signature { 
    
    
    void operator() (  ) {}
#if 0
    void operator() ( kaapi_stack_t* stack   )
    {
      operator()(  );
    }
#endif
  };
};


template<class TASK >
struct KaapiTaskArg0{ 
 
 
  typedef KaapiTaskArg0<TASK > Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    
    dummy();
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    
    dummy();
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[0];
    static kaapi_offset_t        array_offset[0];
    static const kaapi_format_t* array_format[0];
    static Self_t a;
    
    
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          0,
          0,
          0,
          0
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK >
kaapi_format_t KaapiTaskArg0<TASK >::format;

template<class TASK >
kaapi_format_id_t KaapiTaskArg0<TASK >::fmid = 0;










// --------------------------------------------------------------------
/* 1 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<1> {
  template<class F1>
  struct Signature { 
    typedef F1 formal1_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    
    void operator() ( formal1_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1 )
    {
      operator()( f1 );
    }
#endif
  };
};


template<class TASK ,class F1>
struct KaapiTaskArg1{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  
  type_inclosure_F1 f1;
  
  typedef KaapiTaskArg1<TASK ,F1> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[1];
    static kaapi_offset_t        array_offset[1];
    static const kaapi_format_t* array_format[1];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          1,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1>
kaapi_format_t KaapiTaskArg1<TASK ,F1>::format;

template<class TASK ,class F1>
kaapi_format_id_t KaapiTaskArg1<TASK ,F1>::fmid = 0;










// --------------------------------------------------------------------
/* 2 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<2> {
  template<class F1, class F2>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    
    void operator() ( formal1_t, formal2_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2 )
    {
      operator()( f1, f2 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2>
struct KaapiTaskArg2{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  
  typedef KaapiTaskArg2<TASK ,F1,F2> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[2];
    static kaapi_offset_t        array_offset[2];
    static const kaapi_format_t* array_format[2];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          2,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2>
kaapi_format_t KaapiTaskArg2<TASK ,F1 ,F2>::format;

template<class TASK ,class F1 ,class F2>
kaapi_format_id_t KaapiTaskArg2<TASK ,F1 ,F2>::fmid = 0;










// --------------------------------------------------------------------
/* 3 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<3> {
  template<class F1, class F2, class F3>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    
    void operator() ( formal1_t, formal2_t, formal3_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3 )
    {
      operator()( f1, f2, f3 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3>
struct KaapiTaskArg3{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  
  typedef KaapiTaskArg3<TASK ,F1,F2,F3> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[3];
    static kaapi_offset_t        array_offset[3];
    static const kaapi_format_t* array_format[3];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          3,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3>
kaapi_format_t KaapiTaskArg3<TASK ,F1 ,F2 ,F3>::format;

template<class TASK ,class F1 ,class F2 ,class F3>
kaapi_format_id_t KaapiTaskArg3<TASK ,F1 ,F2 ,F3>::fmid = 0;










// --------------------------------------------------------------------
/* 4 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<4> {
  template<class F1, class F2, class F3, class F4>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4 )
    {
      operator()( f1, f2, f3, f4 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4>
struct KaapiTaskArg4{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  
  typedef KaapiTaskArg4<TASK ,F1,F2,F3,F4> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[4];
    static kaapi_offset_t        array_offset[4];
    static const kaapi_format_t* array_format[4];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          4,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4>
kaapi_format_t KaapiTaskArg4<TASK ,F1 ,F2 ,F3 ,F4>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4>
kaapi_format_id_t KaapiTaskArg4<TASK ,F1 ,F2 ,F3 ,F4>::fmid = 0;










// --------------------------------------------------------------------
/* 5 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<5> {
  template<class F1, class F2, class F3, class F4, class F5>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5 )
    {
      operator()( f1, f2, f3, f4, f5 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5>
struct KaapiTaskArg5{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  
  typedef KaapiTaskArg5<TASK ,F1,F2,F3,F4,F5> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[5];
    static kaapi_offset_t        array_offset[5];
    static const kaapi_format_t* array_format[5];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          5,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5>
kaapi_format_t KaapiTaskArg5<TASK ,F1 ,F2 ,F3 ,F4 ,F5>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5>
kaapi_format_id_t KaapiTaskArg5<TASK ,F1 ,F2 ,F3 ,F4 ,F5>::fmid = 0;










// --------------------------------------------------------------------
/* 6 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<6> {
  template<class F1, class F2, class F3, class F4, class F5, class F6>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    typedef F6 formal6_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t, formal6_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5, formal6_t f6 )
    {
      operator()( f1, f2, f3, f4, f5, f6 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6>
struct KaapiTaskArg6{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  type_inclosure_F6 f6;
  
  typedef KaapiTaskArg6<TASK ,F1,F2,F3,F4,F5,F6> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[6];
    static kaapi_offset_t        array_offset[6];
    static const kaapi_format_t* array_format[6];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    array_mode[6-1] = (kaapi_access_mode_t)Trait_ParamClosure<F6>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    array_offset[6-1] = (char*)&a.f6 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    array_format[6-1] = Trait_ParamClosure<F6>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          6,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6>
kaapi_format_t KaapiTaskArg6<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6>
kaapi_format_id_t KaapiTaskArg6<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6>::fmid = 0;










// --------------------------------------------------------------------
/* 7 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<7> {
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    typedef F6 formal6_t;
    typedef F7 formal7_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
    typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t, formal6_t, formal7_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5, formal6_t f6, formal7_t f7 )
    {
      operator()( f1, f2, f3, f4, f5, f6, f7 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7>
struct KaapiTaskArg7{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
  typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  type_inclosure_F6 f6;
  type_inclosure_F7 f7;
  
  typedef KaapiTaskArg7<TASK ,F1,F2,F3,F4,F5,F6,F7> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[7];
    static kaapi_offset_t        array_offset[7];
    static const kaapi_format_t* array_format[7];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    array_mode[6-1] = (kaapi_access_mode_t)Trait_ParamClosure<F6>::xkaapi_mode;
    array_mode[7-1] = (kaapi_access_mode_t)Trait_ParamClosure<F7>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    array_offset[6-1] = (char*)&a.f6 - (char*)&a;
    array_offset[7-1] = (char*)&a.f7 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    array_format[6-1] = Trait_ParamClosure<F6>::format;
    array_format[7-1] = Trait_ParamClosure<F7>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          7,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7>
kaapi_format_t KaapiTaskArg7<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7>
kaapi_format_id_t KaapiTaskArg7<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7>::fmid = 0;










// --------------------------------------------------------------------
/* 8 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<8> {
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    typedef F6 formal6_t;
    typedef F7 formal7_t;
    typedef F8 formal8_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
    typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
    typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t, formal6_t, formal7_t, formal8_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5, formal6_t f6, formal7_t f7, formal8_t f8 )
    {
      operator()( f1, f2, f3, f4, f5, f6, f7, f8 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8>
struct KaapiTaskArg8{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
  typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
  typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  type_inclosure_F6 f6;
  type_inclosure_F7 f7;
  type_inclosure_F8 f8;
  
  typedef KaapiTaskArg8<TASK ,F1,F2,F3,F4,F5,F6,F7,F8> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[8];
    static kaapi_offset_t        array_offset[8];
    static const kaapi_format_t* array_format[8];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    array_mode[6-1] = (kaapi_access_mode_t)Trait_ParamClosure<F6>::xkaapi_mode;
    array_mode[7-1] = (kaapi_access_mode_t)Trait_ParamClosure<F7>::xkaapi_mode;
    array_mode[8-1] = (kaapi_access_mode_t)Trait_ParamClosure<F8>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    array_offset[6-1] = (char*)&a.f6 - (char*)&a;
    array_offset[7-1] = (char*)&a.f7 - (char*)&a;
    array_offset[8-1] = (char*)&a.f8 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    array_format[6-1] = Trait_ParamClosure<F6>::format;
    array_format[7-1] = Trait_ParamClosure<F7>::format;
    array_format[8-1] = Trait_ParamClosure<F8>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          8,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8>
kaapi_format_t KaapiTaskArg8<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8>
kaapi_format_id_t KaapiTaskArg8<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8>::fmid = 0;










// --------------------------------------------------------------------
/* 9 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<9> {
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    typedef F6 formal6_t;
    typedef F7 formal7_t;
    typedef F8 formal8_t;
    typedef F9 formal9_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
    typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
    typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
    typedef typename Trait_ParamClosure<F9>::type_inclosure type_inclosure_F9;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t, formal6_t, formal7_t, formal8_t, formal9_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5, formal6_t f6, formal7_t f7, formal8_t f8, formal9_t f9 )
    {
      operator()( f1, f2, f3, f4, f5, f6, f7, f8, f9 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9>
struct KaapiTaskArg9{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
  typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
  typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
  typedef typename Trait_ParamClosure<F9>::type_inclosure type_inclosure_F9;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  type_inclosure_F6 f6;
  type_inclosure_F7 f7;
  type_inclosure_F8 f8;
  type_inclosure_F9 f9;
  
  typedef KaapiTaskArg9<TASK ,F1,F2,F3,F4,F5,F6,F7,F8,F9> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8, args->f9);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8, args->f9);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[9];
    static kaapi_offset_t        array_offset[9];
    static const kaapi_format_t* array_format[9];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    array_mode[6-1] = (kaapi_access_mode_t)Trait_ParamClosure<F6>::xkaapi_mode;
    array_mode[7-1] = (kaapi_access_mode_t)Trait_ParamClosure<F7>::xkaapi_mode;
    array_mode[8-1] = (kaapi_access_mode_t)Trait_ParamClosure<F8>::xkaapi_mode;
    array_mode[9-1] = (kaapi_access_mode_t)Trait_ParamClosure<F9>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    array_offset[6-1] = (char*)&a.f6 - (char*)&a;
    array_offset[7-1] = (char*)&a.f7 - (char*)&a;
    array_offset[8-1] = (char*)&a.f8 - (char*)&a;
    array_offset[9-1] = (char*)&a.f9 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    array_format[6-1] = Trait_ParamClosure<F6>::format;
    array_format[7-1] = Trait_ParamClosure<F7>::format;
    array_format[8-1] = Trait_ParamClosure<F8>::format;
    array_format[9-1] = Trait_ParamClosure<F9>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          9,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9>
kaapi_format_t KaapiTaskArg9<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8 ,F9>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9>
kaapi_format_id_t KaapiTaskArg9<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8 ,F9>::fmid = 0;










// --------------------------------------------------------------------
/* 10 is the number of possible parameters */
/* Fi: format parameters Shared_XX, XX -> XX */
template<>
struct Task<10> {
  template<class F1, class F2, class F3, class F4, class F5, class F6, class F7, class F8, class F9, class F10>
  struct Signature { 
    typedef F1 formal1_t;
    typedef F2 formal2_t;
    typedef F3 formal3_t;
    typedef F4 formal4_t;
    typedef F5 formal5_t;
    typedef F6 formal6_t;
    typedef F7 formal7_t;
    typedef F8 formal8_t;
    typedef F9 formal9_t;
    typedef F10 formal10_t;
    
     typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
    typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
    typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
    typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
    typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
    typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
    typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
    typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
    typedef typename Trait_ParamClosure<F9>::type_inclosure type_inclosure_F9;
    typedef typename Trait_ParamClosure<F10>::type_inclosure type_inclosure_F10;
    
    void operator() ( formal1_t, formal2_t, formal3_t, formal4_t, formal5_t, formal6_t, formal7_t, formal8_t, formal9_t, formal10_t ) {}
#if 0
    void operator() ( kaapi_stack_t* stack , formal1_t f1, formal2_t f2, formal3_t f3, formal4_t f4, formal5_t f5, formal6_t f6, formal7_t f7, formal8_t f8, formal9_t f9, formal10_t f10 )
    {
      operator()( f1, f2, f3, f4, f5, f6, f7, f8, f9, f10 );
    }
#endif
  };
};


template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9 ,class F10>
struct KaapiTaskArg10{ 
  typedef typename Trait_ParamClosure<F1>::type_inclosure type_inclosure_F1;
  typedef typename Trait_ParamClosure<F2>::type_inclosure type_inclosure_F2;
  typedef typename Trait_ParamClosure<F3>::type_inclosure type_inclosure_F3;
  typedef typename Trait_ParamClosure<F4>::type_inclosure type_inclosure_F4;
  typedef typename Trait_ParamClosure<F5>::type_inclosure type_inclosure_F5;
  typedef typename Trait_ParamClosure<F6>::type_inclosure type_inclosure_F6;
  typedef typename Trait_ParamClosure<F7>::type_inclosure type_inclosure_F7;
  typedef typename Trait_ParamClosure<F8>::type_inclosure type_inclosure_F8;
  typedef typename Trait_ParamClosure<F9>::type_inclosure type_inclosure_F9;
  typedef typename Trait_ParamClosure<F10>::type_inclosure type_inclosure_F10;
  
  type_inclosure_F1 f1;
  type_inclosure_F2 f2;
  type_inclosure_F3 f3;
  type_inclosure_F4 f4;
  type_inclosure_F5 f5;
  type_inclosure_F6 f6;
  type_inclosure_F7 f7;
  type_inclosure_F8 f8;
  type_inclosure_F9 f9;
  type_inclosure_F10 f10;
  
  typedef KaapiTaskArg10<TASK ,F1,F2,F3,F4,F5,F6,F7,F8,F9,F10> Self_t;

  /* */
  static void body_cpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyCPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8, args->f9, args->f10);
  }

  /* */
  static void body_gpu(kaapi_task_t* t, kaapi_stack_t* stack)
  {
    static TaskBodyGPU<TASK> dummy;
    Self_t* args = kaapi_task_getargst(t, Self_t);
    dummy(args->f1, args->f2, args->f3, args->f4, args->f5, args->f6, args->f7, args->f8, args->f9, args->f10);
  }

  static kaapi_format_t    format;
  static kaapi_format_id_t fmid;
  static kaapi_format_t* getformat()
  { return &format; }
  static kaapi_format_t* registerformat()
  {
    if (Self_t::fmid != 0) return &Self_t::format;
    
    static kaapi_access_mode_t   array_mode[10];
    static kaapi_offset_t        array_offset[10];
    static const kaapi_format_t* array_format[10];
    static Self_t a;
    array_mode[1-1] = (kaapi_access_mode_t)Trait_ParamClosure<F1>::xkaapi_mode;
    array_mode[2-1] = (kaapi_access_mode_t)Trait_ParamClosure<F2>::xkaapi_mode;
    array_mode[3-1] = (kaapi_access_mode_t)Trait_ParamClosure<F3>::xkaapi_mode;
    array_mode[4-1] = (kaapi_access_mode_t)Trait_ParamClosure<F4>::xkaapi_mode;
    array_mode[5-1] = (kaapi_access_mode_t)Trait_ParamClosure<F5>::xkaapi_mode;
    array_mode[6-1] = (kaapi_access_mode_t)Trait_ParamClosure<F6>::xkaapi_mode;
    array_mode[7-1] = (kaapi_access_mode_t)Trait_ParamClosure<F7>::xkaapi_mode;
    array_mode[8-1] = (kaapi_access_mode_t)Trait_ParamClosure<F8>::xkaapi_mode;
    array_mode[9-1] = (kaapi_access_mode_t)Trait_ParamClosure<F9>::xkaapi_mode;
    array_mode[10-1] = (kaapi_access_mode_t)Trait_ParamClosure<F10>::xkaapi_mode;
    
    array_offset[1-1] = (char*)&a.f1 - (char*)&a;
    array_offset[2-1] = (char*)&a.f2 - (char*)&a;
    array_offset[3-1] = (char*)&a.f3 - (char*)&a;
    array_offset[4-1] = (char*)&a.f4 - (char*)&a;
    array_offset[5-1] = (char*)&a.f5 - (char*)&a;
    array_offset[6-1] = (char*)&a.f6 - (char*)&a;
    array_offset[7-1] = (char*)&a.f7 - (char*)&a;
    array_offset[8-1] = (char*)&a.f8 - (char*)&a;
    array_offset[9-1] = (char*)&a.f9 - (char*)&a;
    array_offset[10-1] = (char*)&a.f10 - (char*)&a;
    
    array_format[1-1] = Trait_ParamClosure<F1>::format;
    array_format[2-1] = Trait_ParamClosure<F2>::format;
    array_format[3-1] = Trait_ParamClosure<F3>::format;
    array_format[4-1] = Trait_ParamClosure<F4>::format;
    array_format[5-1] = Trait_ParamClosure<F5>::format;
    array_format[6-1] = Trait_ParamClosure<F6>::format;
    array_format[7-1] = Trait_ParamClosure<F7>::format;
    array_format[8-1] = Trait_ParamClosure<F8>::format;
    array_format[9-1] = Trait_ParamClosure<F9>::format;
    array_format[10-1] = Trait_ParamClosure<F10>::format;
    
    
    Self_t::fmid = kaapi_format_taskregister( 
          &Self_t::getformat, 
          &Self_t::body_cpu, 
          typeid(Self_t).name(),
          sizeof(Self_t),
          10,
          array_mode,
          array_offset,
          array_format
      );
   int (TASK::*f_defaultcpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_cpu)(...) = (int (TASK::*)(...))&TaskBodyCPU<TASK>::operator();
   if (f_cpu == f_defaultcpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_CPU] = &Self_t::body_cpu;
   }
   int (TASK::*f_defaultgpu)(...) = (int (TASK::*)(...))&TASK::operator();  /* inherited from Signature */
   int (TASK::*f_gpu)(...) = (int (TASK::*)(...))&TaskBodyGPU<TASK>::operator();
   if (f_gpu == f_defaultgpu) {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = 0;
   }
   else {
     Self_t::format.entrypoint[KAAPI_PROC_TYPE_GPU] = &Self_t::body_gpu;
   }

    return &Self_t::format;
  }  
};

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9 ,class F10>
kaapi_format_t KaapiTaskArg10<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8 ,F9 ,F10>::format;

template<class TASK ,class F1 ,class F2 ,class F3 ,class F4 ,class F5 ,class F6 ,class F7 ,class F8 ,class F9 ,class F10>
kaapi_format_id_t KaapiTaskArg10<TASK ,F1 ,F2 ,F3 ,F4 ,F5 ,F6 ,F7 ,F8 ,F9 ,F10>::fmid = 0;


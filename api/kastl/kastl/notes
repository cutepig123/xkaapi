-- bugs
. probleme avec algorithme find, abandon
. arriver de tomber dans une boucle infinie
. besoin d un lock global
 . while true ; do ...
 . a debugger avec gdb, what are the threads blocking on

-- todos
. find algo, initialiser, comparer le resultat
 . l idee est de passer la sequence en parametre
 dans le cas d un algorithm_result, rien dans le
 cas d un numeric_result
  . init_result met le resultat a .end()
 . comment faire la reduction
. tester que la terminaison fonctionne

 ==> il faut peut etre arreter de passer par des
 iterator et seulement par des index et transformer
 au dernier moment

. une fois find implemente, faire:
ResultTag qui remplace le ReduceTag
et peut avoir la value suivante:
void_tag, algorithm_tag, numeric_tag
ce tag permet la specialisation de
l allocation, initialisation, la preemption ect... 

. partir sur des algos plus compliques pour tester
le modele: inner_product

. remove unneeded template arguments (for instance Body)
. remove unneeded result

. faire les tests + les benchs

. window extractor
 . should slide as space becomes avail, not at the end of the loop
 . sizes must be of the right type (ie. sign errors...)

. faire un preempter, meme que reducer
 . PreemptionTag = nopreempt_tag

. faire un tuner maintenant que les settings sont dynamiques

-- impl
template<typename Iterator>
struct algorithm_result : base_result
{
  Iterator _value;

  void algorithm_result(Iterator& value)
    : _value(value)
  {}

  bool is_found()
  {
    return false;
  }

};

template<typename Value>
struct numeric_result : base_result
{
};


struct void_result
{
};

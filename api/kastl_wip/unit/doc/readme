. introduction

 . the unit/ stuff has 2 goals:
  . test kastl algorithm against the ref
  . benchmark different implementation
   . up to 4 implementations: kastl, tbb, stl, pastl

 . for some reasons (esp. related to benchmarking, the way the kaapi runtime
 creates threads ...), different binaries have to be built for the different
 configuration we want to test

 . this is what the build system is for, and why you encounter so much #defines
 as you walk along this code

. how to build a binary
 . ./do_make.sh will build all the unit binaries

 . the system allows to build 2 kinds of binaries
  . xxx-xxx-check: check an implementation against the ref, usually the stl
  . xxx-xxx-bench: run an implementation an outputs its times

 . the build directory contains a top Makefile that
 includes sub makefiles according to the binary you
 want to build

 . the system is driven by 3 variables
  . LIB={stl,kastl,pastl,tbb}
  . ALGO={for_each,min_element...}
  . DO={bench,check}
 . ex: make LIB=kastl ALGO=for_each DO=bench
  . builds a binary to benchmark kastl::for_each
 . the output directory is bin/

. how to run a binary
 . TODO, refer to run/do_main.sh for now
 . do_run.sh <dirname>
 . run each binary in dirname and create a session
 . 
 . for each binary
  . if this a check

 . it has to take into account the following vars:
  . KAAPI_CPUSET_<N> where <N> a number
   . or KAAPI_CPUSET (eq. to KAAPI_CPUSET_0)
  . SEQUENCE_SIZE_<N>
  . ITER

. sessions
 . archive containing params bench, check, of a run
  . sessions/<date>/<id>/<bin>.o
  . sessions/<date>/<id>/params
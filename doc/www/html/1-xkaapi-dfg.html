<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta name="description" content="XKaapi- DFG program - 09-02-2011 Thierry Gautier  Preface This tutorial is part of the following tutorials XKaapi: programming with data flow graph XKaapi: KaSTL API XKaapi: Low Level Adaptive Application Interface XKaapi: Fortran Interface XKaapi: internal representation &amp; execution   Bientôt en ligne.... What is Kaapi ? C/C++ Library for parallel programming Target architecture: multicore + GPU + cluster Ultimate goal Simplify the development of parallel application architecture abstraction Automatic dynamic load balancing theoretically &amp; practically performances  Work Stealing based algorithms Design Kernel runtime for API (or compiler) work stealing internal scheduling C language, fine grain implementation... APIs for different programming models Data Flow Graph: DFG Athapascan (deprecated), Kaapi++ Parallel STL like: KaSTL Adaptive Algorithms Interface: AAI InstallationDevelopment Source development http://kaapi.gforge.inria.fr  tarball of the master (rc04) GIT: ligforge url = ssh://git.ligforge.imag.fr/git/kaapi/xkaapi.gitUsage of branches origin/master: the official master branch origin/&lt;username&gt;/&lt;branch name&gt;: an user branch The owner is responsible of its branches The user MUST ONLY commit on its own branches Mailing list: kaapi-leaders@lists.gforge.inria.fr http://lists.gforge.inria.fr/cgi-bin/mailman/listinfo/kaapi-leaders Installation automake / autotools etc... ../xkaapi/configure --help ../xkaapi/configure --prefix=&lt;totodir&gt;  Usefull options:  --enable-mode=release for performances --enable-mode=debug for more assertions in the user level API Compilation make Installation make install (in the --prefix directory, step 1) &lt;totodir&gt;/include; &lt;totodir&gt;/lib etc.. use pkgconfig to retreive CCFLAGS, LDFLAGS etc Basic check make check List of examples Examples sub directory cd examples;  make examples : build all examples make &lt;prog&gt;, e.g. make for_each_rec_xx   hello hello_world.cpp  for_each for_each_rec_kaapi++.cpp :  recursive C++ version for_each_0_kaapi++.cpp :  basic adaptive C++ version for_each_0_kaapi.c :  basic adaptive C version for_each_1_kaapi++.cpp :  adaptive C++ version, enable steal of thief for_each_2_kaapi++.cpp :  idem + preemption for_each_0_kaapi++_lambda.cpp : adaptive C++ version with lambda for_each_kastl.cpp: call to STL kastl implementation Cont. Fibo fibo_kaapi.c : low level C version fibo_atha.cpp :  old Athapascan C++ API version fibo_kaapi++.cpp : Kaapi C++ API version fibo_kaapi++_opt.cpp : Kaapi C++ API with optimized task creation fibo_kaapi++_cumul.cpp : Kaapi C++ API version with cumulative write fibo_kaapixx_cumul_opt.cpp : Kaapi C++ API version with optimized task creation fibo_kaapi++_sync.cpp: usage of synch. to avoid sum’ task creation make fibo_kaapi fibo_kaapi++ fibo_atha... NQueens nqueens_atha / nqueens_kaapi++ Cilk two examples from Cilk distribution (matrix computation/qsort) Have a look of subdirectories in &lt;topsrcdir&gt;/examples ! Compilation of examples Use pkg-config gautier@idkoiff:~$ export PKG_CONFIG_PATH=&lt;kaapi install dir&gt;/lib/pkgconfig  gautier@idkoiff:~$ pkg-config --cflags kaapi++-I/home/gautier/KAAPI/install/xkaapi/include  gautier@idkoiff:~$ pkg-config --libs kaapi++-L/home/gautier/KAAPI/install/xkaapi/lib -lkaapi++ -lkaapi   Typical use: gautier@idkoiff:~$ g++ -o mytest mytest.cpp `pkg-config --cflags kaapi++` `pkg-config --libs kaapi++` That all ! Running example KAAPI_CPUCOUNT=1 ./fibo_kaapi++ 30   KAAPI_CPUCOUNT=2 ./fibo_kaapi++ 30   KAAPI_CPUSET=0:4,6 ./fibo_kaapi++ 30 use cores 0,1,2,3,4 and 6 of the machine Fibo(30)=832040Time: 4.326541e-01 Fibo(30)=832040Time: 2.143562e-01 Sources organization xkaapi/src everything about workstealing / graph representation is here xkaapi/examples user level examples xkaapi/api Athapascan C++ interface [deprecated] Kaapi C++ interface [Fortran interface] etc.. C++ API called Kaapi++ #include “kaapi++“ Namespace ka:: 3 main concepts Task signature declare access to data Read: «R»; Write: «W»; Read Write: «RW»; Cumulative Write: «CW» Task implementation one implementation for each architecture E.g. CPU implementation ; GPU implementation (still in progress) A data is shared between 2 tasks iff tasks have the same pointer in effective parameters Library initialization Mostly always the same: int main(int argc, char** argv) {   try {     /* Join the initial group of computation */     ka::Community com = ka::System::join_community( argc, argv );          /* Start computation by spawning the main task */     ka::SpawnMain&lt;doit&gt;()(argc, argv);           /* Leave the community */     com.leave();      /* */     ka::System::terminate();   }   catch (const std::exception&amp; E) {     std::cerr &lt;&lt; &quot;Catch Kaapi exception: &quot; &lt;&lt; E.what() &lt;&lt; std::endl;   }   catch (...) {     std::cerr &lt;&lt; &quot;Catch unknown exception: &quot; &lt;&lt; std::endl;   }   return 0; } Task Task signature Define the number of parameters / type / access mode of each parameter   Task implementation specify the implementation architecture (CPU/GPU) /* Kaapi Hello task: print an integer n */ struct TaskHello: public ka::Task&lt;1&gt;::Signature&lt;int&gt; {};  /* CPU implementation */ template&lt;&gt; struct TaskBodyCPU&lt;TaskHello&gt; {   void operator() ( int n )    {     std::cout &lt;&lt; ”Hello World !, n=” &lt;&lt; n &lt;&lt; std::endl;   } };    Task creation Key word: spawn     Exercise 1: write &amp; compile HelloWorld.cpp /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           /* */     ka::Spawn&lt;TaskHello&gt;()( atoi(argv[1]) ); } }; Task creation Key word: spawn     Exercise II: write all the arguments (integers) /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           /* */     ka::Spawn&lt;TaskHello&gt;()( atoi(argv[1]) ); } }; /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           for (int i=1; i&lt;argc; ++i)       ka::Spawn&lt;TaskHello&gt;()( atoi(argv[i]) ); } }; When a task is executed ? Task creation is a non blocking operation: the task (= function call) is pushed into a stack and the control flow continues without waiting for the termination /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           int  a;     int* b = ...;      ka::Spawn&lt;TaskThatRead_or_WriteData&gt;()( &amp;a, &amp;b );      /* here:         1- Kaapi does not guarantee execution of the task        2- a and b can accessed and should have a correct scope     */ } }; When a task is executed ? Some guarantees: A task begins its execution when all its input arguments are produced (data flow constraints) The parallel execution always produces the same result as the sequential execution (up to round off) At the end of the program, all created tasks have been executed Notion of reference order between tasks Used to define execution order between any two tasks total order Semantic of Kaapi is based on it originaly defined in Athapascan [Pact98]  Reference order Recursive definition In a task body created tasks are enqueued in a FIFO queue each task = function call = function pointer + arguments When task body finish the runtime dequeues each task (FIFO) and executes it struct TaskBodyCPU&lt;TaskF&gt; {   void operator() ( argF )   {     a1 = G1(..);     ka::Spawn&lt;TaskF1&gt;()( argF1 );     a2 = G2(...)     ka::Spawn&lt;TaskF2&gt;()( argF2 );     a3 = G3(...)   } }; execute( TaskF, argF ) =  {   { /* task body execution */     a1 = G1(...);     e1 = eval( argF1 );     enqueue( TaskF1, e1 );     a2 = G2(...);     e2 = eval( argF2 );     enqueue( TaskF2, e2 );     a3 = G3(...);   }   /* epilogue: execute spawned tasks */   (TaskF1,e1) = dequeue();   execute( TaskF1, e1 );   (TaskF2,e2) = dequeue();   execute( TaskF2, e2 ); }  Double HelloWorld (...) Possible traces of execution: /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           /* */     ka::Spawn&lt;TaskHello&gt;()( atoi(argv[1]) );     /* */     ka::Spawn&lt;TaskHello&gt;()( atoi(argv[2]) ); } }; &gt; ./helloworld 1 2 Hello World !, n=1 Hello World !, n=2  &gt; ./helloworld 1 2 Hello World !, n=2 Hello World !, n=1 How to enforce execution order? Cilk’s like synchronisation: ka::Sync(); force execution of all the spawned tasks in the current running task Inline data flow constraint ka::Sync( &lt;pointer&gt; ); wait until the value pointed by the pointer is produced Add dependencies between tasks wait to see “parameter passing rules” in 2 slides ka::Sync() keyword Possible traces of execution: /* The ”doit” main task */ template&lt;class T&gt; struct doit { void operator()(int argc, char** argv ) {           ka::Spawn&lt;TaskHello&gt;()( atoi(argv[1]) );     ka::Sync();     ka::Spawn&lt;TaskHello&gt;()( atoi(argv[2]) ); } }; &gt; ./helloworld 1 2 Hello World !, n=1 Hello World !, n=2  &gt; ./helloworld 1 2 Hello World !, n=1 Hello World !, n=2 Parameter passing rules Parameter passing rules : way effective parameters are bind to formal parameters of task by value (copy): HelloWorld.cpp by reference (using ka::pointer or a C++ pointer)  By value: a copy is made into the task  By reference No copy But task must declare its accesses to shared data read: read access, the task can read the value write: write access, a reader will see the value write read write: exclusive access,one task has access to data cumulative write: several write will participate to produce the final value Task signature Number of parameters fixed at compilation time  Access mode ka::W&lt;T&gt;: write ka::R&lt;T&gt;: read ka::RW&lt;T&gt;: read write ka::CW&lt;T&gt; : cumulative write with global reduction op Should correspond to declaration into formal parameters of task ka::pointer_w&lt;T&gt;  ka::pointer_r&lt;T&gt; ka::pointer_rw&lt;T&gt;  ka::pointer_cw&lt;T,F&gt; struct TaskFibo: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;int&gt;, int&gt; {}; Task Task signature define the number of parameters / type / access mode of each parameter    Task implementation specify the implementation architecture (CPU) /* Kaapi Fibo task: takes a pointer to the result + an integer n */ struct TaskFibo: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;long&gt;, long&gt; {};  /* CPU implementation */ template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::pointer_w&lt;long&gt; res, long n ) { ... } };   Dependencies A task must decribe their modes of access to data passed in effective parameters Task Signature At runtime: the execution = sequence of tasks reference order of execution Kaapi will always respect the following dependencies: a reader will see the value written by the last task in the reference order:  W -&gt; R, {CW}* -&gt; R, or RW -&gt; R : Read After Write other false dependencies (Writer After Read) may be solved by making copies of data runtime decision Cost of dependencies? Dependency analysis is required to execute two tasks in parallel tasks with dependencies are executed following the reference order “ a reader will see value writes by the last writer ” tasks without dependencies may be executed in parallel the runtime decide when and where 2 concurrent tasks are executed in parallel With work stealing scheduling: execution following reference order of execution  dequeue management, no dependency analysis dependencies are only computed during steal operation What is really shared ? Two tasks share a common data IFF they access to the same data in memory Current implementation = limitation same data == same pointer    TaskRW1 &amp; TaskRW2 are independent, even if access to data pointed by ‘a’ an ‘b’ overlap !!! No (yet) region of memory ka::pointer&lt;T&gt; a; ka::pointer&lt;T&gt; b = a+100; ka::Spawn&lt;TaskRW1&gt;()(a); /* rw on a */ ka::Spawn&lt;TaskRW2&gt;()(b); /* rw on b */  Illustration Task creation: Spawn        The runtime automatically detects data flow dependencies between tasks Write after Read dependencies may be solved by copy struct TaskFibo: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;long&gt;, long &gt; {};  struct TaskDelete: public ka::Task&lt;1&gt;::Signature&lt;ka::RW&lt;long&gt; &gt; {};  struct TaskPrint: public ka::Task&lt;1&gt;::Signature&lt;ka::R&lt;long&gt; &gt; {};      /* */       ka::pointer&lt;long&gt; res = new long;            /* */     ka::Spawn&lt;TaskFibo&gt;()( res, n );      /* */     ka::Spawn&lt;TaskPrint&gt;()(res);      /* */     ka::Spawn&lt;TaskDelete &gt;()(res); // delete memory Fibo (bad) example  template&lt;&gt; struct TaskBodyCPU&lt;TaskSum&gt; {   void operator()( ka::pointer_w&lt;long&gt; r, ka::pointer_r&lt;long&gt; a, ka::pointer_r&lt;long&gt; b )    { *r = *a + *b; } };  template&lt;&gt; struct TaskBodyCPU&lt;TaskDelete&gt; {   void operator()( ka::pointer_rw&lt;long&gt; ptr )    { delete ptr; } };  template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::pointer_w&lt;long&gt; ptr, const long n )   {       if (n &lt; 2)       *ptr = n;      else {       ka::pointer&lt;long&gt; ptr1 = new long;       ka::pointer&lt;long&gt; ptr1 = new long;        ka::Spawn&lt;TaskFibo&gt;() ( ptr1, n-1 );       ka::Spawn&lt;TaskFibo&gt;() ( ptr2, n-2 );        ka::Spawn&lt;TaskSum&gt;() ( ptr, ptr1, ptr2 );              ka::Spawn&lt;TaskDelete&gt;() ( ptr1 );       ka::Spawn&lt;TaskDelete&gt;() ( ptr2 );     }   } }; Pointer object allocation Scope of the data pointed by ka::pointer at least the life time of the last task accessing the data due to task execution order =&gt; out the C++ scope where the task is created in Fibo example: new + spawn of task to delete memory 2 standard possibilities to manage dynamic allocations use new / delete: as in the previous “fibo (bad) example” ‘operator new’ at creation of the pointer ‘operator delete’ -&gt; the user has responsability to spawn the last task to delete the data use ka::auto_pointer&lt;TYPE&gt; / scoped pointer (?) ‘operator new’ at creation of the pointer the runtime automatically spawns the task to delete the data Fibo (better) example  template&lt;&gt; struct TaskBodyCPU&lt;TaskSum&gt; {   void operator()( ka::pointer_w&lt;long&gt; r, ka::pointer_r&lt;long&gt; a, ka::pointer_r&lt;long&gt; b )    { *r = *a + *b; } };  template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::pointer_w&lt;long&gt; ptr, const long n )   {       if (n &lt; 2)       *ptr = n;      else {       ka::auto_pointer&lt;long&gt; ptr1 = new long;       ka::auto_pointer&lt;long&gt; ptr2 = new long;        ka::Spawn&lt;TaskFibo&gt;() ( ptr1, n-1 );       ka::Spawn&lt;TaskFibo&gt;() ( ptr2, n-2 );        ka::Spawn&lt;TaskSum&gt;() ( ptr, ptr1, ptr2 );           }   } }; How to improve fibo ? Problem1: Huge number of new / delete at runtime sequential C++ version: automatic variable in the stack for intermediate sub results use ‘ka::auto_variable’ to declare variable in the Kaapi stack of tasks very similar to sequential C++ automatic variable stdlib.h / alloca &lt;=&gt; sequential C++ automatic variable ka::Alloca &lt;=&gt; ka::auto_variable  Illustration on Fibonacci Fibo (much better) example  template&lt;&gt; struct TaskBodyCPU&lt;TaskSum&gt; {   void operator()( ka::pointer_w&lt;long&gt; r, ka::pointer_r&lt;long&gt; a, ka::pointer_r&lt;long&gt; b )    { *r = *a + *b; } };  template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::pointer_w&lt;long&gt; ptr, const long n )   {       if (n &lt; 2)       *ptr = n;      else {       ka::auto_variable&lt;long&gt; res1;       ka::auto_variable&lt;long&gt; res2;        ka::Spawn&lt;TaskFibo&gt;() ( &amp;res1, n-1 );       ka::Spawn&lt;TaskFibo&gt;() ( &amp;res2, n-2 );        ka::Spawn&lt;TaskSum&gt;() ( ptr, &amp;res1, &amp;res2 );           }   } }; Same with “alloca”  template&lt;&gt; struct TaskBodyCPU&lt;TaskSum&gt; {   void operator()( ka::pointer_w&lt;long&gt; r, ka::pointer_r&lt;long&gt; a, ka::pointer_r&lt;long&gt; b )    { *r = *a + *b; } };  template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::pointer_w&lt;long&gt; ptr, const long n )   {       if (n &lt; 2)       *ptr = n;      else {       ka::pointer&lt;long&gt; ptr1 = ka::Alloca&lt;long&gt;(1);       ka::pointer&lt;long&gt; ptr2 = ka::Alloca&lt;long&gt;(1);        ka::Spawn&lt;TaskFibo&gt;() ( ptr1, n-1 );       ka::Spawn&lt;TaskFibo&gt;() ( ptr2, n-2 );        ka::Spawn&lt;TaskSum&gt;() ( ptr, ptr1, ptr2 );           }   } }; How to improve fibo ? Problem2: Two many tasks spawned at each recursion level: one of the recursive spawn may be inline by sequential call Cost of this example over pure C++ sequential version one of the recursive spawn may be inline by sequential call Conclusion about “Fibo” This is not the best way to compute the N-th Fibonacci number All previous presented codes are in the examples/fibo directory fibo_kaapi++.cpp: 1rst version with new + TaskDelete fibo_kaapi++_autopointer.cpp: with ka::auto_pointer fibo_kaapi++_autovar.cpp: with ka::auto_variable fibo_kaapi++_alloca.cpp: with ka::Alloca fibo_kaapi++_opt.cpp: with one seq. call and one spawn Other variations in the same directory cumulative write, using ka::sync,  and with optimization to take into account the current running thread when tasks are spawned Pointer object allocation Resume of previous slides:         Pointer arithmetics  /* using heap allocation =&gt; destruction by the user */       ka::pointer&lt;float&gt; ptr = new float[MAX];        /* using heap allocation =&gt; destruction by the runtime */       ka::auto_pointer&lt;float&gt; ptr = new float[MAX];        /* taking a reference to an global application data */       ka::pointer&lt;float&gt; ptr = &amp;big_application_vector;        /* using Kaapi stack allocation: WARNING limited ressource */       ka::auto_variable&lt;float&gt; var;        /* using Kaapi stack allocation: WARNING limited ressource*/       ka::pointer&lt;int&gt; ptr = ka::Alloca&lt;int&gt;(1); Allowed operations on pointer  Let T any type ka::pointer_w&lt;T&gt; ptr; left value / assignment: ”*ptr = ...” ka::pointer_r&lt;T&gt; ptr; right value ~ T*:  ”std::cout &lt;&lt; *ptr;” ka::pointer_rw&lt;T&gt; ptr; left value / assignment: ”*ptr = ...” right value ~ T*:  ”std::cout &lt;&lt; *ptr;” ka::pointer&lt;T&gt; ptr; constructor with T* value ”ka::pointer&lt;T&gt; ptr = new T;” assignment to T* : ”ptr = new T;” ka::pointer_cw&lt;T,F&gt; ptr; left value : ”*ptr += ...” assumed to be associative C++ pointer arithmetic Increment / decrement by interger Comparizon Difference of pointers Array access Let e an effective reference of type ka::pointer_XX Let f an formal parameter of type ka::pointer_YY The following is allowed: Restriction on passing references   pointer_r	pointer_rp	pointer_rw	pointer_rpwp	pointer_w	pointer_wp pointer	yes	yes	yes	yes	yes	yes pointer_r	yes	yes	no	no	no	no pointer_rp	yes	yes	no	no	no	no pointer_rw	no	no	no	no	no	no pointer_rpwp	yes	yes	yes	yes	yes	yes pointer_w	no	no	no	no	no	no pointer_wp	no	no	no	no	yes	yes formal effective Restriction on passing references   formal effective pointer_r	pointer_rp	pointer_rw	pointer_rpwp	pointer_w	pointer_wp pointer	yes	yes	yes	yes	yes	yes pointer_r	yes	yes	no	no	no	no pointer_rp	yes	yes	no	no	no	no pointer_rw	no	no	yes	no	yes	no pointer_rpwp	yes	yes	yes	yes	yes	yes pointer_w	no	no	no	no	yes	no pointer_wp	no	no	no	no	yes	yes  Extension: terminal recursion yes yes yes Terminal recursive call for_each_rec_xx.cpp Recursive for_each on an array [beg,end) STL approach  Recursive task /* task signature */ template&lt;typename T, typename OP&gt; struct TaskForEach : public ka::Task&lt;3&gt;::Signature&lt;ka::RPWP&lt;T&gt;, ka::RPWP&lt;T&gt;, OP&gt; {};  /* CPU implementation */ template&lt;typename T, typename OP&gt; struct TaskBodyCPU&lt;TaskForEach&lt;T, OP&gt; &gt; {   void operator() ( ka::pointer_rpwp&lt;T&gt; beg, ka::pointer_rpwp&lt;T&gt; end, OP op)    {     if (end-beg &lt; 2)       ka::Spawn&lt;TaskForEachTerminal&lt;T,OP&gt; &gt;()( beg, end, op );     else {       int med = (end-beg)/2;       ka::Spawn&lt;TaskForEach&lt;T,OP&gt; &gt;()( beg, beg+med, op );       ka::Spawn&lt;TaskForEach&lt;T,OP&gt; &gt;()( beg+med, end, op );     }   } };  for_each_rec_xx.cpp Recursive for_each on an array [beg,end) STL approach  Terminal task      RpWp =&gt; RW required to access to data /* task signature */ template&lt;typename T, typename OP&gt; struct TaskForEachTerminal :        public ka::Task&lt;3&gt;::Signature&lt;ka::RW&lt;T&gt;, ka::RW&lt;T&gt;, OP&gt; {};  /* CPU implementation */ template&lt;typename T, typename OP&gt; struct TaskBodyCPU&lt;TaskForEachTerminal&lt;T, OP&gt; &gt; {   void operator() ( ka::pointer_rw&lt;T&gt; beg, ka::pointer_rw&lt;T&gt; end, OP op)    {     std::for_each( beg, end, op );   } }; Some optimizations Better task creation Tasks are pushed into the current thread stack avoid access to the “current thread” keep the same signature   add an extra / optional formal parameter in  the implementation    spawn using the thread: thread-&gt; /* Kaapi Fibo task: takes a pointer to the result + an integer n */ struct TaskFibo: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;int&gt;, int&gt; {}; /* CPU implementation */ template&lt;&gt; struct TaskBodyCPU&lt;TaskFibo&gt; {   void operator() ( ka::Thread* thread,                      ka::pointer_w&lt;int&gt; res, int n ) { ... } }; /* Recursive calls in Fibonacci */ thread-&gt;Spawn&lt;TaskFibo&gt;()( res1, n-1 ); thread-&gt;Spawn&lt;TaskFibo&gt;()( res2, n-2 ); thread-&gt;Spawn&lt;TaskSum&gt;() ( res, res1, res2 ); Passing big value Value = effective parameter is copied 2 times to the internal task argument: Spawn to the user function: function call      Use const T&amp; declaration: copied once /* Stupid task */ struct TaskFAT: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;int&gt;, Matrix&gt; {}; template&lt;&gt; struct TaskBodyCPU&lt;TaskFAT&gt; {   void operator() ( ka::pointer_w&lt;int&gt; res, Matrix M ) { ... } }; ka::Spawn&lt;TaskFAT&gt;()( smallint, bigmatrix );  /* Not so stupid task */ struct TaskFAT: public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;int&gt;, Matrix&gt; {}; template&lt;&gt; struct TaskBodyCPU&lt;TaskFAT&gt; {   void operator() ( ka::pointer_w&lt;int&gt; res, const Matrix&amp; M ) { ... } }; ka::Spawn&lt;TaskFAT&gt;()( smallint, bigmatrix );  Passing big value cont’d If not enough → use pointer     overhead: same as using a C++ pointer the user should consider the life data /* not stupid task */ struct TaskFAT:     public ka::Task&lt;2&gt;::Signature&lt;ka::W&lt;int&gt;,                                   ka::W&lt;Matrix&gt; &gt; {}; template&lt;&gt; struct TaskBodyCPU&lt; TaskFAT &gt; {   void operator() ( ka::pointer_w&lt;int&gt; res, ka::pointer_w&lt;Matrix&gt;M )   { ... } };  ka::Spawn&lt;TaskFAT&gt;()( smallint, &amp;bigmatrix );  http://kaapi.gforge.inria.fr Kaapi is a software developped at http://moais.imag.fr"/>
    <title></title>
    <script type="text/javascript" language="javascript">
//      <![CDATA[
            var images = new Array (52);
            images[0] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.001.png";
            images[1] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.002.png";
            images[2] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.003.png";
            images[3] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.004.png";
            images[4] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.005.png";
            images[5] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.006.png";
            images[6] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.007.png";
            images[7] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.008.png";
            images[8] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.009.png";
            images[9] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.010.png";
            images[10] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.011.png";
            images[11] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.012.png";
            images[12] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.013.png";
            images[13] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.014.png";
            images[14] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.015.png";
            images[15] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.016.png";
            images[16] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.017.png";
            images[17] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.018.png";
            images[18] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.019.png";
            images[19] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.020.png";
            images[20] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.021.png";
            images[21] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.022.png";
            images[22] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.023.png";
            images[23] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.024.png";
            images[24] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.025.png";
            images[25] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.026.png";
            images[26] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.027.png";
            images[27] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.028.png";
            images[28] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.029.png";
            images[29] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.030.png";
            images[30] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.031.png";
            images[31] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.032.png";
            images[32] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.033.png";
            images[33] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.034.png";
            images[34] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.035.png";
            images[35] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.036.png";
            images[36] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.037.png";
            images[37] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.038.png";
            images[38] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.039.png";
            images[39] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.040.png";
            images[40] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.041.png";
            images[41] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.042.png";
            images[42] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.043.png";
            images[43] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.044.png";
            images[44] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.045.png";
            images[45] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.046.png";
            images[46] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.047.png";
            images[47] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.048.png";
            images[48] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.049.png";
            images[49] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.050.png";
            images[50] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.051.png";
            images[51] = "1-xkaapi-dfg.html_files/1-xkaapi-dfg.052.png";
            var index = 0;
            function WindowLoaded(evt)
            {
                document.body.onselectstart = function () { return false; };
            }
            function Step(i)
            {
                GoTo(index + i)
            }
            function GoTo(newIndex)
            {
                if(newIndex >= 0 && newIndex < images.length)
                {
                    index = newIndex;
                    document.Slideshow.src = images[index];
                }
            }
//      ]]>
    </script>
</head>
<body bgcolor="black" onload='WindowLoaded(event);'>
    <p align="center">
        <br/>
        <br/>
        <img name="Slideshow" alt="" src="1-xkaapi-dfg.html_files/1-xkaapi-dfg.001.png" onclick="Step(1)"/>
    </p>
</body>
</html>
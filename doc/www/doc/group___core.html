<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Core</h1>
<p>All the classes in this module are used to defined the reflexive feature of the kernel of KAAPI for workstealing.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_condition.html">Core::Condition</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_condition.html" title="Condition to signal end of steal operationThis class implements one method for synchronisation...">Condition</a> to signal end of steal operationThis class implements one method for synchronisation between a thief and its victim. When a thief thread has successed to steal work from a victim thread, a condition object may be used to express the synchronization of waiting the end of the execution of all theft works. The condition object may be used to wait multiple thiefs before the victim continue.  <a href="class_core_1_1_condition.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_printable.html">Core::Printable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_thread_format.html">Core::ThreadFormat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format for a <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Thread</a>.  <a href="class_core_1_1_thread_format.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_thread.html">Core::Thread</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flow of controlA <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Core::Thread</a> is a flow of control which consist of its runtime environnement (data, registers ...). This is the basic unit to execute part of the program. Multiple thread may be running at the same time, and its depends on the concrete implementation of the class. A <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Core::Thread</a> is also and <a class="el" href="class_core_1_1_work_set.html" title="WorkSet of worksetThe workset is a set of processors with a steal interface to steal...">Core::WorkSet</a> with its own synchronisation object inherited from <a class="el" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors...">Util::Mutex</a>. The difference between a <a class="el" href="class_core_1_1_work_set.html" title="WorkSet of worksetThe workset is a set of processors with a steal interface to steal...">WorkSet</a> and a <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Thread</a> is that <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Thread</a> has no childs (workset). A <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Thread</a> inherits from <a class="el" href="class_util_1_1_thread.html" title="POSIX interface to thread.">Util::Thread</a> the fact that it is a flow of control may be concurrent with other <a class="el" href="class_util_1_1_thread.html" title="POSIX interface to thread.">Util::Thread</a> or <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Core::Thread</a>. A current running thread of control, for instance the main thread of a process, may be attached as a <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Core::Thread</a> by calling the method <a class="el" href="class_core_1_1_thread.html#a6db9200f910dda05fd4ec77208d0d871">Thread::attach_host_thread()</a>. Each created thread on a node with a globalid has an Util::Object::identifier of the form ((gid &lt;&lt; 16)|local_counter).  <a href="class_core_1_1_thread.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_processor_factory.html">Core::ProcessorFactory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component for initialization of the default kind of <a class="el" href="class_core_1_1_processor.html" title="KAAPI ProcessorProcessor manages scheduling of a set of threads with at most one...">Processor</a>.  <a href="class_core_1_1_processor_factory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_work_set_factory.html">Core::WorkSetFactory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component for initialization of the default workset.  <a href="class_core_1_1_work_set_factory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_init.html">Core::Init</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Module initialization for <a class="el" href="namespace_core.html" title="The Core namespace contains definitions for the workstealing algorithm.">Core</a> functionnalities.  <a href="class_core_1_1_init.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_select_victim_interface.html">Core::SelectVictimInterface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual base class for selection of a victim processor.  <a href="class_core_1_1_select_victim_interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_random_victim.html">Core::RandomVictim</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Random work stealing algorithm on a worksetDo random choice of the processor.  <a href="class_core_1_1_random_victim.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_round_robin_victim.html">Core::RoundRobinVictim</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RoundRobin work stealing algorithm on a worksetDo roundrobin choice of the processor.  <a href="class_core_1_1_round_robin_victim.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_work_set_steal_algorithm.html">Core::WorkSetStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_steal_algorithm.html" title="Base class to implement an algorithm for work stealingAll objects that inherit from...">StealAlgorithm</a> on a worksetThis is the base class for stealing over a workset. By default, no instance of this class is attached to the workset, and a workset could not be stolen (invocation to steal always return false).  <a href="class_core_1_1_work_set_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_processor_steal_algorithm.html">Core::ProcessorStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_steal_algorithm.html" title="Base class to implement an algorithm for work stealingAll objects that inherit from...">StealAlgorithm</a> of a K-ProcessorAn instance of this class is attached to each processor.  <a href="class_core_1_1_processor_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_wakeup_first_processor_steal_algorithm.html">Core::WakeupFirstProcessorStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DefaultStealAlgorithm of a K-Processor1/ if local steal then try to wakeup thread 2/ if thief_processor is the attached processor then steal an victim processor 3/ steal task in suspended thread 4/ steal task in active thread 5/ steal on the workset.  <a href="class_core_1_1_wakeup_first_processor_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_random_processor_steal_algorithm.html">Core::RandomProcessorStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Random stealAlgorithm of a K-ProcessorSame as <a class="el" href="class_core_1_1_wakeup_first_processor_steal_algorithm.html" title="DefaultStealAlgorithm of a K-Processor1/ if local steal then try to wakeup thread...">WakeupFirstProcessorStealAlgorithm</a>, select processor in 3/ using random strategy.  <a href="class_core_1_1_random_processor_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_round_robin_processor_steal_algorithm.html">Core::RoundRobinProcessorStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RoundRobin stealAlgorithm of a K-ProcessorSame as <a class="el" href="class_core_1_1_wakeup_first_processor_steal_algorithm.html" title="DefaultStealAlgorithm of a K-Processor1/ if local steal then try to wakeup thread...">WakeupFirstProcessorStealAlgorithm</a>, select processor in 3/ using roundrobin strategy.  <a href="class_core_1_1_round_robin_processor_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_n_u_m_a_processor_steal_algorithm.html">Core::NUMAProcessorStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NUMAStealAlgorithm of a K-Processor1/ if local steal then try to wakeup thread 2/ Steal task from threads 3/ steal the work set.  <a href="class_core_1_1_n_u_m_a_processor_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_idleable.html">Core::Idleable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for object that has idle_activity interface...  <a href="class_core_1_1_idleable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_idleable_with_instance_reification.html">Core::IdleableWithInstanceReification</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for object that allows reification of idle_activity.  <a href="class_core_1_1_idleable_with_instance_reification.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_processor.html">Core::Processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">KAAPI <a class="el" href="class_core_1_1_processor.html" title="KAAPI ProcessorProcessor manages scheduling of a set of threads with at most one...">Processor</a><a class="el" href="class_core_1_1_processor.html" title="KAAPI ProcessorProcessor manages scheduling of a set of threads with at most one...">Processor</a> manages scheduling of a set of threads with at most one active thread at any time. A processor implements the interface signal to handles the signalization mechanism on specific execution points. A processor is attached with an executing thread of control and a native thread of control may be attached to a processor.  <a href="class_core_1_1_processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_steal_algorithm.html">Core::StealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class to implement an algorithm for work stealingAll objects that inherit from <a class="el" href="class_core_1_1_stealable.html" title="Base interface for object that accepts steal request.">Stealable</a> class are able to reify the method invocation steal in order to specify a given algorithm object of class <a class="el" href="class_core_1_1_steal_algorithm.html" title="Base class to implement an algorithm for work stealingAll objects that inherit from...">StealAlgorithm</a>.  <a href="class_core_1_1_steal_algorithm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_stealable.html">Core::Stealable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base interface for object that accepts steal request.  <a href="class_core_1_1_stealable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_stealable_with_instance_reification.html">Core::StealableWithInstanceReification</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for object that accepts steal request with instance reificationInstances of class that inherits from <a class="el" href="class_core_1_1_stealable_with_instance_reification.html" title="Interface for object that accepts steal request with instance reificationInstances...">StealableWithInstanceReification</a> can reify the steal method by providing a object that implements <a class="el" href="class_core_1_1_steal_algorithm.html" title="Base class to implement an algorithm for work stealingAll objects that inherit from...">StealAlgorithm</a> using an invocation of reify method.  <a href="class_core_1_1_stealable_with_instance_reification.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_thread_queue.html">Core::ThreadQueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_thread_queue.html" title="ThreadQueue of threads.">ThreadQueue</a> of threads.  <a href="class_core_1_1_thread_queue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_thread_stack.html">Core::ThreadStack</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_thread_stack.html" title="ThreadStack of threadsLink using _next field of Core::Thread.">ThreadStack</a> of threadsLink using _next field of <a class="el" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement...">Core::Thread</a>.  <a href="class_core_1_1_thread_stack.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_core_1_1_work_set.html">Core::WorkSet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_core_1_1_work_set.html" title="WorkSet of worksetThe workset is a set of processors with a steal interface to steal...">WorkSet</a> of worksetThe workset is a set of processors with a steal interface to steal work from the set of processors. The workset is formed by attaching processors. The default workset is created using the factory <a class="el" href="class_core_1_1_work_set_factory.html" title="Component for initialization of the default workset.">WorkSetFactory</a>. The default number of processors are created using the <a class="el" href="class_core_1_1_processor_factory.html" title="Component for initialization of the default kind of Processor.">ProcessorFactory</a>. Both factory are defined in <a class="el" href="class_core_1_1_init.html" title="Module initialization for Core functionnalities.">Core::Init</a> class.  <a href="class_core_1_1_work_set.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_s_1_1_loc_thread_steal_algorithm.html">WS::LocThreadStealAlgorithm</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">StealAlgorithm of a K-ProcessorAn instance of this class is attached for all instance of Thread.  <a href="class_w_s_1_1_loc_thread_steal_algorithm.html#_details">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>All the classes in this module are used to defined the reflexive feature of the kernel of KAAPI for workstealing. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:51:57 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

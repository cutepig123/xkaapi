<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Util::Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_util.html">Util</a>::<a class="el" href="class_util_1_1_parser.html">Parser</a>
  </div>
</div>
<div class="contents">
<h1>Util::Parser Class Reference</h1><!-- doxytag: class="Util::Parser" -->
<p><code>#include &lt;utils_parser.h&gt;</code></p>

<p><a href="class_util_1_1_parser-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser_1_1_module.html">Module</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_util_1_1_parser_1_1_module_info.html">ModuleInfo</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a6518973f98d157783657e622a6d0e644">Parser</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a21a00e79be9896e1b8ca5b4149d748d4">~Parser</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a3e64b4d1ca0402e69108d4fea24d062a">parse</a> (<a class="el" href="class_util_1_1_properties.html">Properties</a> &amp;initialprop, int &amp;argc, char **&amp;argv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a8a1a9cbf6ef9cd532911ef376b66bcb6">add_parser</a> (const <a class="el" href="class_util_1_1_parser.html">Parser</a> &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a0b12bb1f550e0cff48c60895065d0a98">add_module</a> (const <a class="el" href="class_util_1_1_parser_1_1_module.html">Module</a> *mod, <a class="el" href="class_util_1_1_properties.html">Properties</a> *prop)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a5c92ff6d6400af7dbf7c81f7a7846e1a">add_module</a> (const std::string &amp;name, <a class="el" href="class_util_1_1_properties.html">Properties</a> *prop)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#aad090d63ec6a0f98a938c8856efbb1ff">print_usage</a> (std::ostream &amp;o) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a161758413238ea41b213e3633106ce1f">dump_rc</a> (std::ostream &amp;o) const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#abbf322af819d9d1b3f213e6c2e3e4b2d">Bool2String</a> (bool v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a80f4db93c13b1c36aefd1ead9f766789">String2Bool</a> (const std::string &amp;s)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#ae8aaf6034312970315a6e126b03bcbbd">Long2String</a> (long v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a36c0cea60846fd06f3c8a5991897025b">String2Long</a> (const std::string &amp;s)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a455fd2b9061263eaf89e85c1b92a3ad4">ULong2String</a> (unsigned long v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a0c6f2e0eef0153b2e85aede3793b9056">String2ULong</a> (const std::string &amp;s)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#aadfb845739b4d9c5800c1bee1b61b23f">ULLong2String</a> (unsigned long long v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#aac27819f50567881c7c03d2452accf6e">String2ULLong</a> (const std::string &amp;s)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a4b4bcf5960dda209ed5d66ae889cdaff">Double2String</a> (double v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#adabdf0db7867add793230ab75f579700">String2lstStr</a> (std::list&lt; std::string &gt; &amp;retval, const std::string &amp;s, char delimiter=',')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#afed30059f4269e05fd081e50e117ce82">String2Double</a> (const std::string &amp;s)  throw (InvalidArgumentError)</td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_util_1_1_parser_1_1_module_1_1_options.html">Module::Options</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a9def5ac828a758b081be00d3d3c1f850">Options</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="struct_util_1_1_parser_1_1_module_info.html">ModuleInfo</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#ae3bdae59e65f0dbe779452534a530d4a">AllModules</a></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#aad29868a87abbcdb12d0989312a71ead">set_defaultvalue</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_parser.html#ae3bdae59e65f0dbe779452534a530d4a">AllModules</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_parser.html#a95f7de4e8c6dbc9231cb1e4e389d7998">_lookup</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Paser class Paser class is used to parse command line arguments in order to form properties for a fixed set of predefined module name. The grammar of the command line is the following. moduleoptions -&gt; '--' modulename options | moduleoptions | {} options -&gt; '-'optionname | '-'optionname '=' values | options | {} modulename -&gt; string optionname -&gt; string values -&gt; string string cannot contained '--' or declared options with '-'.</p>
<p>Whatever is the rule for an option, the default value, if not specify on the command line, is 'true'. See example.</p>
<p>Recognized command line aruments are deleted from the command line. The names for modules and options should be declared before parsing the command line and should not appear in the string for values. The output of the parser is for each declared module a properties object that contains strings : for options with values : modulename.optionname=values for options without values : modulename.optionname=true if the option is defined or modulename.optionname=false if the option is not defined</p>
<p>Important remarks. The character '_' in optioname is transformed into '.' in the properties object. For instance 'dummy_option1' defined in modulename has a key 'modulename.dummy.options=...'.</p>
<div class="fragment"><pre class="fragment">
    // My parser will recognized :
    //   --shuttle -velocity 123 -gravity 9.3 -wind -12 
    // as well as 
    //   --shuttle -velocity 123 --toto -gravity 9.3 -wind -12
    // The output display should be (may be in a different order):
    //      shuttle.velocity=123;
    //      shuttle.gravity=9.3;
    //      shuttle.gravity=-12;
    // 
    // While the command line:
    // --shuttle -order 3
    // Produce the following output using '500' as default value for velocity.
    //      shuttle.velocity=500;
    //      shuttle.order=3;
    //
    // Note that command line 
    // --shuttle -order 
    // Will produce the following output:
    //      shuttle.order=true;
    // Because no value has been specify for the order !

    Parser my_parser;
    Properties my_prop;
    
    // form the modules
    Parser::Module shuttle_module("shuttle");
    // option with default value "500"
    shuttle_module.add_option("shuttle", "velocity","500");
    // option without default value
    shuttle_module.add_option("shuttle", "gravity");
    // option without default value
    shuttle_module.add_option("shuttle", "wind");
    // option with default value "2" and the usage for this option.
    shuttle_module.add_option("shuttle", "order", "2", "define the order of the numerical scheme for integration");

    // Add rules to the parser
    my_parser.add_module(shuttle_module, my_prop);

    // parse the command line    
    my_parser.parse( prop, argc, argv );
    
    // display output
    my_prop.print( std::cout );
    </pre></div> <hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae3bdae59e65f0dbe779452534a530d4a"></a><!-- doxytag: member="Util::Parser::AllModules" ref="ae3bdae59e65f0dbe779452534a530d4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string,<a class="el" href="struct_util_1_1_parser_1_1_module_info.html">ModuleInfo</a>*&gt; <a class="el" href="class_util_1_1_parser.html#ae3bdae59e65f0dbe779452534a530d4a">Util::Parser::AllModules</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9def5ac828a758b081be00d3d3c1f850"></a><!-- doxytag: member="Util::Parser::Options" ref="a9def5ac828a758b081be00d3d3c1f850" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_util_1_1_parser_1_1_module_1_1_options.html">Module::Options</a> <a class="el" href="class_util_1_1_parser_1_1_module_1_1_options.html">Util::Parser::Options</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6518973f98d157783657e622a6d0e644"></a><!-- doxytag: member="Util::Parser::Parser" ref="a6518973f98d157783657e622a6d0e644" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::Parser::Parser </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21a00e79be9896e1b8ca5b4149d748d4"></a><!-- doxytag: member="Util::Parser::~Parser" ref="a21a00e79be9896e1b8ca5b4149d748d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::Parser::~Parser </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5c92ff6d6400af7dbf7c81f7a7846e1a"></a><!-- doxytag: member="Util::Parser::add_module" ref="a5c92ff6d6400af7dbf7c81f7a7846e1a" args="(const std::string &amp;name, Properties *prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::add_module </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_properties.html">Properties</a> *&nbsp;</td>
          <td class="paramname"> <em>prop</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declare a new module with a name </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the module name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prop</em>&nbsp;</td><td>the properties object where to store recognized options for this module </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>throw</em>&nbsp;</td><td><a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a> if module is already added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b12bb1f550e0cff48c60895065d0a98"></a><!-- doxytag: member="Util::Parser::add_module" ref="a0b12bb1f550e0cff48c60895065d0a98" args="(const Module *mod, Properties *prop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::add_module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_parser_1_1_module.html">Module</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_properties.html">Properties</a> *&nbsp;</td>
          <td class="paramname"> <em>prop</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add rules from a module. After call to this method, additional options may be added on the returned object but not of the pass by value 'mod' object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mod</em>&nbsp;</td><td>the module </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prop</em>&nbsp;</td><td>the properties object where to store recognized options for this module </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>throw</em>&nbsp;</td><td><a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a> if module has no name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a1a9cbf6ef9cd532911ef376b66bcb6"></a><!-- doxytag: member="Util::Parser::add_parser" ref="a8a1a9cbf6ef9cd532911ef376b66bcb6" args="(const Parser &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::add_parser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_parser.html">Parser</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the rules of parsing from an existing parser </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>the parser </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbf322af819d9d1b3f213e6c2e3e4b2d"></a><!-- doxytag: member="Util::Parser::Bool2String" ref="abbf322af819d9d1b3f213e6c2e3e4b2d" args="(bool v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; Util::Parser::Bool2String </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Conversion methods from some basic type to string and vis et versa Convert a bool to a string </p>

</div>
</div>
<a class="anchor" id="a4b4bcf5960dda209ed5d66ae889cdaff"></a><!-- doxytag: member="Util::Parser::Double2String" ref="a4b4bcf5960dda209ed5d66ae889cdaff" args="(double v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::Parser::Double2String </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a double to a string </p>

</div>
</div>
<a class="anchor" id="a161758413238ea41b213e3633106ce1f"></a><!-- doxytag: member="Util::Parser::dump_rc" ref="a161758413238ea41b213e3633106ce1f" args="(std::ostream &amp;o) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::dump_rc </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump predefined values </p>

</div>
</div>
<a class="anchor" id="ae8aaf6034312970315a6e126b03bcbbd"></a><!-- doxytag: member="Util::Parser::Long2String" ref="ae8aaf6034312970315a6e126b03bcbbd" args="(long v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::Parser::Long2String </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a long to a string </p>

</div>
</div>
<a class="anchor" id="a3e64b4d1ca0402e69108d4fea24d062a"></a><!-- doxytag: member="Util::Parser::parse" ref="a3e64b4d1ca0402e69108d4fea24d062a" args="(Properties &amp;initialprop, int &amp;argc, char **&amp;argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_properties.html">Properties</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialprop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the argc, argv A new command line without recognized arguments are accessible from the new command line generated after parsing through the use of new_argc() and new_argv() methods. All recognized options and their values are stored into the properties object associated with the module name when defined. </p>

</div>
</div>
<a class="anchor" id="aad090d63ec6a0f98a938c8856efbb1ff"></a><!-- doxytag: member="Util::Parser::print_usage" ref="aad090d63ec6a0f98a938c8856efbb1ff" args="(std::ostream &amp;o) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::print_usage </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Display usage informations about all added modules </p>

</div>
</div>
<a class="anchor" id="aad29868a87abbcdb12d0989312a71ead"></a><!-- doxytag: member="Util::Parser::set_defaultvalue" ref="aad29868a87abbcdb12d0989312a71ead" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::Parser::set_defaultvalue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a80f4db93c13b1c36aefd1ead9f766789"></a><!-- doxytag: member="Util::Parser::String2Bool" ref="a80f4db93c13b1c36aefd1ead9f766789" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Util::Parser::String2Bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to a bool </p>

</div>
</div>
<a class="anchor" id="afed30059f4269e05fd081e50e117ce82"></a><!-- doxytag: member="Util::Parser::String2Double" ref="afed30059f4269e05fd081e50e117ce82" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double Util::Parser::String2Double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to a double </p>

</div>
</div>
<a class="anchor" id="a36c0cea60846fd06f3c8a5991897025b"></a><!-- doxytag: member="Util::Parser::String2Long" ref="a36c0cea60846fd06f3c8a5991897025b" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static long Util::Parser::String2Long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to a long </p>

</div>
</div>
<a class="anchor" id="adabdf0db7867add793230ab75f579700"></a><!-- doxytag: member="Util::Parser::String2lstStr" ref="adabdf0db7867add793230ab75f579700" args="(std::list&lt; std::string &gt; &amp;retval, const std::string &amp;s, char delimiter=',')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Util::Parser::String2lstStr </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>retval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delimiter</em> = <code>','</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to a list of string (delimiter is ',') </p>

</div>
</div>
<a class="anchor" id="aac27819f50567881c7c03d2452accf6e"></a><!-- doxytag: member="Util::Parser::String2ULLong" ref="aac27819f50567881c7c03d2452accf6e" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long long Util::Parser::String2ULLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to an unsigned long long </p>

</div>
</div>
<a class="anchor" id="a0c6f2e0eef0153b2e85aede3793b9056"></a><!-- doxytag: member="Util::Parser::String2ULong" ref="a0c6f2e0eef0153b2e85aede3793b9056" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long Util::Parser::String2ULong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a string to an unsigned long </p>

</div>
</div>
<a class="anchor" id="aadfb845739b4d9c5800c1bee1b61b23f"></a><!-- doxytag: member="Util::Parser::ULLong2String" ref="aadfb845739b4d9c5800c1bee1b61b23f" args="(unsigned long long v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::Parser::ULLong2String </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert an unsigned long bool to a string </p>

</div>
</div>
<a class="anchor" id="a455fd2b9061263eaf89e85c1b92a3ad4"></a><!-- doxytag: member="Util::Parser::ULong2String" ref="a455fd2b9061263eaf89e85c1b92a3ad4" args="(unsigned long v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::Parser::ULong2String </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert an unsigned long bool to a string </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a95f7de4e8c6dbc9231cb1e4e389d7998"></a><!-- doxytag: member="Util::Parser::_lookup" ref="a95f7de4e8c6dbc9231cb1e4e389d7998" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_parser.html#ae3bdae59e65f0dbe779452534a530d4a">AllModules</a> <a class="el" href="class_util_1_1_parser.html#a95f7de4e8c6dbc9231cb1e4e389d7998">Util::Parser::_lookup</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="utils__parser_8h.html">utils_parser.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:53:25 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

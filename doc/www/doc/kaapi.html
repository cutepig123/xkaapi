<html lang="en">
<head>
<title>kaapi</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="kaapi">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for KAAPI (version 2.4.1, 16 June 2010),
Hyantes is free software; you can redistribute it and/or modify
it under the terms of the GPL License

Copyright (C) 2007 LIG-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
pre, hr, code, .file, .command, .option, h1, h2, h3, h4, h5 { color: #007676; }
pre { border:thin dashed #808080; }

pre {
    padding:2px;
    margin-left:2%;
    width:90%;
}

address {
    margin-left:1%;
}

div.contents {
    border-left:thin dashed #808080;
    margin-left:1%;
}

code, .command, .option {
    font-size:100%;
    /*border:thin dashed #808080;*/
    font-family:monospace;
    font-weight:bolder;
    padding:2px;
}

.node {
    font-size:70%;
}


a:link, a:visited, a:hover {
	color: #666666;
}

a.download:before {
    content:url(download.png);
}
/*
p a:before {
    content:url(url.png)
}
*/
dt:before {
    content:url(circle.png);
}

body {
  font-family: arial, serif;
  background-color: #ffffff;
  margin: 0px auto 10px auto;
  padding: 0px;
}

p, dl {
    margin: 5px 10px 10px 10px;
	line-height: 130%;
}

ul li {
  margin: 5px 0px 5px 0px;
}

h1 {
    font-size:200%;
    font-variant:small-caps;
    margin: 10px 10px 10px 10px;
    text-align: center;
}

h2 {
    font-variant:small-caps;
	font-size: 110%;
    margin: 10px 10px 5px 2px;
}

h3 {
	font-size: 100%;
    margin: 10px 10px 5px 4px;
}
h4 {
	font-size: 100%;
    margin: 10px 10px 5px 6px;
}
h5 {
	font-size: 100%;
    margin: 10px 10px 5px 8px;
}

.menu {
  margin-top: 5px;
  margin-bottom: 15px;
  list-style-image: url("arrow.png");
}
	

ul {
  margin-top: 5px;
  margin-bottom: 15px;
  list-style-image: url("arrow.png");
}

hr {
  border: 1;
  width: 80%;
  text-align:left;
}

--></style>
</head>
<body>
<h1 class="settitle">kaapi</h1>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Kaapi</a>
<li><a name="toc_kaapi-overview" href="#kaapi-overview">1 Overview</a>
<li><a name="toc_install-guide" href="#install-guide">2 Quick installation guide of KAAPI</a>
<ul>
<li><a href="#get-the-source">2.1 Get the source</a>
<li><a href="#compile-the-package">2.2 Compile the package</a>
<ul>
<li><a href="#configure">2.2.1 Configuring</a>
<ul>
<li><a href="#git-users">2.2.1.1 For git users only</a>
<li><a href="#all-users">2.2.1.2 For all users</a>
</li></ul>
<li><a href="#make">2.2.2 Compiling</a>
<li><a href="#make-install">2.2.3 Installing</a>
</li></ul>
</li></ul>
<li><a name="toc_compile-and-run" href="#compile-and-run">3 Compile and Run Athapascan programs</a>
<ul>
<li><a href="#compile">3.1 Compiling Athapascan program</a>
<ul>
<li><a href="#setting-environment">3.1.1 Setting up an environment to compile Athapascan programs</a>
<li><a href="#compile-with-pkg_002dconfig">3.1.2 Using the pkg-config tool</a>
<li><a href="#compile-with-environment-variables">3.1.3 Using environment variables</a>
</li></ul>
<li><a href="#run">3.2 Running an Athapascan program</a>
<ul>
<li><a href="#single-instance">3.2.1 Running a single instance of the program</a>
<li><a href="#multiple-instance">3.2.2 Running multiple instances of the program on several machines</a>
</li></ul>
</li></ul>
<li><a name="toc_Athapascan" href="#Athapascan">4 Athapascan Concept</a>
<ul>
<li><a href="#programming-model">4.1 Programming Model</a>
<ul>
<li><a href="#task-description">4.1.1 Task description</a>
<ul>
<li><a href="#task-definition">4.1.1.1 Task definition</a>
<li><a href="#task-parameters">4.1.1.2 Task parameters</a>
</li></ul>
<li><a href="#task-samples">4.1.2 Task samples</a>
<ul>
<li><a href="#from-a-procedure">4.1.2.1 From a <code>C</code> procedure</a>
</li></ul>
<li><a href="#shared-memory">4.1.3 Shared memory</a>
<ul>
<li><a href="#serialize-parameters">4.1.3.1 Serialize parameters</a>
<li><a href="#dependencies-description">4.1.3.2 Dependencies description</a>
</li></ul>
</li></ul>
<li><a href="#programing-environnment">4.2 Programming environment</a>
<ul>
<li><a href="#initialize-the-library">4.2.1 Initialize the library</a>
<li><a href="#define-task">4.2.2 Define task</a>
<li><a href="#spawn-task">4.2.3 Spaw task</a>
</li></ul>
<li><a href="#performance">4.3 When speed matters</a>
<li><a href="#additionnal-features">4.4 Additionnal feeatures</a>
<ul>
<li><a href="#global-memory">4.4.1 Global memory</a>
<li><a href="#sharing-arrays">4.4.2 Sharing arrays</a>
<ul>
<li><a href="#arrays-through-structures">4.4.2.1 Arrays through structures</a>
<li><a href="#arrays-through-verctors">4.4.2.2 Arrays through verctors</a>
<li><a href="#arrays-through-iterators">4.4.2.3 Arrays through iterators</a>
</li></ul>
<li><a href="#control-task-creation">4.4.3 Control task creation</a>
<li><a href="#use-classical-algorithms">4.4.4 Use classical algorithms</a>
</li></ul>
</li></ul>
<li><a name="toc_tutorials" href="#tutorials">5 Athapascan tutorials</a>
<ul>
<li><a href="#hello-world">5.1 Hello World - 1 Fork, 0 Shared</a>
<li><a href="#fibonacci">5.2 Fibonacci - multiple Fork and Shared</a>
</li></ul>
<li><a name="toc_API" href="#API">6 Athapascan Application Programming Interface</a>
<ul>
<li><a href="#fork">6.1 Fork</a>
<li><a href="#shared">6.2 Shared</a>
<li><a href="#monotonic-bound">6.3 MonotonicBound</a>
<li><a href="#synchronized-blocks">6.4 SyncGuard</a>
<li><a href="#algorithms">6.5 Algorithms</a>
<li><a href="#utilities">6.6 Utilities</a>
<li><a href="#dynamically-loaded-modules">6.7 Dynamically Loaded Modules - enhance kaapi</a>
<ul>
<li><a href="#dlm-api">6.7.1 API - interface required for a Dynamically loaded module</a>
<li><a href="#load-dlm">6.7.2 Command Line Interface - interface to load extra modules from the kaapi command line</a>
</li></ul>
</li></ul>
<li><a name="toc_function-methods-and-classes-index" href="#function-methods-and-classes-index">Function, methods and classes index</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#kaapi-overview">kaapi overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Kaapi</h2>

<p>This manual is for Kaapi library (version 2.4.1, 16 June 2010).

<ul class="menu">
<li><a accesskey="1" href="#kaapi-overview">kaapi overview</a>:  Overview of the package
<li><a accesskey="2" href="#install-guide">install guide</a>:  Installation guide
<li><a accesskey="3" href="#compile-and-run">compile and run</a>:  Link program with <code>KAAPI</code>
<li><a accesskey="4" href="#Athapascan">Athapascan </a>:  Detailed overview of Kaapi content
<li><a accesskey="5" href="#tutorials">tutorials</a>:  understand the basics
<li><a accesskey="6" href="#API">API </a>:  functions and classes exported by the Kaapi library
<li><a accesskey="7" href="#function-methods-and-classes-index">function methods and classes index </a>:  quickly find your way in the api
</ul>
<!-- * contacts :: flame or grats the authors -->

<div class="node">
<a name="kaapi-overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#install-guide">install guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Overview</h2>

<p>KAAPI means Kernel for Adaptative, Asynchronous Parallel and Interactive programming. It is a C++ library that allows to execute multithreaded computation with data flow synchronization between threads. The library is able to schedule fine/medium size grain program on distributed machine. The data flow graph is dynamic (unfold at runtime). Target architectures are clusters of SMP machines.

   <p>Main features are

     <ul>
<li>It is based on work-stealing algorithms ;
<li>It can run on various processors ;
<li>It can run on various architectures (clusters or grids) ;
<li>It contains non-blocking and scalable algorithms ;
</ul>

<!--  -->
<div class="node">
<a name="install-guide"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#compile-and-run">compile and run</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#kaapi-overview">kaapi overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Quick installation guide of KAAPI</h2>

<p>In order to use the <code>Athapascan</code>'s API, you need to install <code>KAAPI</code> library. 
The following steps will help you to do it.

<ul class="menu">
<li><a accesskey="1" href="#get-the-source">get the source</a>:  download the library
<li><a accesskey="2" href="#compile-the-package">compile the package</a>:  <samp><span class="command">./configure; make; make install</span></samp>
</ul>

<div class="node">
<a name="get-the-source"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#compile-the-package">compile the package</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#install-guide">install guide</a>

</div>

<h3 class="section">2.1 Get the source</h3>

<p>There are several ways to get <code>KAAPI</code> source files:

     <ul>
<li>You can download the latest stable version available at: <a href="https://gforge.inria.fr/frs/?group_id=94">https://gforge.inria.fr/frs/?group_id=94</a>

     <li>You can also get a tarball of the latest git sources (rebuilt every night): <a href="http://kaapi.gforge.inria.fr/snapshots/kaapi-svn.tar.gz">http://kaapi.gforge.inria.fr/snapshots/kaapi-svn.tar.gz</a>. Please note that if current git version fails to pass the <samp><span class="command">make distchek</span></samp> test, the tarball won't be built (i.e. you will download the latest tarball that pass <samp><span class="command">make distchek</span></samp>).

     <li>At least, you can use the anonymous git server if you want to keep updating sources (but sometimes, sources are totally broken here):
</ul>

<pre class="example">     $ <samp><span class="command">git</span></samp> clone git://git.ligforge.imag.fr/git/kaapi/kaapi.git kaapi-git
</pre>
   <div class="node">
<a name="compile-the-package"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#get-the-source">get the source</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#install-guide">install guide</a>

</div>

<h3 class="section">2.2 Compile the package</h3>

<p>The following details the weel known <samp><span class="command">./configure; make; make install</span></samp> steps.

<ul class="menu">
<li><a accesskey="1" href="#configure">configure</a>: <samp><span class="command">./configure</span></samp>
<li><a accesskey="2" href="#make">make</a>: <samp><span class="command">make</span></samp>
<li><a accesskey="3" href="#make-install">make install</a>: <samp><span class="command">make</span></samp> install
</ul>

<div class="node">
<a name="configure"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#make">make</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile-the-package">compile the package</a>

</div>

<h4 class="subsection">2.2.1 Configuring</h4>

<p>Depending on how you got <code>KAAPI</code> you may need to perform some additionnal actions.

<ul class="menu">
<li><a accesskey="1" href="#git-users">git users</a>:  For git users only
<li><a accesskey="2" href="#all-users">all users</a>:  git and non git users
</ul>

<div class="node">
<a name="git-users"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#all-users">all users</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#configure">configure</a>

</div>

<h5 class="subsubsection">2.2.1.1 For git users only</h5>

<p><code>KAAPI</code> uses GNU <samp><span class="command">autoconf</span></samp> and <samp><span class="command">automake</span></samp> tools to simplify its configuration. 
For <samp><span class="command">git</span></samp> users, they must run the following script in the source directory to generate autoconf/automake/libtool files (make sure that you have these development tools available on your system). 
This has already been done When you use the first two other ways to get <code>KAAPI</code> sources.

   <p><strong>NOTE</strong>: In the following, replace &lt;<var>kaapi_src_dir</var>&gt; by the directory where you have gotten kaapi

<pre class="example">     $ cd &lt;<var>kaapi_src_dir</var>&gt; &amp;&amp; ./bootstrap
</pre>
   <div class="node">
<a name="all-users"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#git-users">git users</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#configure">configure</a>

</div>

<h5 class="subsubsection">2.2.1.2 For all users</h5>

<p>You can check whether a configure file has been created in the source directory.

   <p>If you want to use more configure options, please read its documentation:
<pre class="example">     $ <samp><span class="command">./configure</span></samp> <samp><span class="option">--help</span></samp>
</pre>
   <p>It is better that KAAPI source files are compiled in a different directory from the source code directory. We suggest you create a directory named build:

<pre class="example">     $ cd ..
     $ mkdir build ; cd build
</pre>
   <p>In the build directory, you now can launch the configure script, using
<samp><span class="option">--prefix</span></samp>=&lt;<var>install dir</var>&gt; option to choose an installation path which will be
the root of the installation directory (header files, archive, script,etc. will
be put here).  This installation directory must be different from the source
directory (and the build directory).

   <p><strong>NOTE</strong>: Source (and build) directory can be removed after the
KAAPI library is compiled and installed. The installation directory must be
kept to be able to compile and run KAAPI applications

<pre class="example">     $ ../&lt;kaapi_src_dir&gt;/configure --prefix=$HOME/KAAPI
</pre>
   <div class="node">
<a name="make"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#make-install">make install</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#configure">configure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile-the-package">compile the package</a>

</div>

<h4 class="subsection">2.2.2 Compiling</h4>

<p>Concerning Compilers : we ensure that KAAPI can be well compiled with the following compilers:

     <ul>
<li><samp><span class="command">g++-3.4</span></samp> (deprecated)
<li><samp><span class="command">g++-4.1</span></samp> to <samp><span class="command">g++-4.3</span></samp>
</ul>

   <p><strong>WARNING</strong>: On Itanium, version 4 or greater is required, older version (especially 3.4) are not supported

   <p>To compile the library, just run <samp><span class="command">make</span></samp> in the build directory:

<pre class="example">     $ <samp><span class="command">make</span></samp>
</pre>
   <p>It may take some time. You can also read make documentation to have more compiling options.

<div class="node">
<a name="make-install"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#make">make</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile-the-package">compile the package</a>

</div>

<h4 class="subsection">2.2.3 Installing</h4>

<p>If the previous steps succeed, then the installation of the library is simple. 
(Note: depending on your installation path specified by the prefix option during the previous configuration, you may need root privileges).

<pre class="example">     $ <samp><span class="command">make</span></samp> install
</pre>
   <p>Congratulation, you can now use <code>Athapascan</code> and <code>KAAPI</code> !

<div class="node">
<a name="compile-and-run"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Athapascan">Athapascan</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#install-guide">install guide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Compile and Run Athapascan programs</h2>

<p>This chapter details the basic steps needed to compile a source code linked with <code>KAAPI</code>,
and how to run it.

<ul class="menu">
<li><a accesskey="1" href="#compile">compile</a>: Compiling Athapascan program
<li><a accesskey="2" href="#run">run</a>: Running Athapascan program
</ul>

<div class="node">
<a name="compile"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#run">run</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile-and-run">compile and run</a>

</div>

<h3 class="section">3.1 Compiling Athapascan program</h3>

<p>Once <code>KAAPI</code> is installed (see <a href="#install-guide">install guide</a>), there are two ways to compile an <code>Athapascan</code> program. 
You can either use the help of the pkg-config program if you have it installed or
you can use environment variables.

<ul class="menu">
<li><a accesskey="1" href="#setting-environment">setting environment</a>:  if <code>KAAPI</code> is not installed in default location
<li><a accesskey="2" href="#compile-with-pkg_002dconfig">compile with pkg-config</a>:  the modern way
<li><a accesskey="3" href="#compile-with-environment-variables">compile with environment variables</a>:  the old way
</ul>

<div class="node">
<a name="setting-environment"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#compile-with-pkg_002dconfig">compile with pkg-config</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile">compile</a>

</div>

<h4 class="subsection">3.1.1 Setting up an environment to compile Athapascan programs</h4>

<p>If you use environment variables or if KAAPI is not installed in system
directories (usually if you did not use the &ldquo;&ndash;prefix=/usr&ldquo; with the configure
script), you need to setup your environment.

   <p>You can either start a new shell
<pre class="example">     $ $HOME/kaapi/bin/kaapish --mode=devel --flags
     $ # replace $HOME/kaapi by the prefix used with the configure script
</pre>
   <p>or you can add environment variables in the current shell
<pre class="example">     $ eval `$HOME/kaapi/bin/kaapish --shell --mode=devel --flags`
     $ # replace $HOME/kaapi by the prefix used with the configure script
</pre>
   <p>In the latter case (adding to the current environment), you can add
the line in your shell rc file (<samp><span class="file">.bashrc</span></samp>, <samp><span class="file">.tcshrc</span></samp>, ...) to avoid to
type it each time.

   <p>If <samp><span class="command">kaapish</span></samp> does not correctly detect your kind of shell, you can specify it
<pre class="example">     $ eval `$HOME/kaapi/bin/kaapish --shell=sh --mode=devel --flags`
     $ # replace $HOME/kaapi by the prefix used with the configure script
</pre>
   <p>More detail about the <samp><span class="command">kaapish</span></samp> command can be found in its man page kaapish(1)

<div class="node">
<a name="compile-with-pkg-config"></a>
<a name="compile-with-pkg_002dconfig"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#compile-with-environment-variables">compile with environment variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#setting-environment">setting environment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile">compile</a>

</div>

<h4 class="subsection">3.1.2 Using the pkg-config tool</h4>

<p>Once you setup an correct environment or if you installed KAAPI in system
directories (usually if you use the <samp><span class="option">--prefix=/usr</span></samp> with the configure script),
you can compile and link with the correct flags by requesting them to
<samp><span class="command">pkg-config</span></samp> as for any other library managed by <samp><span class="command">pkg-config</span></samp>:
<pre class="example">     $ g++ -c atha_test.cpp `pkg-config --cflags kaapi` # compiling step
     $ g++ -o atha_test atha_test.o `pkg-config --libs kaapi` # linking step
</pre>
   <div class="node">
<a name="compile-with-environment-variables"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#compile-with-pkg_002dconfig">compile with pkg-config</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile">compile</a>

</div>

<h4 class="subsection">3.1.3 Using environment variables</h4>

<p>Once you setup an correct environment, you can compile and link with the
correct flags by using the new defined environment variables:
<pre class="example">     $ g++ -c atha_test.cpp $ATHAPASCAN1_CPPFLAGS # compiling step
     $ g++ -o atha_test atha_test.o $ATHAPASCAN1_LDFLAGS # linking step
</pre>
   <div class="node">
<a name="run"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#compile">compile</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#compile-and-run">compile and run</a>

</div>

<h3 class="section">3.2 Running an Athapascan program</h3>

<p>If you have not installed KAAPI in a system-wide location, you will need to use
kaapish(1) (or karun(1) to run on several machines, see below) so that environment variables are
correctly defined.

<ul class="menu">
<li><a accesskey="1" href="#single-instance">single instance</a>:  run program on a single computer
<li><a accesskey="2" href="#multiple-instance">multiple instance</a>:  run program on cluster
</ul>

<div class="node">
<a name="single-instance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#multiple-instance">multiple instance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#run">run</a>

</div>

<h4 class="subsection">3.2.1 Running a single instance of the program</h4>

<p>You can run the program directly:
<pre class="example">     $ $HOME/kaapi/bin/kaapish ./atha_test
     $ # replace $HOME/kaapi by the prefix used with the configure script
</pre>
   <p>Or you can update environment variables in your shell to be able to run your
program:
<pre class="example">     $ eval `$HOME/kaapi/bin/kaapish --shell --mode=run`
     $ # replace $HOME/kaapi by the prefix used with the configure script
     $ ./atha_test
</pre>
   <p><strong>NOTE</strong>: in case you already setup an environment to compile KAAPI program or
if you installed KAAPI in system directories (usually if you use the
<samp><span class="option">--prefix=/usr</span></samp> with the configure script), you already have a correct
environment to run Athapascan programs. So you can run it immediately (the last
line of the previous example)

   <p>Of cause, you can use a more featured program, for example <samp><span class="command">fibo_apiatha</span></samp>
(in this example, no running environment is previously setup, so <samp><span class="command">kaapish</span></samp> is
used)
<pre class="example">     $ $HOME/kaapi/bin/kaapish ./fibo_apiatha 30 15
                               #30: the 30-th fibonacci number
                               #15: threshold to stop recursive
</pre>
   <p><strong>NOTE</strong>: self documentation of KAAPI is displayed by the command line argument
<samp><span class="option">--help</span></samp>.  All KAAPI script or program compiled with KAAPI accept this option.

   <p>For instance:
<pre class="example">     $ $HOME/kaapi/bin/kaapish --help
     $ $HOME/kaapi/bin/kaapish ./fibo_apiatha --help
</pre>
   <p>One particular option is <samp><span class="option">--dumprc</span></samp> in order to dump default value of
properties into the file <samp><span class="file">dump.rc</span></samp> in order to change them for next run. KAAPI
looks for a properties' file named <samp><span class="file">kaapi.rc</span></samp> in <samp><span class="env">$HOME</span></samp> and <samp><span class="env">$PWD</span></samp>.

<div class="node">
<a name="multiple-instance"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#single-instance">single instance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#run">run</a>

</div>

<h4 class="subsection">3.2.2 Running multiple instances of the program on several machines</h4>

<p>To run the same program on several machines, the user may use the <samp><span class="command">karun</span></samp>
command:

<pre class="example">     $ $HOME/kaapi/bin/karun --np &lt;#processes&gt; -f &lt;hostnames&gt; ./fibo_apiatha 30 15
</pre>
   <p>Note that if <samp><span class="command">kaapish</span></samp> is not in you <samp><span class="env">$PATH</span></samp> when executing an <samp><span class="command">ssh</span></samp> on remote
machines (check with <code>ssh &lt;machine&gt; which kaapish</code>), you will need to specify
it to <samp><span class="command">karun</span></samp>:
<pre class="example">     $ $HOME/kaapi/bin/karun --wrapper-binary kaapish=/path/on/remote/node/kaapish \
         --np &lt;#processes&gt; -f &lt;hostnames&gt; ./fibo_apiatha 30 15
</pre>
   <p>more detail about this command can be found in the man page karun(1)

   <p><strong>NOTE</strong>: if you want to run your programm on a single machine but still want to
use several threads, you can use:
<pre class="example">     $ $HOME/kaapi/bin/kaapish ./myprog --community -thread.poolsize n my args
                                     # n is the number of threads
</pre>
   <!--  -->
<div class="node">
<a name="Athapascan"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tutorials">tutorials</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#compile-and-run">compile and run</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Athapascan Concept</h2>

<p>Let us dive into KAAPI through its main interface, <code>Athapascan</code>

<ul class="menu">
<li><a accesskey="1" href="#programming-model">programming model</a>:  forget message passing library, and learn a task based one
<li><a accesskey="2" href="#programing-environnment">programing environnment</a>:  from the model to the code
<li><a accesskey="3" href="#performance">performance</a>:  When speed matters
<li><a accesskey="4" href="#additionnal-features">additionnal features</a>:  things that can be useful
</ul>

<!--  -->
<div class="node">
<a name="programming-model"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#programing-environnment">programing environnment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Athapascan">Athapascan</a>

</div>

<h3 class="section">4.1 Programming Model</h3>

<ul class="menu">
<li><a accesskey="1" href="#task-description">task description</a>:  What is a task ? 
<li><a accesskey="2" href="#shared-memory">shared memory</a>:  Distributed memory model
<li><a accesskey="3" href="#task-samples">task samples</a>:  some kind of tasks
</ul>

<p><code>KAAPI</code> is a middleware working on Dynamic Acyclic Data flow graphes. 
Once given this graph, it can dynamically schedule it using a work-stealing algorithm.

   <p>But most distributed computing users are familiar with message passing paradigm, and <code>KAAPI</code> uses an other paradigm:
     <ol type=1 start=1>
<li>Describe the task of your graph / program
<li>Describe the dependencies between your task
        </ol>

   <p>Once this is done, <code>KAAPI</code> will schedule the taks in an efficient way, making sure that

     <ol type=1 start=1>
<li>All dependencies are respected
<li>Parallelism between independant tasks is used as much as possible
        </ol>

   <p>Of course, this will not work as expected on all kind of graph, but it has been <em>proven</em> to be an
asymptotically optimal way to schedule tasks from a divided and conquer algorithm, based on <code>fork</code> and <code>join</code> calls.

<!--  -->
<div class="node">
<a name="task-description"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#shared-memory">shared memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programming-model">programming model</a>

</div>

<h4 class="subsection">4.1.1 Task description</h4>

<p>A task in <code>Athapascan</code> is more or less a function object with no side effect. 
A task execution is somewhat similar to a standard procedure call (Tasks are dynamically created at run time). 
The only difference is that the created task's execution is fully asynchronous, meaning the creator is not waiting for the execution of the created task to finish to continue with its own execution. 
So an <code>Athapascan</code> program can be seen as a set of tasks scheduled by the library and distributed among nodes for its execution.

<ul class="menu">
<li><a accesskey="1" href="#task-definition">task definition</a>:  how to define a task
<li><a accesskey="2" href="#task-parameters">task parameters</a>:  how to pass parameters to a task
</ul>

<!--  -->
<div class="node">
<a name="task-definition"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#task-parameters">task parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#task-description">task description</a>

</div>

<h5 class="subsubsection">4.1.1.1 Task definition</h5>

<p>A task corresponds to the execution of a  function object, i.e. an object from a class (or structure) having the <code>void operator()(...)</code> defined:
<pre class="example">     struct <var>user_task</var>
     {
       void operator() ( /* formal parameters */ )
       {
         /*...*/
       }
     };
</pre>
   <p>A sequential (hence not asynchronous !) call to this function class is written in C++:

<pre class="example">     user_task() ( /* effective parameters */ ) ;
</pre>
   <p>And an asynchronous call to this <em>task</em> is written in <code>Athapascan</code>:

<pre class="example">     a1::Fork&lt; <var>user_task</var> &gt; () ( /* effective parameters */ ) ;
</pre>
   <p>See <a href="#API">API</a> for a detailed description of the <code>a1::Fork</code> usage.

   <p>Note that this does <em>not</em> provide a way to describe dependencies between tasks. 
Dependencies are described through the use of <em>formal parameters</em>.

<!--  -->
<div class="node">
<a name="task-parameters"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#task-definition">task definition</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#task-description">task description</a>

</div>

<h5 class="subsubsection">4.1.1.2 Task parameters</h5>

<p>In C++, the formal parameters can be either passed by
     <dl>
<dt><em>copy</em><dd>It as a read only meaning: parameters passed by copy are read by the function, but cannot be modified. 
It is a <em>read dependency</em>.

     <br><dt><em>reference</em><dd>It as a read / write meaning: parameters can be read and modified by the function. 
If the parameter is only written, it is a <em>write dependency</em>. 
Otherwise it is a  <em>read write dependency</em>.

   </dl>

   <p>Unlike functions, tasks will be used in a distibuted environment
and their parameters will
     <ul>
<li>influence their scheduling;
<li>need to be shared acroos the network  (see <a href="#serialize-parameters">serialize parameters</a>). 
</ul>

   <p>Here are the different kinds of parameters allowed for a task:

     <dl>
<dt><code>T</code><dd>designate a classical <code>C++</code> type that does not affect shared memory. 
However this type must be communicable (see <a href="#serialize-parameters">serialize parameters</a>). 
It will be copied twice with every call. 
It is a <em>read dependency</em>.

     <br><dt><code>const T &amp;</code><dd>designate a classical constant reference to a <code>C++</code> type that does not affect shared memory. 
As the above, the type must be communicable (see <a href="#serialize-parameters">serialize parameters</a>), but it will suffer one less copy. 
It is a <em>read dependency</em>.

     <br><dt><code>Shared_...&lt; T &gt;</code><dd>designate a parameter that is a reference to a shared object located in the shared memory. 
<code>T</code> is the type of this object. 
<code>T</code> must also be communicable (see <a href="#serialize-parameters">serialize parameters</a>). 
As explained in <a href="#shared-memory">shared memory</a>, it is the <code>Athapascan</code> way of describing <em>read dependency</em>,
<em>write dependency</em> or <em>read write dependency</em>.

   </dl>

   <p>The following kind of parameters are <em>not</em> allowed for a task.
     <dl>
<dt><code>T*</code><dd>pointers are linked to local memory. 
There is no sense in sharing pointers over distibuted memory. 
<br><dt><code>T&amp;</code><dd>reference are linked to local memory. 
There is no sense in sharing pointers over distibuted memory. 
An interesting exception is <code>const</code> references. 
We know that the object will not be modified, so it can be passed by copy. 
</dl>

<div class="node">
<a name="task-samples"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#shared-memory">shared memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programming-model">programming model</a>

</div>

<h4 class="subsection">4.1.2 Task samples</h4>

<ul class="menu">
<li><a accesskey="1" href="#from-a-procedure">from a procedure</a>:  <code>C</code> procedure to <code>Athapscan</code> task
</ul>

<div class="node">
<a name="from-a-procedure"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#task-samples">task samples</a>

</div>

<h5 class="subsubsection">4.1.2.1 From a <code>C</code> procedure</h5>

<p>Obviously, a <code>C</code> procedure (i.e. a <code>C</code> function with void as return type) can be directly encapsulated in a <code>C++</code> function class. 
It becomes a task for Athapascan. 
Here is an example:

<pre class="example">     /* c procedure */
     void f ( int i )
     {
         printf( "what could I compute with %d ? \n", i );
     }
</pre>
   <p>The transformation to a function class is straight forward:
<pre class="example">     /* encapsulated procedure */
     struct f_encapsulated
     {
       void operator() ( a1::Shared_r&lt;int&gt; i ) /* i is some formal parameter*/
       {
         f( i.read() );
       }
     };
</pre>
   <!--  -->
<div class="node">
<a name="shared-memory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#task-samples">task samples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#task-description">task description</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programming-model">programming model</a>

</div>

<h4 class="subsection">4.1.3 Shared memory</h4>

<p>In the message passing paradigm, developpers manually manage send and receive of data across running programs. 
In <code>Athapascan</code>, the message are sent by the middleware to share variable among tasks. 
The user does <em>not</em> need to manage the send and receive, but he must still

<ul class="menu">
<li><a accesskey="1" href="#serialize-parameters">serialize parameters</a>:  manage the serialization of data sent over the network
<li><a accesskey="2" href="#dependencies-description">dependencies description</a>:  manage dependecies through task parameters read acces
</ul>

<!--  -->
<div class="node">
<a name="serialize-parameters"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#dependencies-description">dependencies description</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#shared-memory">shared memory</a>

</div>

<h5 class="subsubsection">4.1.3.1 Serialize parameters</h5>

<p>Using a distributed architecture means handling data located in shared memory (mapping, migration, consistency). 
This implies a serialization step for the arguments of tasks. 
This serialization has to be explicitly done by the programmer to suit the specific needs of the program.

   <p><code>Athapascan</code> already handles some types:
     <ul>
<li>the following <code>C++</code> basic types
<pre class="verbatim">     char
     short
     int
     long
     float
     double
</pre>
<li>some types from the STL
<pre class="verbatim">     vector&lt;...>
     string
     pair&lt;...,...>
</pre>
</ul>

   <p>Using this communicable types, you can define other communicable types. 
To do this, a type <var>T</var> must have
     <ul>
<li>an empty constructor: <var>T</var><code>()</code> ;
<li>a copy constructor: <var>T</var><code>(const &amp; </code><var>T</var><code>)</code> ;
<li>a serializing operator: <code>a1::OStream&amp; operator&lt;&lt;( a1::OStream&amp; </code><var>output_stream</var><code>, const </code><var>T</var><code>&amp; </code><var>x</var><code> )</code>
which puts into the <var>output_stream</var> the information needed to reconstruct an image of <var>x</var> using the <code>operator &gt;&gt;</code> ;
<li>a deserializing operator: <code>a1::IStream&amp; operator&gt;&gt;( a1::IStream&amp; </code><var>input_stream</var><code>, </code><var>T</var><code>&amp; </code><var>x</var><code>)</code>
which takes from the <var>input_stream</var> the information needed to construct the object <var>x</var>; it initializes <var>x</var> with the value related to the information from  <var>input_stream</var>. 
</ul>

   <p>Following code shows a simple way to serialize a class:

<pre class="example">     struct Complex
     {
       double x;
       double y;
     
       //empty constructor
       Complex()
         :x(0),y(0) {}
     
       //copy constructor
       Complex( const Complex&amp; <var>z</var>)
         :x(<var>z</var>.x),y(<var>z</var>.y) {}
     
     };
     
     //packing operator
     a1::OStream&amp; operator&lt;&lt; (a1::OStream&amp; <var>out</var>, const Complex&amp; <var>z</var>)
     {
       return <var>out </var>&lt;&lt; <var>z</var>.x &lt;&lt; <var>z</var>.y;
     }
     
     //unpacking operator
     a1::IStream&amp; operator&gt;&gt; (a1::IStream&amp; <var>in</var>, Complex&amp; <var>z</var>)
     {
       return <var>in </var>&gt;&gt; <var>z</var>.x&gt;&gt; <var>z</var>.y;
     }
</pre>
   <!--  -->
<div class="node">
<a name="dependencies-description"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#serialize-parameters">serialize parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#shared-memory">shared memory</a>

</div>

<h5 class="subsubsection">4.1.3.2 Dependencies description</h5>

<p>In order to respect the sequential consistency (lexicographic order semantic), <code>Athapascan</code> has to identify the value related to a shared object for each read performed. 
Parallelism detection is easily possible in the context that any task specifies the shared data objects that it will access during its execution (on-the-fly detection of independent tasks), and which type of access it will perform on them (on-the-fly detection of a task's precedence). 
All manipulated shared data must be declared in the prototype of the task, and to detect the synchronizations between tasks, according to lexicographic semantic, any shared parameter of a task is tagged in the prototype according to the access performed on it. 
This tag indicates what kind of manipulation the task (and, due to the lexicographic order semantics, all the sub-tasks it will fork) is allowed to perform on the shared object. 
This tag is called the access right; it appears in the prototype of the task as a suffix of the type of any shared parameter. 
Four rights can be distingueshed and are presented below: read, write, update and accumulation.

     <dl>
<dt><em>read right</em><dd><code>a1::Shared_r&lt;</code><var>T</var><code>&gt;</code> is the type of a parameter whose value can only be read using its <code>const </code><var>T</var><code>&amp; read()</code> method. 
This reading can be concurrent with other tasks referencing this shared object in the same mode.

     <br><dt><em>write right</em><dd><code>a1::Shared_w&lt;</code><var>T</var><code>&gt;</code> is the type of a parameter whose value can only be written using its <code>void write(</code><var>T</var><code>)</code> method. 
This writing can be concurrent with other tasks referencing this shared data in the same mode. 
The final value is the last one according to the reference order.

     <br><dt><em>update right</em><dd><code>a1::Shared_rw&lt;</code><var>T</var><code>&gt;</code> is the type of a parameter whoses value can be updated in place; the related value can be read and/or written using the  <var>T</var><code>&amp; access()</code> method. 
Such an object represents a critical section for the task. 
This mode is the only one where the address of the physical object related to the shared object is available. 
It enables the user to call sequential codes working directly with this pointer.

     <br><dt><em>concurrent write right</em><dd><code>a1::Shared_cw&lt;</code><var>T</var><code>,</code><var>F</var><code>&gt;</code> is the type of a parameter whose value can only be accumulated with respect to the user defined function class <var>F</var>. 
The resulting value of the concurrent write is an accumulation of all other values written by a call to this function, through the use of the <code>void cumul(</code><var>T</var> method.

   </dl>

   <p>For a more in-depth description of the shared parameters, please refer to the <a href="#API">API</a>.

<!--  -->
<div class="node">
<a name="programing-environnment"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#performance">performance</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#programming-model">programming model</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Athapascan">Athapascan</a>

</div>

<h3 class="section">4.2 Programming environment</h3>

<p>Now that the basic programming model has been described, let us see how it is implemented. 
To do so we need to

<ul class="menu">
<li><a accesskey="1" href="#initialize-the-library">initialize the library</a>:  parse arguments and create the first task
<li><a accesskey="2" href="#define-task">define task</a>:  describe the program architecture
<li><a accesskey="3" href="#spawn-task">spawn task</a>:  dynamically fill the graph
</ul>

<!--  -->
<div class="node">
<a name="initialize-the-library"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#define-task">define task</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programing-environnment">programing environnment</a>

</div>

<h4 class="subsection">4.2.1 Initialize the library</h4>

<p>The execution of an <code>Athapascan</code> program is handled by a <code>a1::Community</code>. 
A community restructures a group of nodes so that they can be distributed to the different parallel machines. 
Therefore, prior to the declaration of any Athapascan object or task, a community must be created. 
Currently, this community only contains the group of nodes defined at the start of the application.

   <p>Once the community has been created, tasks can be created and submited to the community (see <a href="#spawn-task">spawn task</a>).

   <p>The library header must first be included to get all prototypes:
This defines the <code>a1</code> namespace.
<pre class="example">     #include &lt;athapascan-1&gt;
</pre>
   <p>Usually the community is defined in the main method of the program.

<pre class="example">     int main( int argc, char** argv )
     {
</pre>
   <p><code>Athapscan</code> reads its parameters from the program arguments
<!-- ( see @ref{launching athapscan} ). -->
They are used to initialize the <code>Community</code>.
<pre class="example">         a1::Community com = a1::System::join_community( argc, argv );
</pre>
   <p>A main task is then spawned. Its prototype is strictely defined: it must define the
<code>void operator()(int </code><var>argc</var><code>, char **</code><var>argv</var><code>)</code>. 
It is called <var>doit</var> in the following
<pre class="example">         a1::ForkMain&lt;doit&gt;()(argc, argv);
</pre>
   <p>The starter is hit once we ask to leave the community. 
A community can only be left if it contains no task.
<pre class="example">         com.leave();
</pre>
   <p>It is often considered to do some cleanup before exiting
<pre class="example">         a1::System::terminate();
         return 0;
     }
</pre>
   <p>Now let us define our first task.

<!--  -->
<div class="node">
<a name="define-task"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#spawn-task">spawn task</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#initialize-the-library">initialize the library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programing-environnment">programing environnment</a>

</div>

<h4 class="subsection">4.2.2 Define task</h4>

<p>The task <var>doit</var> should contain the code to be executed in parallel. 
It is often only a matter of spawning additionnal tasks (hopefully in a recursive way). 
But let say we just want to print a "hello world".

   <p>First, a task is nothing else than a structure:
<pre class="example">     struct doit
     {
</pre>
   <p>Second it is also a function obect. As described in <a href="#initialize-the-library">initialize the library</a>, the <var>doit</var> task
has specific parameters
<pre class="example">         void operator()(int <var>argc</var>, char **<var>argv</var>)
         {
</pre>
   <p>The body is known across the world (let us suppose we added <code>#include &lt;iostream&gt;</code> in the header)
<pre class="example">             std::cout &lt;&lt; "hello world !" &lt;&lt; std::endl;
        }
</pre>
   <p>For <code>Java</code> addict, do not forget to close the structure !
<pre class="example">     };
</pre>
   <p>This is your first Task. 
Executing it will not result in a parallel execution. 
We need more task to feed our scheduler. 
What about a simple sum ? 
The <code>C</code> procedure would be
<pre class="example">     int sum(int <var>n</var>, int <var>p</var>);
</pre>
   <p>Let us do some semantic analysis to make it a task:
     <dl>
<dt><var>n</var><dd>is read by <code>sum</code> : it will become a <code>a1::Shared_r&lt;int&gt;</code> ! 
<br><dt><var>p</var><dd>is also read by <code>sum</code> : it will become a <code>a1::Shared_r&lt;int&gt;</code> ! 
<br><dt><var>return value</var><dd>is written by <code>sum</code> : it will become a <code>a1::Shared_w&lt;int&gt;</code> ! 
</dl>

   <p>So once our task defined:
<pre class="example">     struct sum_task
     {
     };
</pre>
   <p>We can provide it with the good <code>operator() </code>

<pre class="example">         void operator()( a1::Shared_r&lt;int&gt; <var>n</var>, a1::Shared_r&lt;int&gt; <var>p</var>, a1::Shared_w&lt;int&gt; <var>r</var>)
         {
         }
</pre>
   <p>The body should be a simple call to the <code>C</code> procedure <code>sum</code>. 
But we need to access the content of the shared data (see <a href="#API">API</a> for a list of available methods).
     <dl>
<dt><var>n</var><code>.read()</code><dd>will read the content of <var>n</var>
<br><dt><var>p</var><code>.read()</code><dd>will read the content of <var>p</var>
<br><dt><var>r</var><code>.write(</code><var>val</var><code>)</code><dd>will write <var>val</var> in <var>r</var>. 
</dl>

   <p>so the body is
<pre class="example">             <var>r</var>.write( sum( <var>n</var>.read(), <var>p</var>.read() ) );
</pre>
   <!--  -->
<div class="node">
<a name="spawn-task"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#define-task">define task</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#programing-environnment">programing environnment</a>

</div>

<h4 class="subsection">4.2.3 Spaw task</h4>

<p>Now that we have defined our first real task <var>sum_task</var>,
it is time to spawn it. 
let us go back to our <var>doit</var> special task, and modify it a bit
<pre class="example">     struct doit
     {
         void operator()(int <var>argc</var>, char **<var>argv</var>)
         {
             if( <var>argc</var> != 3 )
                 return;
             int <var>n</var> = atoi(<var>argv</var>[1]);
             int <var>p</var> = atoi(<var>argv</var>[2]);
             int <var>r</var>;
             <var>r</var> = sum(<var>n</var>,<var>p</var>);
             std::cout &lt;&lt; <var>r</var> &lt;&lt; std::endl;
         }
     };
</pre>
   <p>But we want to use our task ! 
The task takes <code>a1::Shared</code> parameters, so
<pre class="example">             a1::Shared&lt;int&gt; <var>n</var> = atoi(<var>argv</var>[1]);
             a1::Shared&lt;int&gt; <var>p</var> = atoi(<var>argv</var>[2]);
             a1:/Shared&lt;int&gt; <var>r</var>;
</pre>
   <p>Once intialized, you can<em>not</em> access the content of the shared variable from this task ! 
It can only be accessed by other tasks with proper access right. 
This is easy to understand. Has task calls are asynchrnonous, it is hazardous to access them in an uncontrolled way. 
Task dependencies will take the control.

   <p>Now spawn the task to get an asynchronous call to <code>sum_task</code>
<pre class="example">             a1::Fork&lt; sum_task &gt; () ( <var>n</var>, <var>p</var>, <var>r</var> );
</pre>
     <dl>
<dt><em>Question</em><dd>But what if I want the result ?You just wrote it is impossible to read from <var>r</var>! 
<br><dt><em>Answer</em><dd>Create a new task that will read <var>r</var> with proper access right !
     <pre class="example">          struct read_task
          {
              void operator() ( a1::Shared_r&lt;int&gt; <var>r</var> )
              {
                  std::cout &lt;&lt; <var>r</var>.read() &lt;&lt; std::endl;
              }
          };
</pre>
     </dl>

<!--  -->
<div class="node">
<a name="performance"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#additionnal-features">additionnal features</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#programing-environnment">programing environnment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Athapascan">Athapascan</a>

</div>

<h3 class="section">4.3 When speed matters</h3>

<p>It is important to understand that a work stealing sceduling is efficent only if
the data flow graph is deep, and grows in a fork / join style. 
But
     <ul>
<li>if the tasks are too small, the cost of task creation / scheduling outperforms the cost of task execution, which leads to poor performance
<li>if too few tasks are created, CPU power may be lost
</ul>

   <p>That's why we need a <em>threshold</em>. A threshold is a constant that control when we should stop to create Tasks
to execute the sequential algorithm. 
It often looks like this
<pre class="example">     struct task
     {
         void operator()(/* parameters */)
         {
             if( size &lt; threshold )
                 /* sequential_call */
             else
                 /* fork new task */
         }
     };
</pre>
   <p>The fibonnaci example behaves like this. 
Choosing the threshold is a matter of test and experiments, but it is <strong>really</strong> important.

<!--  -->
<div class="node">
<a name="additionnal-features"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#performance">performance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Athapascan">Athapascan</a>

</div>

<h3 class="section">4.4 Additionnal feeatures</h3>

<p>Tasks and shared parameters are the basics of <code>Athapascan</code>. 
But it is not always enough to write real-life programs ! 
Take a look at

<ul class="menu">
<li><a accesskey="1" href="#global-memory">global memory</a>:  when shared memory is not enough
<li><a accesskey="2" href="#sharing-arrays">sharing arrays</a>:  dealing with pointer hell
<li><a accesskey="3" href="#control-task-creation">control task creation</a>:  where are the tasks created, and when do they stop
<li><a accesskey="4" href="#use-classical-algorithms">use classical algorithms</a>:  for simple cases
</ul>

<!--  -->
<div class="node">
<a name="global-memory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#sharing-arrays">sharing arrays</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#additionnal-features">additionnal features</a>

</div>

<h4 class="subsection">4.4.1 Global memory</h4>

<p>The current release of <code>Athapascan</code> provides the <code>a1::MonotonicBound</code> template that allows several processes to read or update a bound that increases or decreases monotonically. 
Such a variable has a system wide identifier that should be defined during the declaration. 
It is communicable and could be a parameter of tasks.

   <p>To declare a <code>a1::MonotonicBound</code>, you must provide the string identifier and two tempalte parameters:
     <ol type=1 start=1>
<li>the type of the variable updated, <var>T</var>
<li>the type of the function obect used to update the variable, <var>F</var>
        </ol>

<pre class="example">     /* raw initialization */
     a1::MonotonicBound&lt;T,F&gt; a ("B&amp;B bound");
     /* initialization by value */
     a1::MonotonicBound&lt;T,F&gt; b ( "another B&amp;B bound", new T(/*...*/) );
</pre>
   <p>The update function <var>F</var> is a function class that should has an <code>operator()</code> with the following signature.
<pre class="example">     template &lt; class T&gt; struct F
     {
       bool operator()( T&amp; res, const T&amp; val);
     };
</pre>
   <p>The return value of the operator is true if and only if the local value has been updated. 
In this, case during the invocation of the release, the protocol will broadcast the new local bound to all other processors which update their bound in the same way.

   <p>For instance, the definition of the operator that compute the maximal value could be:

<pre class="example">     struct Max
     {
       bool operator()( long&amp; result, const long&amp; value)
       {
         if (result &lt; value)
         {
           result = value;
           return true;
         }
         return false;
       }
     };
</pre>
   <p>To read (and only read) the value of a <code>a1::MonotonicBound</code>, a lock is to be taken on the value, then a call to the <code>read</code> method.
<pre class="example">     <var>a</var>.acquire();
     <var>a</var>.read(); // return a const T&amp; on the value
     <var>a</var>.release();
</pre>
   <p>To update the value of  a <code>a1::MonotonicBound</code>, use the <code>update</code> method
<pre class="example">     <var>a</var>.update(<var>new_val</var>);
</pre>
   <!--  -->
<div class="node">
<a name="sharing-arrays"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#control-task-creation">control task creation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#global-memory">global memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#additionnal-features">additionnal features</a>

</div>

<h4 class="subsection">4.4.2 Sharing arrays</h4>

<p>As said in <a href="#task-parameters">task parameters</a>, tasks parameters are not allowed to be pointers. 
But High performance Computing make an extensive use of arrays, so what ?

<ul class="menu">
<li><a accesskey="1" href="#arrays-through-structures">arrays through structures</a>:  encapsulate your arrays
<li><a accesskey="2" href="#arrays-through-verctors">arrays through verctors</a>:  <code>std::vector</code> support
<li><a accesskey="3" href="#arrays-through-iterators">arrays through iterators</a>:  iterate on remore arrays
</ul>

<!--  -->
<div class="node">
<a name="arrays-through-structures"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#arrays-through-verctors">arrays through verctors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#sharing-arrays">sharing arrays</a>

</div>

<h5 class="subsubsection">4.4.2.1 Arrays through structures</h5>

<p>If you hae a static array, whose size never change, the best option is to encapsulate it in
a structure. To use
<pre class="example">     int <var>my_array</var>[256];
</pre>
   <p>You define a new communicable structure
<pre class="example">     structure int_array_256
     {
         int array[256];
         int_array_256() {}
         int_array_256(const int_array_256&amp; <var>a</var>)
         {
             std::copy(<var>a</var>,  <var>a</var> +256, array);
         }
     };
     
     //packing operator
     a1::OStream&amp; operator&lt;&lt; (a1::OStream&amp; <var>out</var>, const int_array_256&amp; <var>i</var>)
     {
         for(int j=0; j&lt;256;j++)
             <var>out </var> &lt;&lt; <var>i</var>[j];
         return <var>out </var>;
     }
     
     //unpacking operator
     a1::IStream&amp; operator&gt;&gt; (a1::IStream&amp; <var>in</var>, int_array_256&amp; <var>i</var>)
     {
         for(int j=0; j&lt;256;j++)
             <var>in</var> &gt;&gt; <var>i</var>[j];
         return <var>in</var>;
     }
</pre>
   <p>And you can now use it as a formal parameter of your task. 
Yet note that the copy introduce by such a structure is rarely worth the price !

<!--  -->
<div class="node">
<a name="arrays-through-verctors"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#arrays-through-iterators">arrays through iterators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#arrays-through-structures">arrays through structures</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#sharing-arrays">sharing arrays</a>

</div>

<h5 class="subsubsection">4.4.2.2 Arrays through verctors</h5>

<p>If you want to share value from an array, the best tool is the <code>std::vector</code> class. 
The <code>std::vector</code> class is communicable.
<pre class="example">      std::vector&lt;int&gt; <var>v</var>(256);
      std::fill( <var>v</var>.begin(), <var>v</var>.end(), 42);
      a1::Shared&lt; std::vector&lt;int&gt; &gt; <var>shared_vector</var> = <var>v</var>;
      a1::Fork&lt;a_task&gt; () ( <var>shared_vector</var> );
</pre>
   <!--  -->
<div class="node">
<a name="arrays-through-iterators"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#arrays-through-verctors">arrays through verctors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#sharing-arrays">sharing arrays</a>

</div>

<h5 class="subsubsection">4.4.2.3 Arrays through iterators</h5>

<p>A remote iterator is a communicable type used to keep the reference of an array across the network, thus allowing access to large amount of remote data. 
This does not provide any synchronization as a Shared does, so you have to manage dependencies using other means (usually a fake Shared dependencie).

   <p>To use remote iterators, you first declare them, and then init them from a local data
<pre class="example">     int array[256];
     // for read-write access
     a1::remote&lt;int*&gt; begin, end;
     a1::init(begin, end, array, array + 256);
     // for read only access
     a1::const_remote&lt;int*&gt; cbegin, cend;
     a1::init(cbegin, cend, array, array + 256);
</pre>
   <p>The <code>const_remote</code> class will give you a read-only iterator, while the <code>remote</code> class will give you read-write access.

   <p>You can now use the remote iterators as you would use random access iterators : incrementation, copy, dereferencing and so on is allowded. 
Of course those iterator can be used as arguments of any STL algoroithm as native iterator would. 
They have the Random access iterator tag. 
As they are communicable, you can pass them as parameters to an athapascan'task.

   <p>To get a reference on data pointed by the iteratore, you must first ensure a copy of the real data is available on your local machine. 
You must do so using the <code>fetch</code> function :
Not using the fetch function may result in a SEGFAULT, for you're trying to access data that may not exist in memory.

<pre class="example">     struct task
     {
         void operator() ( a1::remote&lt;int*&gt; b, a1::remote&lt;int*&gt; e)
         {
             size_t n = e -b;
             if( n &lt; 4)
             {
                 a1::fetch(b,e);
                 while(b&lt;e)
                     std::cout &lt;&lt; *b++ &lt;&lt; std::endl;
             }
             else
             {
                 a1::Fork&lt;task&gt;()( b, b+n/2);
                 a1::Fork&lt;task&gt;()( b +n/2, e);
             }
         }
     };
</pre>
   <p>No guarantee is given if the split overrides. Try to avoid it. 
The detailed interface is given in <a href="#API">API</a>.

<!--  -->
<div class="node">
<a name="control-task-creation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#use-classical-algorithms">use classical algorithms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#sharing-arrays">sharing arrays</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#additionnal-features">additionnal features</a>

</div>

<h4 class="subsection">4.4.3 Control task creation</h4>

<p>You sometime want to merge distributed and sequential code. 
To do this, you must ensure that all tasks have been executed. 
<code>a1::SyncGuard</code> comes handy there. 
It is a class that ensures that every task spawned betwwen the creation of an object of type <code>a1::SyncGuard</code>
and its destruction are executed.
<pre class="example">     struct task
     {
         void operator()()
         {
             // all tasks
             {
                 // from here
                     a1::SyncGuard s;
                     a1::Fork&lt;task1&gt;()();
                     a1::Fork&lt;task2&gt;()();
                 // to here
             }
             // have finished when I arrive here
             a1::Fork&lt;task3&gt;()();
         }
     };
</pre>
   <p>This is often usefull, but beware, it may lower the parallism !

   <p>Once a task is created, you have no control over where it will be executed. 
It is not a problem if the task had no side effect. 
But they sometime have, so you can specify attribute to the <code>Fork</code> operator. 
The most useful attribute is <code>a1::SetLocal</code> which ensure the task will be executed by the process that spawned it. 
It can be used when preformance matters, or to access local memory.
<pre class="example">     a1::Fork&lt;task&gt;(a1::SetLocal)(/* task arguments */);
</pre>
   <p>Here is a little trick to read from local memory. 
It uses both <code>a1::SetLocal</code> and <code>a1::SyncGuard</code>. 
See
<pre class="example">     int global_int;
     struct task
     {
         void operator()(a1::Shared_r&lt;int&gt; i)
         {
             global_int = i.read();
         }
     };
     
     struct doit
     {
         void operator()(int , char **)
         {
             a1::Shared&lt;int&gt; i;
             {
                 a1::SyncGuard s;
                 // some_task writes in i
                 a1::Fork&lt;some_task&gt;()(i);
                 // task cannot be stolen !
                 a1::Fork&lt;task&gt;(a1::SetLocal)(i)
             }
             // global_int is up to date thanks to the guard
             std::cout &lt;&lt; global_int &lt;&lt; std::endl;
         }
     };
</pre>
   <!--  -->
<div class="node">
<a name="use-classical-algorithms"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#control-task-creation">control task creation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#additionnal-features">additionnal features</a>

</div>

<h4 class="subsection">4.4.4 Use classical algorithms</h4>

<p>For ease of use, <code>Athapascan</code> offers some high level algorithms, with an interface and a semantic very similar to <code>STL</code> ones. 
Once <code>Athapascan</code> has been started and the main task forked, you can freely use any of those algorithms.

   <p>Thoses algortihms are described in <a href="#API">API</a>, but here is a quick list:
     <ul>
<li><code>a1::sort</code>
<li><code>a1::stable_sort</code>
<li><code>a1::transform</code>
<li><code>a1::for_each</code>
<li><code>a1::find_if</code>
<li><code>a1::find</code>
</ul>

<div class="node">
<a name="tutorials"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#API">API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Athapascan">Athapascan</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Athapascan tutorials</h2>

<p>This chapters list some really simple programs that can help you to understand <code>Athpascan</code>'s primitives

<ul class="menu">
<li><a accesskey="1" href="#hello-world">hello world</a>:  distributed version of the famous one
<li><a accesskey="2" href="#fibonacci">fibonacci</a>:  how useless, but how typical
</ul>

<div class="node">
<a name="hello-world"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fibonacci">fibonacci</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#tutorials">tutorials</a>

</div>

<h3 class="section">5.1 Hello World - 1 Fork, 0 Shared</h3>

<p>Say hello to your friends ! 
Understand the <code>a1::Fork</code> usage.

     <dl>
<dt><strong>Basics</strong><dd>
Each time you want to parallelize a sequential code using Athapascan, you have two things to think of:
          <ul>
<li>how can I describe the sequential processing in terms of data transformations ( which will be called "tasks" ) ?

          <li>what are the dependencies between those tasks ? Does one requires the result from another ? 
</ul>

     <p>Once you have done this, your mind can begin to relax, your finger will begin to code.

     <br><dt><strong>Algorithm</strong><dd>

     <p><em>Algorithm</em> is a bit petty here. 
The <em>hello world</em> program just displays, for a given value of <var>n</var>

     <pre class="example">          hello world from 0 !
          hello world from 1 !
          ...
          hello world from n-2 !
          hello world from n-1 !
</pre>
     <p>The following <code>C++</code> code will more or less achieve this goal:

     <pre class="example">          #include &lt;iostream&gt;
          int main(int, char **)
          {
            int n = 10; /* number of iteration*/
            for (int id = 0; id &lt; n; id++)
              std::cout &lt;&lt; "hello world from " &lt;&lt; id &lt;&lt; " !" &lt;&lt; std::endl;
            return 0;
          }
</pre>
     <br><dt><strong>Where are the tasks</strong><dd>

     <p>In this <em>very simple</em> code, finding the task, the <strong>job to be done</strong>, is rather simple. 
What do we want to do ? print a message with a special id (a number). 
So the task is the printing of the message, it has no return value, and a single int as input.

          <dl>
<dt><strong>Task</strong><dd>print_hello
<br><dt><strong>input</strong><dd><code>int</code> id (read)
<br><dt><strong>output</strong><dd>none
</dl>

     <br><dt><strong>Where are the dependencies</strong><dd>

     <p>Obviously, each task is independent, isn't it ? The engine will automatically deduce this from the fact that each input parameter only has read access.

     <br><dt><strong>Preparing the code</strong><dd>

     <p>Now that we know what are the tasks and the dependencies, we need to describe them in a piece of code. 
If I follow the Athapascan guide, I read that a task is a function object with void return value. Let's rewrite previous code !

     <pre class="example">          #include &lt;iostream&gt;
          /* declare my task as a function object */
          struct print_hello
          {
            void operator()( int id )
            {
              std::cout &lt;&lt; "hello world from " &lt;&lt; id &lt;&lt; " !" &lt;&lt; std::endl;
            }
          };
          
          int main(int, char **)
          {
            int n = 10; /* number of iteration*/
            for (int i = 0; i &lt; n; i++)
              print_hello()(i); /* create and use the function object */
            return 0;
          }
</pre>
     <p><strong>NOTE</strong>: we did not create a single instance of the function object and then make several method calls, as we usually do. This is to prepare to the following : each task will be created separately.

     <br><dt><strong>Using Athapascan</strong><dd>
Before going further, we have to prepare the use of KAAPI library. It means we have to do some initialization stuff etc.

          <ol type=1 start=1>
<li>Initialize the library
<li>Create the main task
<li>Clean up
          </ol>

     <pre class="example">          #include &lt;iostream&gt;
          #include &lt;athapascan-1.h&gt; // add athapascan header
          
          struct print_hello
          {
            void operator()( int id )
            {
              std::cout &lt;&lt; "hello world from " &lt;&lt; id &lt;&lt; " !" &lt;&lt; std::endl;
            }
          };
          
          struct do_main // the do_main is also a task
          {
            void operator()(int argc, char **argv) // copy main here
            {
              int n = 10; /* number of iteration*/
              for (int i = 0; i &lt; n; i++)
                print_hello()(i); /* create and use the function object */
            }
          };
          
          int main(int argc, char **argv)
          {
            a1::Community com = a1::System::join_community(argc,argv); // init library
            do_main()(argc,argv); // main call
            com.leave(); // ensure no more task left
            a1::System::terminate(); // clean up
            return 0;
          }
</pre>
     <p><strong>NOTE</strong>: <code>com.leave()</code> is important, it computes the termination of the program, checking whether the local task list is empty or not.

     <p>After reading the documentation, I understood that there were some kind of shared variables that were used to compute the dependencies. 
I know that I only need to read the content of id, so I'll put it into a <code>a1::Shared_r&lt;int&gt;</code>

     <pre class="example">          #include &lt;iostream&gt;
          #include &lt;athapascan-1.h&gt;
          
          struct print_hello
          {
            void operator()( a1::Shared_r&lt;int&gt; id ) // use shared read access
            {
              // use the read() method to get the content of the shared
              std::cout &lt;&lt; "hello world from " &lt;&lt; id.read() &lt;&lt; " !" &lt;&lt; std::endl;
            }
          };
          
          struct do_main // the do_main is also a task
          {
            void operator()(int argc, char **argv) // copy main here
            {
              int n = 10; /* number of iteration*/
              for (int i = 0; i &lt; n; i++)
              {
                a1::Shared&lt;int&gt; id(i); // put variable in shared memory
                print_hello()(id);
              }
            }
          };
          
          int main(int argc, char **argv)
          {
            a1::Community com = a1::System::join_community(argc,argv);
            do_main()(argc,argv);
            com.leave();
            a1::System::terminate();
            return 0;
          }
</pre>
     <p><strong>NOTE</strong>: In fact, the shared memory is not needed here. Passing normal variable as parameters is equivalent to read access for dependencies computing.

     <p>I also understood that my tasks were designed to be forked instead of begin called. I must replace my function call by <code>a1::Fork</code> !

     <pre class="example">          #include &lt;iostream&gt;
          #include &lt;athapascan-1.h&gt;
          
          struct print_hello
          {
            void operator()( a1::Shared_r&lt;int&gt; id )
            {
              std::cout &lt;&lt; "hello world from " &lt;&lt; id.read() &lt;&lt; " !" &lt;&lt; std::endl;
            }
          };
          
          struct do_main
          {
            void operator()(int argc, char **argv)
            {
              int n = 10; /* number of iteration*/
              for (int i = 0; i &lt; n; i++)
              {
                a1::Shared&lt;int&gt; id(i);
                a1::Fork&lt;print_hello&gt;()(id); // fork a new task
              }
            }
          };
          
          int main(int argc, char **argv)
          {
            a1::Community com = a1::System::join_community(argc,argv);
            a1::ForkMain&lt;do_main&gt;()(argc,argv); // main fork, only executed by one node
            com.leave();
            a1::System::terminate();
            return 0;
          }
</pre>
     <p>This is your first piece of athapascan code !

     <p><strong>NOTE</strong>: To compile this code, please have a look to the install and compile documentation (see <a href="#compile">compile</a>)!

     <p><strong>NOTE</strong>: To get better performance , the for loop should be written recursively, and a threshold should be used. More on this in next tutorial ! 
</dl>

<div class="node">
<a name="fibonacci"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#hello-world">hello world</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#tutorials">tutorials</a>

</div>

<h3 class="section">5.2 Fibonacci - multiple Fork and Shared</h3>

<p>This tutorial will help you to understand how to use sahed memory.

     <dl>
<dt><strong>Algorithm</strong><dd>
The Fibonacci series is defined as:
          <ul>
<li>F(0) = 0
<li>F(1) = 1
<li>F(n) = F(n - 1) + F(n - 2) for all n &gt; 2
</ul>

     <p>There are different algorithms to resolve Fibonacci numbers, some having a linear time complexity O(n). 
The algorithm we present here is a recursive method.

     <p><strong>NOTE</strong>: It is a very bad implementation as it has an exponential complexity, O(2n), (as opposed to the linear time complexity of other algorithms). However, this approach is easy to understand and to paralleled.

     <br><dt><strong>Sequential implementation</strong><dd>

     <p>First, let's have a glance at the regular naive recursive sequential program:

     <pre class="example">          #include &lt;iostream&gt;
          
          int fibonacci(int n)
          {
              if (n&lt;2)
                  return n;
              else
              return fibonacci(n-1)+fibonacci(n-2);
          }
          
          int main(int argc, char** argv)
          {
              int n = atoi(argv[1]);
              int res =  fibonacci( n );
              std::cout &lt;&lt; "result= " &lt;&lt; res &lt;&lt; std::endl;
              return 0 ;
          }
</pre>
     <p>We will follow the steps described in first tutorial :

          <ol type=1 start=1>
<li>identify the tasks
<li>identify the dependencies
          </ol>

     <br><dt><strong>Where are the tasks</strong><dd>

     <p>A task is a data transformation. It is easy to see that the Fibonacci function itself is a task, taking a number as input, and returning a number as output.

          <dl>
<dt><strong>Task</strong><dd>fibonacci
<br><dt><strong>Input</strong><dd><code>int</code> n (read)
<br><dt><strong>Output</strong><dd><code>int</code> res (write) = fibonacci(n)
</dl>

     <p>But with a little more experience, you will see that the <code>operator+</code> combining the result of the two function call is also a task. So we write

          <dl>
<dt><strong>Task</strong><dd>add
<br><dt><strong>Input</strong><dd><code>int</code> i (read), <code>int</code> j (read)
<br><dt><strong>Output</strong><dd><code>int</code> res (write) = i + j
</dl>

     <br><dt><strong>Where are the dependencies</strong><dd>

     <p>You cannot add fibonacci(n-1) and fibonacci(n-2) before the function call ends : the input of task add are written by tasks fibonacci(n-1) and fibonacci(n-2) : they shared data ! 
We describe this in KAAPI by declaring the variable in shared memory, and then describing the access rights used to access the data.

     <br><dt><strong>Preparing the code</strong><dd>

     <p>To make the usage of KAAPI easier, I will rewrite the code in this way :

     <pre class="example">          #include &lt;iostream&gt;
          
          int fibonacci(int n)
          {
              int res; // output variable
              if (n&lt;2)
              {
                  res = n;
              }
              else
              {
          	int arg1 = n-1; // input variable
          	int tmp1 = fibonacci(arg1);
          	int arg2 = n-2; // input variable
          	int tmp2 = fibonacci(arg2);
          	res = tmp1 + tmp2;
              }
              return res;
          }
          
          int main(int argc, char** argv)
          {
              int n = atoi(argv[1]);
              int res =  fibonacci( n );
              std::cout &lt;&lt; "result= " &lt;&lt; res &lt;&lt; std::endl;
              return 0 ;
          }
</pre>
     <br><dt><strong>Using Athapascan</strong><dd>

     <p>The implementation of the add task is a good example of KAAPI task : it is simple, but uses two different of shared variable. The sequential function is

     <pre class="example">          int add (int i, int j)
          {
            int res;
            res = i + j;
            return res;
          }
</pre>
     <p>As a function object with no return value, it could be

     <pre class="example">          struct add
          {
            void operator()( int i /* read*/,
              int j/* read*/, int&amp; res/*write*/)
              // use a reference instead of return value
            {
              res = i + j ;
            }
          };
</pre>
     <p>You note that i and j are read, res is only written, so I will replace the type by the equivalent shared type with the correct access right:

          <dl>
<dt><code>int</code><em> [read]</em><dd><code>a1::Shared_r&lt;int&gt;</code>
<br><dt><code>int</code><em> [write]</em><dd><code>a1::Shared_w&lt;int&gt;</code>
</dl>

     <pre class="example">          struct add
          {
            void operator()( a1::Shared_r&lt;int&gt; i,
              a1::Shared_r&lt;int&gt; j,
              a1::Shared_w&lt;int&gt; res )
              // replace with shared variable
            {
              res.write( i.read() + j.read() );
            }
          };
</pre>
     <p><strong>NOTE</strong>: You cannot directly access the content of a shared, you must use the appropriate method. Of course, you cannot <code>read()</code> the content of a <code>shared_w</code> ...

     <p>Let's write the code for the fibonacci task. As usual, we will write it in two steps. First use the function object design :

     <pre class="example">          struct fibonacci
          {
            void operator()( int n /*read*/, int&amp; res /*write*/ )
            {
              if( n &lt; 2 )
              {
                res = n ; /* write operation here */
              }
              else
              {
                int res1;
                fibonacci()(n-1,res1); // fibo task call
                int res2;
                fibonacci()(n-2,res2); // fibo task call
                add()( res1, res2, res ); // add task call
              }
            }
          };
</pre>
     <p>Then use the shared memory and task spawning :

          <dl>
<dt><code>int</code><em> [write]</em><dd><code>a1::Shared_w&lt;int&gt;</code>
<br><dt><code>add</code><em>()(...)</em><dd><code>a1::Fork&lt;add&gt;()</code>
<br><dt><code>fibonacci</code><em>()(...)</em><dd><code>a1::Fork&lt;fibonacci&gt;()</code>
</dl>

     <p><strong>NOTE</strong>: As explained in previous tutorial, it is useless to put a read-only variable in shared memory if there is no other dependencies on this variable.

     <pre class="example">          struct fibonacci
          {
            void operator()( int n , a1::Shared_w&lt;int&gt; res )
            {
              if( n &lt; 2 )
              {
                res.write(n) ; // replace the affectation by a write call
              }
              else
              {
                a1::Shared&lt;int&gt; res1;
                a1::Fork&lt;fibonacci&gt;()(n-1,res1); // fibo task call
                a1::Shared&lt;int&gt; res2;
                a1::Fork&lt;fibonacci&gt;()(n-2,res2); // fibo task call
                a1::Fork&lt;add&gt;()( res1, res2, res ); // add task call
              }
            }
          };
</pre>
     <p>Here you are, both tasks have been written, you just have to include the standard main of an Athapascan program to get the following result :

     <pre class="verbatim">     //! run as: karun -np 2 --threads 2 ./fibo_apiatha 36 4
     
     /****************************************************************************
      * 
      *  Shared usage sample : fibonnaci
      *
      ***************************************************************************/
     
     
     #include &lt;iostream>
     #include "athapascan-1" // this is the header required by athapascan
     
     
     // --------------------------------------------------------------------
     /* Sequential fibo function
      */
     unsigned long long fiboseq(unsigned long long n)
     { return (n&lt;2 ? n : fiboseq(n-1)+fiboseq(n-2) ); }
     
     unsigned long long fiboseq_On(unsigned long long n){
       if(n&lt;2){
         return n;
       }else{
     
         unsigned long long fibo=1;
         unsigned long long fibo_p=1;
         unsigned long long tmp=0;
         unsigned long long i=0;
         for( i=0;i&lt;n-2;i++){
           tmp = fibo+fibo_p;
           fibo_p=fibo;
           fibo=tmp;
         }
         return fibo;
       }
     }
     
     /* Print any typed shared
      * this task has read acces on a, it will wait until previous write acces on it are done
     */
     template&lt;class T>
     struct Print {
       void operator() ( a1::Shared_r&lt;T> a, const T&amp; ref_value, a1::Shared_r&lt;double> t )
       { 
         /*  Util::WallTimer::gettime is a wrapper around gettimeofday(2) */
         double delay = Util::WallTimer::gettime() - t.read();
     
         /*  a1::System::getRank() prints out the id of the node executing the task */
         Util::logfile() &lt;&lt; a1::System::getRank() &lt;&lt; ": -----------------------------------------" &lt;&lt; std::endl;
         Util::logfile() &lt;&lt; a1::System::getRank() &lt;&lt; ": res  = " &lt;&lt; a.read() &lt;&lt; std::endl;
         Util::logfile() &lt;&lt; a1::System::getRank() &lt;&lt; ": time = " &lt;&lt; delay &lt;&lt; " s" &lt;&lt; std::endl;
         Util::logfile() &lt;&lt; a1::System::getRank() &lt;&lt; ": -----------------------------------------" &lt;&lt; std::endl;
         KAAPI_LOG( a.read() != ref_value, "**** Error **** : bad value" );
       }
     };
     
     
     /* Sum two integers
      * this task reads a and b (read acces mode) and write their sum to res (write access mode)
      * it will wait until previous write to a and b are done
      * once finished, further read of res will be possible
      */
     struct Sum {
       void operator() ( a1::Shared_w&lt;unsigned long long> res, 
                         a1::Shared_r&lt;unsigned long long> a, 
                         a1::Shared_r&lt;unsigned long long> b) 
       {
         /* write is used to write data to a Shared_w
          * read is used to read data from a Shared_r
          */
         res.write(a.read()+b.read());
       }
     };
     
     /* Get current time
      */
     struct GetTime {
       void operator() ( a1::Shared_rw&lt;double> t) 
       {
         t.access() = Util::WallTimer::gettime();
       }
     };
     
     /* Athapascan Fibo task
      * - res is the return value, return value are usually put in a Shared_w
      * - n is the order of fibonnaci. It could be a Shared_r, but there are no dependencies to compute on it, so it would be useless
      * - threshold is used to control the grain of the application. The greater it is, the more task will be created, the more parallelism there will be.
      *   a high value of threshold also decreases the performances, beacause of athapascan's overhead, choose it wisely
      */
     struct Fibo {
       void operator() ( a1::Shared_w&lt;unsigned long long> res, int n, int threshold, a1::Shared_r&lt;double> t )
       {  
         if (n &lt; threshold) {
           res.write( fiboseq(n) );
         }
         else {
           a1::Shared&lt;unsigned long long> res1;
           a1::Shared&lt;unsigned long long> res2;
           a1::Shared&lt;double> t;
     
           /* the Fork keyword is used to spawn new task
            * new tasks are executed in parallel as long as dependencies are respected
            */
           a1::Fork&lt;Fibo>() ( res1, n-1, threshold, t );
           a1::Fork&lt;Fibo>() ( res2, n-2, threshold, t );
     
           /* the Sum task depends on res1 and res2 which are written by previous tasks
            * it must wait until thoses tasks are finished
            */
           a1::Fork&lt;Sum>()  ( res, res1, res2 );
         }
       }
     };
     
     
     /* Main of the program
     */
     struct doit {
     
       void do_experiment(unsigned int n, unsigned int seuil, unsigned int iter )
       {
         double t = Util::WallTimer::gettime();
         unsigned long long ref_value = fiboseq_On(n);
         double delay = Util::WallTimer::gettime() - t;
         Util::logfile() &lt;&lt; "[fibo_apiatha] Sequential value for n = " &lt;&lt; n &lt;&lt; " : " &lt;&lt; ref_value 
                         &lt;&lt; " (computed in " &lt;&lt; delay &lt;&lt; " s)" &lt;&lt; std::endl;
         a1::Shared&lt;double> time(0.0);
         for (unsigned int i = 0 ; i &lt; iter ; ++i)
         {
           /* notice how useless the init value is */
           a1::Shared&lt;unsigned long long> res(31415);
         
           a1::Fork&lt;GetTime>(a1::SetLocal)(time);
           
           a1::Fork&lt;Fibo>()( res, n, seuil, time );
     
           /* a1::SetLocal ensures that the task is executed locally (cannot be stolen) */
           a1::Fork&lt;Print&lt;unsigned long long> >(a1::SetLocal)(res, ref_value, time);
         }
       }
     
       void operator()(int argc, char** argv )
       {
         unsigned int n = 30;
         if (argc > 1) n = atoi(argv[1]);
         unsigned int seuil = 2;
         if (argc > 2) seuil = atoi(argv[2]);
         unsigned int iter = 3;
         if (argc > 3) iter = atoi(argv[3]);
         
         Util::logfile() &lt;&lt; "In main: n = " &lt;&lt; n &lt;&lt; ", seuil = " &lt;&lt; seuil &lt;&lt; ", iter = " &lt;&lt; iter &lt;&lt; std::endl;
         do_experiment( n, seuil, iter );
       }
     };
     
     
     /* user store for global variable
     */
     void fibo_userglobal( Util::OStream&amp; out )
     {
       static const char* msg = "ceci est la variable globale de fibonnaci";
       out.write(Util::WrapperFormat&lt;char>::format, Util::OStream::IA, msg, strlen(msg)+1);
     }
     
     
     /* main entry point : Athapascan initialization
     */
     #if defined(KAAPI_USE_IPHONEOS)
     void* KaapiMainThread::run_main(int argc, char** argv)
     #else
     int main(int argc, char** argv)
     #endif
     {
       try {
     #if defined(KAAPI_USR_FT)
         FT::set_savehandler( &amp;fibo_userglobal );
     #endif
     
         /* Join the initial group of computation : it is defining
            when launching the program by a1run.
         */
         a1::Community com = a1::System::join_community( argc, argv );
         
         /** Print pid/gid 
         */
         KAAPI_LOG(true, "[main] pid=" &lt;&lt; getpid());
         
         /* Start computation by forking the main task */
         a1::ForkMain&lt;doit>()(argc, argv); 
         
         /* Leave the community: at return to this call no more athapascan
            tasks or shared could be created.
         */
         com.leave();
     
         /* */
         a1::System::terminate();
       }
       catch (const a1::InvalidArgumentError&amp; E) {
         Util::logfile() &lt;&lt; "Catch invalid arg" &lt;&lt; std::endl;
       }
       catch (const a1::BadAlloc&amp; E) {
         Util::logfile() &lt;&lt; "Catch bad alloc" &lt;&lt; std::endl;
       }
       catch (const a1::Exception&amp; E) {
         Util::logfile() &lt;&lt; "Catch : "; E.print(std::cout); std::cout &lt;&lt; std::endl;
       }
       catch (...) {
         Util::logfile() &lt;&lt; "Catch unknown exception: " &lt;&lt; std::endl;
       }
       
       return 0;
     }
     
</pre>

   </dl>

<!--  -->
<div class="node">
<a name="API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#function-methods-and-classes-index">function methods and classes index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tutorials">tutorials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Athapascan Application Programming Interface</h2>

<p>This is a quick reference to most classes and functions defined in the
header <samp><span class="file">&lt;athapascan-1&gt;</span></samp>. 
Do not forget to had
<pre class="example">         #include &lt;athapscan-1&gt;
         using namespace a1; // optional
</pre>
   <p>to your source code !

</li></ul>
<p>The must have
<ul class="menu">
<li><a accesskey="1" href="#fork">fork</a>:  <code>a1::Fork&lt;...&gt;(...)(...)</code>
<li><a accesskey="2" href="#shared">shared</a>:  <code>a1::Shared</code>, <code>a1::Shared_r</code>, <code>a1::Shared_w</code>, <code>a1::Shared_rw</code>, <code>a1::Shared_cw</code>
</ul>

</li></ul>
<p>And the sometimes useful
<ul class="menu">
<li><a accesskey="1" href="#monotonic-bound">monotonic bound</a>:  <code>a1::MonotonicBound</code>
<li><a accesskey="2" href="#synchronized-blocks">synchronized blocks</a>: <code>a1::SyncGuard</code>
<li><a accesskey="3" href="#algorithms">algorithms</a>:  various algorithms ported from the <acronym title="Standard Template Library">STL</acronym> (Standard Template Library)
<li><a accesskey="4" href="#utilities">utilities</a>:  timers, loggers, resize_vector ... 
<li><a accesskey="5" href="#dynamically-loaded-modules">dynamically loaded modules</a>:  external modules that can be loaded dynamically
</ul>
<!-- * remote iterator:: @code{a1::remote}, @code{a1::const_remote}, @code{a1::init}, @code{a1::fetch} -->

<!--  -->
<div class="node">
<a name="fork"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#shared">shared</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.1 Fork</h3>

     <dl>
<!--  -->
<dt><strong>Declaration</strong><dd>
     <pre class="example">          template&lt;class <var>Task</var>, class <var>Attribute</var> &gt;
          class Fork
          {
              Fork(Attribute = DefaultAttribut );
          
              void operator()( ... );
          };
</pre>
     <!--  -->
     <br><dt><strong>Template parameters</strong><dd>
          <dl>
<dt><var>Task</var><a name="index-Task-1"></a><dd>This template parameter is used to know which task will be spawned. 
It must implement a <code>operator()(...)</code> method. 
The parameters of the <code>Fork</code> method <code>operator()</code> are the same as the <code>operator()</code> from <var>Task</var>.

          <br><dt><var>Attribute</var><a name="index-Attribute-2"></a><dd>This template parameter is never specified direclty. Instead, it is deduced from the call to the <code>Fork</code> constructor. 
The class given can chage the bahavior of the forked task. Possible values are

               <dl>
<dt><var>DefaultAttribute</var><a name="index-DefaultAttribute-3"></a><dd>The default behavior, nothing particular
<br><dt><var>SetLocal</var><a name="index-SetLocal-4"></a><dd>Force the forked task to be executed locally
</dl>

     </dl>

     <!--  -->
     <br><dt><strong>Methods</strong><dd>

          <dl>
<dt><code>Fork(Attribute = DefaultAttribut)</code><a name="index-Fork_0028Attribute-_003d-DefaultAttribut_0029-5"></a><dd>The constructor of the <code>Fork</code> class. 
It is always used to construct a temporary object, from which you call the  <code>operator()</code> method. 
The <code>Attribute</code> parameter determines the behavior of forked task, as described before.

          <br><dt><code>void operator() (...)</code><a name="index-void-operator_0028_0029-_0028_002e_002e_002e_0029-6"></a><dd>The parameters of the method <code>operator()</code> are the same as the <code>operator()</code> from <var>Task</var>. 
This method spawns a task of type <var>Task</var> into the local stack, waiting to be executed by current process, or to be stolen by a remote process.

     </dl>

</dl>

<!--  -->
<div class="node">
<a name="shared"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#monotonic-bound">monotonic bound</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fork">fork</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.2 Shared</h3>

     <dl>
<!--  -->
<dt><code>Shared</code><a name="index-Shared-7"></a><dd>
          <dl>
<dt><strong>Declaration</strong><dd>
          <pre class="example">               template&lt;class T&gt;
               class Shared
               {
                   Shared();
                   Shared(T );
                   Shared(T* );
                   const T&amp; get_data();
               };
</pre>
          <br><dt><strong>Template Parameters</strong><dd>
               <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
</dl>

          <br><dt><strong>Methods</strong><dd>
               <dl>
<dt><code>Shared()</code><a name="index-Shared_0028_0029-8"></a><dd>Create an empty shared variable. 
<br><dt><code>Shared(T </code><var>t</var><code>)</code><a name="index-Shared_0028T-_0040var_007bt_007d_0029-9"></a><dd>Put a copy of <var>t</var> into the shared memory. 
<br><dt><code>Shared(T* )</code><a name="index-Shared_0028T_002a-_0029-10"></a><dd>Put a copy of *<var>t</var> into the shared memory. 
<br><dt><code>get_data()</code><a name="index-get_005fdata_0028_0029-11"></a><dd>Return content of shared, use cautiously because no check on the internal state is done
</dl>

     </dl>

     <!--  -->
     <br><dt><code>Shared_r</code><a name="index-Shared_005fr-12"></a><dd>
          <dl>
<dt><strong>Declaration</strong><dd>
          <pre class="example">               template&lt;class T&gt;
               class Shared_r
               {
                   const T&amp; read();
               };
</pre>
          <br><dt><strong>Template Parameters</strong><dd>
               <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
The variable held can only be read. 
</dl>

          <br><dt><strong>Methods</strong><dd>
               <dl>
<dt><code>read()</code><a name="index-read_0028_0029-13"></a><dd>Returns the content (in read only mode) of the object. 
The returned value cannot be modified. 
Further write must wait until the end of current task. 
</dl>

     </dl>

     <!--  -->
     <br><dt><code>Shared_w</code><a name="index-Shared_005fw-14"></a><dd>
          <dl>
<dt><strong>Declaration</strong><dd>
          <pre class="example">               template&lt;class T&gt;
               class Shared_w
               {
                   void write(T t);
               };
</pre>
          <br><dt><strong>Template Parameters</strong><dd>
               <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
The variable held can only be written. 
</dl>

          <br><dt><strong>Methods</strong><dd>
               <dl>
<dt><code>write()</code><a name="index-write_0028_0029-15"></a><dd>Write the content of <var>t</var> into the object. 
Further read must wait until the end of current task. 
In case of concurrent <code>write</code>, no guarantee on the order is given. 
</dl>

     </dl>
     <!--  -->
<br><dt><code>Shared_rw</code><a name="index-Shared_005frw-16"></a><dd>
          <dl>
<dt><strong>Declaration</strong><dd>
          <pre class="example">               template&lt;class T&gt;
               class Shared_rw
               {
                    T&amp; access()
               };
</pre>
          <br><dt><strong>Template Parameters</strong><dd>
               <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
</dl>

          <br><dt><strong>Methods</strong><dd>
               <dl>
<dt><code>access()</code><a name="index-access_0028_0029-17"></a><dd>Return the content of <var>t</var> of the object. 
The returned value can be modified. 
Further read or write must wait until the end of current task. 
</dl>
          </dl>

     <!--  -->
     <br><dt><code>Shared_cw</code><a name="index-Shared_005fcw-18"></a><dd>
          <dl>
<dt><strong>Declaration</strong><dd>
          <pre class="example">               template&lt;class T, class F&gt;
               class Shared_cw
               {
                    void cumul(T t)
               };
</pre>
          <br><dt><strong>Template Parameters</strong><dd>
               <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
<br><dt><var>F</var><dd>Type of the update function object. 
<var>F</var> must have an empty constructor and a <code>void operator()( </code><var>T</var><code>&amp;, const </code><var>T</var><code>&amp;); </code> method.

          </dl>

          <br><dt><strong>Methods</strong><dd>
               <dl>
<dt><code>cumul(T t)</code><a name="index-cumul_0028T-t_0029-19"></a><dd>Add the content of <var>t</var> to the object in the sense of <var>F</var>. 
There is no constriant on the order between various <code>cumul</code> call on the same shared object. 
Further read must wait until the end of current task. 
</dl>

     </dl>

</dl>

<!--  -->
<div class="node">
<a name="monotonic-bound"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#synchronized-blocks">synchronized blocks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#shared">shared</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.3 MonotonicBound</h3>

     <dl>
<dt><strong>Declaration</strong><dd>
     <pre class="example">          template&lt;class T, class F&gt;
          class MonotonicBound
          {
              MonotonicBound(const string&amp; name, T* initial_value = 0 );
              void update(const T&amp; t);
              void acquire();
              void release();
              const T&amp; read() const;
          };
</pre>
     <br><dt><strong>Template Parameters</strong><dd>
          <dl>
<dt><var>T</var><dd>Type of the variable to share. 
Type <var>T</var> must be communicable. 
<br><dt><var>F</var><dd>Type of the update function object. 
<var>F</var> must have an empty constructor and a <code> bool operator() (T&amp; result, const T&amp; value ); </code> method. 
this method returns true if <var>result</var> was updated. 
</dl>

     <br><dt><strong>Methods</strong><dd>
          <dl>
<dt><code>MonotonicBound(const string&amp; name, T* initial_value = 0 )</code><a name="index-MonotonicBound_0028const-string_0026-name_002c-T_002a-initial_005fvalue-_003d-0-_0029-20"></a><dd>Constructor of the class. 
<var>name</var> must be a unique identifier. 
If given, the <var>initial_value</var> is now owned by the object and need not to be realeased.

          <br><dt><code>update(const T&amp; t)</code><a name="index-update_0028const-T_0026-t_0029-21"></a><dd>Update the content of the object using the <var>F</var> update function. 
It is responsible to get the update the local value of the bound. 
The invocation of update should be surround by invocations <code>acquire</code>/<code>release</code>. 
Multiple update may be invoked between invocations to <code>acquire</code>/<code>release</code>.

          <br><dt><code>acquire()</code><a name="index-acquire_0028_0029-22"></a><dd>Is responsible to get the initial value of the bound from processor that manage it. 
If such an initial value exists, then the method take the last updated value as the current value.

          <br><dt><code>release()</code><a name="index-release_0028_0029-23"></a><dd>Is responsible to update all copies of the bound is the local value has been updated. 
After the invocation of release, the local processor that has release the bound should re-invoke i<code>acquire</code>: the read value will be the updated value. 
Other processor will be able to read the updated value in a bounded time.

          <br><dt><code>read()</code><a name="index-read_0028_0029-24"></a><dd>is responsible returns a reference to the last value acquired by the invocation to <code>acquire</code>. 
The invocation of read should be surround by invocations to <code>acquire</code>/<code>release</code>. 
Multiple read may be invoked between invocations to <code>acquire</code>/<code>release</code>. 
</dl>

</dl>
   <!--  -->
<!-- @node remote iterator -->
<!-- @section Remote -->

   <p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
<div class="node">
<a name="synchronized-blocks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#algorithms">algorithms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#monotonic-bound">monotonic bound</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.4 SyncGuard</h3>

     <dl>
<dt><strong>Declaration</strong><dd>
     <pre class="example">          class SyncGuard
          {
              SyncGuard();
              ~SyncGuard();
          };
</pre>
     <br><dt><strong>Methods</strong><dd>
          <dl>
<dt><code>SyncGuard()</code><a name="index-SyncGuard_0028_0029-25"></a><dd>Constructor of the class. 
When an object of class <code>SyncGuard</code> is created, it creates a special fram in which all further tasks willbe spawned. 
When the object is destroyed, the frame is closed and all generated tasks are executed.

          <br><dt><code>~SyncGuard()</code><a name="index-g_t_007eSyncGuard_0028_0029-26"></a><dd>Destructor of the class. 
When called, it forces the execution of all tasks in its frame. 
This method only returns when  all tasks (and children) have been executed. 
</dl>

</dl>

<!--  -->
<div class="node">
<a name="algorithms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#utilities">utilities</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#synchronized-blocks">synchronized blocks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.5 Algorithms</h3>

     <dl>
<dt><code>for_each</code><a name="index-for_005feach-27"></a><dd>
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template &lt;class InputIterator, class Function&gt;
               void for_each (InputIterator first, InputIterator last, Function f,
                 typename std::iterator_traits&lt;InputIterator&gt;::difference_type threshold = 0);
</pre>
          <br><dt><strong>Algorithm</strong><dd>Applies function <var>f</var> to each of the elements in the range [<var>first</var>,<var>last</var>).

          <p>The behavior of this template function is equivalent to:

          <pre class="example">               template&lt;class InputIterator, class Function&gt;
               void for_each(InputIterator first, InputIterator last, Function f)
               {
                 while ( first!=last ) f(*first++);
               }
</pre>
          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>first</var><dt><var>last</var><dd>Input iterators to the initial and final positions in a sequence. 
The range used is [<var>first</var>,<var>last</var>), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last.

               <br><dt><var>f</var><dd>Unary function taking an element in the range as argument. 
This can either <em>not</em> be a pointer to a function. 
It <em>must</em> be  an object whose class overloads <code>operator()</code>. 
Its return value, if any, is ignored.

               <br><dt><var>threshold</var><dd>integer used as grain size. It is comutedn automatically if not provided, but should be set by hand for best performances. 
</dl>

               <ul>
<li>as an additionnal requirement, <var>f</var> and data from <var>first</var> to <var>last</var> must all be communicable !! 
<li>Currently, only pointers iterator are supported. 
<li>no hypothesis can be made on the order of appliance for <var>f</var>. 
</ul>

     </dl>

     <br><dt><code>transform</code><a name="index-transform-28"></a><dd>
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template &lt; class InputIterator, class OutputIterator, class UnaryOperator &gt;
               void transform ( InputIterator first1, InputIterator last1,
                                          OutputIterator result, UnaryOperator op,
                                          size_t threshold = 0 );
               
               template &lt; class InputIterator1, class InputIterator2,
                          class OutputIterator, class BinaryOperator &gt;
               void transform ( InputIterator1 first1, InputIterator1 last1,
                                          InputIterator2 first2, OutputIterator result,
                                          BinaryOperator binary_op,
                                          size_t threshold = 0 );
</pre>
          <br><dt><strong>Algorithm</strong><dd>The first version applies op to all the elements in the input range ([<var>first1</var>,<var>last1</var>)) and stores each returned value in the range beginning at result. 
The second version uses as argument for each call to binary_op one element from the first input range ([<var>first1</var>,<var>last1</var>)) and one element from the second input range (beginning at <var>first2</var>).

          <p>The behavior of this function template is equivalent to:

          <pre class="example">               template &lt; class InputIterator, class OutputIterator, class UnaryOperator &gt;
               void transform ( InputIterator first1, InputIterator last1,
                                          OutputIterator result, UnaryOperator op )
               {
                 while (first1 != last1)
                   *result++ = op(*first1++);  // or: *result++=binary_op(*first1++,*first2++);
               }
</pre>
          <p>The function allows for the destination range to be the same as one of the input ranges to make transformations <em>in place</em>.

          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>first1</var><dt><var>last1</var><dd>
    Input iterators to the initial and final positions of the first sequence. The range used is [<var>first1</var>,<var>last1</var>), which contains all the elements between <var>first1</var> and <var>last1</var>, including the element pointed by <var>first1</var> but not the element pointed by <var>last1</var>.

               <br><dt><var>first2</var><dd>    Input iterator to the initial position of the second range. The range includes as many elements as [<var>first1</var>,<var>last1</var>). 
<br><dt><var>result</var><dd>    Output iterator to the initial position of the range where function results are stored. The rangeincludes as many elements as [<var>first1</var>,<var>last1</var>). 
<br><dt><var>op</var><dd>    Unary function taking one element as argument, and returning some result value. 
    This can <em>not</em> be a pointer to a function. 
    It <em>must</em> be an object whose class overloads <code>operator()</code>. 
    <br><dt><var>binary_op</var><dd>    Binary function taking two elements as argument (one of each of the two sequences), and returning some result value. 
    This can <em>not</em> be a pointer to a function. 
    It <em>must</em> be an object whose class overloads <code>operator()</code>. 
<br><dt><var>shold</var><dd>    Value of the Grain size used to bound parallelism. If none given, it will be automatically computed, set it by hand for best performances. 
</dl>

               <ul>
<li>as an additionnal requirement, <var>binary_op</var> and data from <var>first1</var> to <var>last1</var>, <var>first2</var>, <var>result</var> must all be communicable !!

               <li>Currently, only pointers iterator are supported.

               <li>no hypothesis can be made on the order of appliance for <var>binary_op</var>. 
</ul>
          </dl>

     <br><dt><code>find</code><a name="index-find-29"></a><dd>
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template &lt;class InputIterator, class T&gt;
               InputIterator find ( InputIterator first, InputIterator last, const T&amp; value,
                                    typename std::iterator_traits&lt;InputIterator&gt;::difference_type threshold = 0);
</pre>
          <br><dt><strong>Algorithm</strong><dd>
Returns an iterator to the first element in the range [<var>first</var>,<var>last</var>) that compares equal to <var>value</var>, or <var>last</var> if not found.

          <p>The behavior of this function template is equivalent to:

          <pre class="example">               template&lt;class InputIterator, class T&gt;
               InputIterator find ( InputIterator first, InputIterator last, const T&amp; value )
               {
                 for ( ;first!=last; first++) if ( *first==value ) break;
                 return first;
               }
</pre>
          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>first</var><dt><var>last</var><dd>Input iterators to the initial and final positions in a sequence. 
The range used is [<var>first</var>,<var>last</var>), which contains all the elements between <var>first</var> and <var>last</var>, including the element pointed by <var>first</var> but not the element pointed by <var>last</var>. 
<br><dt><var>value</var><dd>Value to be compared to each of the elements. 
<br><dt><var>threshold</var><dd>    Value of the Grain size used to bound parallelism. If none given, it will be automatically computed, set it by hand for best performances. 
</dl>

          <br><dt><strong>Return value</strong><dd>An iterator to the first element in the range that matches <var>value</var>. 
If no element matches, the function returns <var>last</var>.

     </dl>

          <ul>
<li>as an additionnal requirement, data from <var>first1</var> to <var>last1</var> and <var>value</var> must all be communicable !!

          <li>Currently, only pointers iterator are supported. 
</ul>

     <br><dt><code>find_if</code><a name="index-find_005fif-30"></a><dd>
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template &lt;class InputIterator, class T&gt;
               InputIterator find_if ( InputIterator first, InputIterator last, const T&amp; value, Predicate pred,
                                    typename std::iterator_traits&lt;InputIterator&gt;::difference_type threshold = 0);
</pre>
          <br><dt><strong>Algorithm</strong><dd>
Returns an iterator to the first element in the range [<var>first</var>,<var>last</var>) for which applying <var>pred</var> to it, is <var>true</var>.

          <p>The behavior of this function template is equivalent to:

          <pre class="example">               template&lt;class InputIterator, class Predicate&gt;
               InputIterator find_if ( InputIterator first, InputIterator last, Predicate pred )
               {
                 for ( ; first!=last ; first++ ) if ( pred(*first) ) break;
                 return first;
               }
</pre>
          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>first</var><dt><var>last</var><dd>    Input iterators to the initial and final positions in a sequence. The range used is [<var>first</var>,<var>last</var>), which contains all the elements between <var>first</var> and <var>last</var>, including the element pointed by <var>first</var> but not the element pointed by <var>last</var>. 
<br><dt><var>pred</var><dd>    Unary predicate taking an element in the range as argument, and returning a value indicating the falsehood (with false, or a zero value) or truth (true, or non-zero) of some condition applied to it. 
    This can <em>not</em> be a pointer to a function. 
    It <em>must</em> be an object whose class overloads <code>operator()</code>. 
<br><dt><var>threshold</var><dd>    Value of the Grain size used to bound parallelism. If none given, it will be automatically computed, set it by hand for best performances. 
</dl>

          <br><dt><strong>Return value</strong><dd>An iterator to the first element in the range for which the application of <var>pred</var> to it does not return false (zero). 
If <var>pred</var> is false for all elements, the function returns <var>last</var>.

     </dl>

          <ul>
<li>as an additionnal requirement, <var>pred</var> and data from <var>first</var> to <var>last</var> must all be communicable !! 
<li><li>Currently, only pointers iterator are supported. 
</ul>

     <br><dt><code>sort and stable_sort</code><a name="index-sort-and-stable_005fsort-31"></a><dd>
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template &lt;class RandomAccessIterator&gt;
               void stable_sort ( RandomAccessIterator first, RandomAccessIterator last,
                   typename std::iterator_traits&lt;RandomAccessIterator&gt;::difference_type threshold = 0);
               
               template &lt;class RandomAccessIterator, class Compare&gt;
               void sort ( RandomAccessIterator first, RandomAccessIterator last,
                   typename std::iterator_traits&lt;RandomAccessIterator&gt;::difference_type threshold = 0);
</pre>
          <br><dt><strong>Algorithm</strong><dd>
Sorts the elements in the range [<var>first</var>,<var>last</var>) into ascending order. 
<code>stable_sort</code> also grants that the relative order of the elements with equivalent values is preserved.

          <p>The elements are compared using <code>operator&lt;</code>.

          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>first</var><dt><var>last</var><dd>    Random-Access iterators to the initial and final positions of the sequence to be sorted. The range used is [<var>first</var>,<var>last</var>), which contains all the elements between <var>first</var> and <var>last</var>, including the element pointed by first but not the element pointed by &ldquo;last&ldquo;. 
<br><dt><var>threshold</var><dd>    Value of the Grain size used to bound parallelism. If none given, it will be automatically computed, set it by hand for best performances. 
</dl>

               <ul>
<li>as an additionnal requirement, data from <var>first</var> to <var>last</var> must all be communicable !! 
<li>Currently, only pointers iterator are supported. 
</ul>

     </dl>

</dl>

<!--  -->
<div class="node">
<a name="utilities"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#dynamically-loaded-modules">dynamically loaded modules</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#algorithms">algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.6 Utilities</h3>

     <dl>
<dt><code>Util::logfile()</code><a name="index-Util_003a_003alogfile_0028_0029-32"></a><dd>manage logs.
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               std::ostream&amp; logfile();
</pre>
          <br><dt><strong>Return Value</strong><dd>returns a <code>std::ostream</code> reference that can be used to print out any kind of text. 
The text will be forwrded to the master node and displayed with a smaal header containing information about
               <ul>
<li>the global id of the source node
<li>the date when the log was taken (according to local clock)
</ul>
          </dl>

     <br><dt><code>Util::WallTimer::gettime()</code><a name="index-Util_003a_003aWallTimer_003a_003agettime_0028_0029-33"></a><dd>take time
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               double gettime();
</pre>
          <br><dt><strong>Return Value</strong><dd>time since the birth of Unix in milliseconds
</dl>

     <br><dt><code>resize_vector(std::vector&lt; a1::Shared&lt;...&gt; &gt;, size_type)</code><a name="index-resize_005fvector_0028std_003a_003avector_003c-a1_003a_003aShared_003c_002e_002e_002e_003e-_003e_002c-size_005ftype_0029-34"></a><dd>resize a vector of Shared.Its behavior is similar to vector::resize() method
          <dl>
<dt><strong>Description</strong><dd>
          <pre class="example">               template&lt;class T&gt;
               void resize_vector(std::vector&lt; a1::Shared&lt;T&gt; &gt;&amp; v,
                   typename std::vector&lt; a1::Shared&lt;T&gt; &gt;::size_type sz);
</pre>
          <br><dt><strong>Parameters</strong><dd>
               <dl>
<dt><var>v</var><dd>vector of shared to be resized
<br><dt><var>sz</var><dd>new size of the vector
</dl>

     </dl>

</dl>

<div class="node">
<a name="dynamically-loaded-modules"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#utilities">utilities</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API">API</a>

</div>

<h3 class="section">6.7 Dynamically Loaded Modules - enhance kaapi</h3>

<p>This tutorial will show you how to develop an external module and dynamically load it in any already compiled kaapi program.

<ul class="menu">
<li><a accesskey="1" href="#dlm-api">dlm api</a>:  the application programming interface for dynamically loaded module
<li><a accesskey="2" href="#load-dlm">load dlm</a>:  command line syntax to load extra dlm
</ul>

<div class="node">
<a name="dlm-api"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#load-dlm">load dlm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dynamically-loaded-modules">dynamically loaded modules</a>

</div>

<h4 class="subsection">6.7.1 API - interface required for a Dynamically loaded module</h4>

<p>Basically, a Dynamically loaded module is a standard <code>Kaapi</code> module. 
In order to make it dynamically loadable, you must also provide a <code>factory</code> function.

<div class="defun">
&mdash; Function: <b>create_module</b><var><a name="index-create_005fmodule-35"></a></var><br>
<blockquote><p><code>extern "C" Util::KaapiComponent* create_module();</code>
factory function that return a new instance of the <code>Util::KaapiComponent</code> derived class. 
The kaapi module loader will call the <code>delete_module</code> to free allocated memory. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>delete_module</b><var> kaapi_component<a name="index-delete_005fmodule-36"></a></var><br>
<blockquote><p><code>extern "C" void delete_module(Util::KaapiComponent* </code><var>kaapi_component</var>
The counterpart of the <code>create_module</code> function. 
Instead of allocating memory for a new module, it frees the memory of given pointer. 
</p></blockquote></div>

   <p>A detailed description of the <code>Util::KaapiComponent</code> is given in the doxygen documentation. 
As a simple reminder, it's interface is given here:
<pre class="example">     #include &lt;utils_component.h&gt;
     class Util::KaapiComponent
     {
     
         public:
         int initialize() throw();
         int terminate() throw();
         void add_options( Util::Parser* , Util::Properties* );
         void declare_dependencies();
     };
</pre>
   <p>Note that the <code>declare_dependencies</code> is of no use for dynamically loaded modules. 
These modules are loaded after all the static ones, in the order given at the command line.

<div class="node">
<a name="load-dlm"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dlm-api">dlm api</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dynamically-loaded-modules">dynamically loaded modules</a>

</div>

<h4 class="subsection">6.7.2 Command Line Interface - interface to load extra modules from the kaapi command line</h4>

<p>This sections describes the usage of the <em>dl</em> module in charge of the dynamic loading of extra modules. 
It uses the kaapi way of passing arguments to modules:
<samp><span class="option">--module-name</span></samp> <samp><span class="option">-option-name</span></samp> <var>value</var>
A description of a module option can be found by running any kaapi program with
<pre class="example">     $ kaapi_prog --help <var>module-name</var>
</pre>
   <p>The <em>dl</em> module provides two options:
     <dl>
<dt><samp><span class="option">-verboseon</span></samp><dd>set it to <var>true</var> or <var>false</var> to get status report from the <em>dl</em> module.

     <br><dt><samp><span class="option">-load</span></samp><dd>description of the module to load, in the form
     <pre class="example">          (path_to_the_module.so(:arguments of the module)?,)*path_to_the_module.so(:arguments of the module)
</pre>
     </dl>
   <!--  -->

<div class="node">
<a name="function-methods-and-classes-index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#API">API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Function, methods and classes index</h2>

<ul class="index-fn" compact>
<li><a href="#index-access_0028_0029-17"><code>access()</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-acquire_0028_0029-22"><code>acquire()</code></a>: <a href="#monotonic-bound">monotonic bound</a></li>
<li><a href="#index-create_005fmodule-35"><code>create_module</code></a>: <a href="#dlm-api">dlm api</a></li>
<li><a href="#index-cumul_0028T-t_0029-19"><code>cumul(T t)</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-delete_005fmodule-36"><code>delete_module</code></a>: <a href="#dlm-api">dlm api</a></li>
<li><a href="#index-find-29"><code>find</code></a>: <a href="#algorithms">algorithms</a></li>
<li><a href="#index-find_005fif-30"><code>find_if</code></a>: <a href="#algorithms">algorithms</a></li>
<li><a href="#index-for_005feach-27"><code>for_each</code></a>: <a href="#algorithms">algorithms</a></li>
<li><a href="#index-Fork_0028Attribute-_003d-DefaultAttribut_0029-5"><code>Fork(Attribute = DefaultAttribut)</code></a>: <a href="#fork">fork</a></li>
<li><a href="#index-get_005fdata_0028_0029-11"><code>get_data()</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-MonotonicBound_0028const-string_0026-name_002c-T_002a-initial_005fvalue-_003d-0-_0029-20"><code>MonotonicBound(const string&amp; name, T* initial_value = 0 )</code></a>: <a href="#monotonic-bound">monotonic bound</a></li>
<li><a href="#index-read_0028_0029-24"><code>read()</code></a>: <a href="#monotonic-bound">monotonic bound</a></li>
<li><a href="#index-read_0028_0029-13"><code>read()</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-release_0028_0029-23"><code>release()</code></a>: <a href="#monotonic-bound">monotonic bound</a></li>
<li><a href="#index-resize_005fvector_0028std_003a_003avector_003c-a1_003a_003aShared_003c_002e_002e_002e_003e-_003e_002c-size_005ftype_0029-34"><code>resize_vector(std::vector&lt; a1::Shared&lt;...&gt; &gt;, size_type)</code></a>: <a href="#utilities">utilities</a></li>
<li><a href="#index-Shared-7"><code>Shared</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_0028_0029-8"><code>Shared()</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_0028T-_0040var_007bt_007d_0029-9"><code>Shared(T </code><var>t</var><code>)</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_0028T_002a-_0029-10"><code>Shared(T* )</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_005fcw-18"><code>Shared_cw</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_005fr-12"><code>Shared_r</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_005frw-16"><code>Shared_rw</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-Shared_005fw-14"><code>Shared_w</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-sort-and-stable_005fsort-31"><code>sort and stable_sort</code></a>: <a href="#algorithms">algorithms</a></li>
<li><a href="#index-SyncGuard_0028_0029-25"><code>SyncGuard()</code></a>: <a href="#synchronized-blocks">synchronized blocks</a></li>
<li><a href="#index-transform-28"><code>transform</code></a>: <a href="#algorithms">algorithms</a></li>
<li><a href="#index-update_0028const-T_0026-t_0029-21"><code>update(const T&amp; t)</code></a>: <a href="#monotonic-bound">monotonic bound</a></li>
<li><a href="#index-Util_003a_003alogfile_0028_0029-32"><code>Util::logfile()</code></a>: <a href="#utilities">utilities</a></li>
<li><a href="#index-Util_003a_003aWallTimer_003a_003agettime_0028_0029-33"><code>Util::WallTimer::gettime()</code></a>: <a href="#utilities">utilities</a></li>
<li><a href="#index-void-operator_0028_0029-_0028_002e_002e_002e_0029-6"><code>void operator() (...)</code></a>: <a href="#fork">fork</a></li>
<li><a href="#index-write_0028_0029-15"><code>write()</code></a>: <a href="#shared">shared</a></li>
<li><a href="#index-g_t_007eSyncGuard_0028_0029-26"><code>~SyncGuard()</code></a>: <a href="#synchronized-blocks">synchronized blocks</a></li>
   </ul></body></html>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Net::Device Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_net.html">Net</a>::<a class="el" href="class_net_1_1_device.html">Device</a>
  </div>
</div>
<div class="contents">
<h1>Net::Device Class Reference</h1><!-- doxytag: class="Net::Device" --><!-- doxytag: inherits="Util::Object,Net::NetworkObject,Net::Callback,Net::Upcall" -->
<p><code>#include &lt;network_device.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Net::Device:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_device__inherit__graph.png" border="0" usemap="#_net_1_1_device_inherit__map" alt="Inheritance graph"/></div>
<map name="_net_1_1_device_inherit__map" id="_net_1_1_device_inherit__map">
<area shape="rect" id="node20" href="class_f_d_n_e_t_1_1_device.html" title="FDNET::Device" alt="" coords="557,5,685,35"/><area shape="rect" id="node22" href="class_m_a_n_e_t_1_1_device.html" title="MANET::Device" alt="" coords="556,59,687,88"/><area shape="rect" id="node24" href="class_m_y_n_e_t_1_1_device.html" title="MYNET::Device" alt="" coords="556,112,687,141"/><area shape="rect" id="node26" href="class_s_o_c_k_n_e_t_1_1_device.html" title="SOCKNET::Device" alt="" coords="548,165,695,195"/><area shape="rect" id="node28" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html" title="TAKTUKNET::Device" alt="" coords="540,219,703,248"/><area shape="rect" id="node30" href="class_u_d_p_n_e_t_1_1_device.html" title="UDPNET::Device" alt="" coords="552,272,691,301"/><area shape="rect" id="node2" href="class_util_1_1_object.html" title="Object with synchronisation mutex and condition variablesThe Object class defines..." alt="" coords="207,59,305,88"/><area shape="rect" id="node4" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="9,5,124,35"/><area shape="rect" id="node6" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors..." alt="" coords="17,59,116,88"/><area shape="rect" id="node8" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="7,112,127,141"/><area shape="rect" id="node10" href="class_net_1_1_network_object.html" title="Net::NetworkObject" alt="" coords="176,112,336,141"/><area shape="rect" id="node12" href="class_net_1_1_callback.html" title="Net::Callback" alt="" coords="197,165,315,195"/><area shape="rect" id="node14" href="class_util_1_1_callback.html" title="Util::Callback" alt="" coords="9,192,124,221"/><area shape="rect" id="node16" href="class_net_1_1_upcall.html" title="Net::Upcall" alt="" coords="207,219,305,248"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Net::Device:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_device__coll__graph.png" border="0" usemap="#_net_1_1_device_coll__map" alt="Collaboration graph"/></div>
<map name="_net_1_1_device_coll__map" id="_net_1_1_device_coll__map">
<area shape="rect" id="node12" href="class_net_1_1_network.html" title="Net::Network" alt="" coords="1951,456,2065,485"/><area shape="rect" id="node26" href="class_net_1_1_cluster.html" title="Net::Cluster" alt="" coords="2867,225,2973,255"/><area shape="rect" id="node38" href="class_net_1_1_device_object.html" title="Net::DeviceObject" alt="" coords="1933,320,2083,349"/><area shape="rect" id="node44" href="class_net_1_1_i_o_instruction_stream.html" title="Net::IOInstructionStream" alt="" coords="3167,996,3364,1025"/><area shape="rect" id="node2" href="class_util_1_1_object.html" title="Object with synchronisation mutex and condition variablesThe Object class defines..." alt="" coords="1105,724,1204,753"/><area shape="rect" id="node35" href="class_net_1_1_channel.html" title="Net::Channel" alt="" coords="2453,785,2568,815"/><area shape="rect" id="node78" href="class_net_1_1_i_o_daemon.html" title="Net::IODaemon" alt="" coords="2853,943,2987,972"/><area shape="rect" id="node4" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="713,881,828,911"/><area shape="rect" id="node80" href="class_util_1_1_thread.html" title="POSIX interface to thread." alt="" coords="2457,1256,2564,1285"/><area shape="rect" id="node6" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors..." alt="" coords="721,935,820,964"/><area shape="rect" id="node103" href="class_util_1_1_event_buffer_manager.html" title="A Generic Buffer Manager : EventBufferManager EventBufferManager is an implementation..." alt="" coords="2819,1568,3021,1597"/><area shape="rect" id="node8" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="711,1619,831,1648"/><area shape="rect" id="node10" href="class_net_1_1_network_object.html" title="Net::NetworkObject" alt="" coords="2431,365,2591,395"/><area shape="rect" id="node15" href="class_net_1_1_callback.html" title="Net::Callback" alt="" coords="1096,259,1213,288"/><area shape="rect" id="node17" href="class_util_1_1_callback.html" title="Util::Callback" alt="" coords="713,489,828,519"/><area shape="rect" id="node23" href="class_net_1_1_upcall.html" title="Net::Upcall" alt="" coords="1105,489,1204,519"/><area shape="rect" id="node19" href="class_util_1_1_atomic.html" title="Atomic object represents atomic operation over integer.This class implements object..." alt="" coords="364,611,465,640"/><area shape="rect" id="node21" href="struct_util_1_1kaapi__atomic__t.html" title="Util::kaapi_atomic_t" alt="" coords="5,668,165,697"/><area shape="rect" id="node30" href="class_net_1_1_node_info.html" title="Net::NodeInfo" alt="" coords="3204,303,3327,332"/><area shape="rect" id="node33" href="class_net_1_1_out_channel.html" title="Net::OutChannel" alt="" coords="2849,1100,2991,1129"/><area shape="rect" id="node41" href="class_util_1_1_global_id.html" title="Class for representing a global identifier of the distributed processusGlobal Identifier..." alt="" coords="1099,1153,1211,1183"/><area shape="rect" id="node91" href="class_util_1_1_o_event_stream.html" title="Output events stream: Util::OEventStream." alt="" coords="1929,1467,2087,1496"/><area shape="rect" id="node95" href="class_util_1_1_event_buffer.html" title="A Generic Trace Buffer class: Util::EventBuffer." alt="" coords="1547,1408,1685,1437"/><area shape="rect" id="node46" href="class_util_1_1_queable.html" title="Util::Queable\&lt; IOInstructionStream \&gt;" alt="" coords="1865,1051,2151,1080"/><area shape="rect" id="node121" href="class_util_1_1_queue.html" title="Util::Queue\&lt; IOInstructionStream \&gt;" alt="" coords="2373,995,2648,1024"/><area shape="rect" id="node49" href="class_util_1_1_queable.html" title="Base class of object queueable into double linked list.To be en(de)queueable in a..." alt="" coords="695,1344,847,1373"/><area shape="rect" id="node63" href="class_util_1_1_queable.html" title="Util::Queable\&lt; OutChannel \&gt;" alt="" coords="1295,1351,1521,1380"/><area shape="rect" id="node97" href="class_util_1_1_queable.html" title="Util::Queable\&lt; EventBuffer \&gt;" alt="" coords="1041,1508,1268,1537"/><area shape="rect" id="node51" href="struct_net_1_1_i_o_instruction.html" title="Net::IOInstruction" alt="" coords="2847,1377,2993,1407"/><area shape="rect" id="node53" href="struct_net_1_1_i_o_put_instruction.html" title="Net::IOPutInstruction" alt="" coords="2425,1377,2596,1407"/><area shape="rect" id="node55" href="struct_net_1_1_i_o_del_instruction.html" title="Net::IODelInstruction" alt="" coords="2425,1431,2596,1460"/><area shape="rect" id="node70" href="class_util_1_1_r_w_lock.html" title="Read&#45;Write lockThis class implements interface for Posix Read&#45;Write lock. All errors..." alt="" coords="2456,231,2565,260"/><area shape="rect" id="node84" href="class_util_1_1_key.html" title="Util::Key\&lt; ByteAllocator \&gt;" alt="" coords="1907,1363,2109,1392"/><area shape="rect" id="node86" href="class_util_1_1_key.html" title="Thread private attributeThis class provides an interface to posix pthread specific..." alt="" coords="1556,1235,1676,1264"/><area shape="rect" id="node88" href="class_util_1_1_key.html" title="Util::Key\&lt; Thread \&gt;" alt="" coords="1927,1256,2089,1285"/><area shape="rect" id="node93" href="class_util_1_1_context_id.html" title="Util::ContextId" alt="" coords="1093,1396,1216,1425"/><area shape="rect" id="node110" href="class_util_1_1_queue.html" title="Util::Queue\&lt; EventBuffer \&gt;" alt="" coords="2403,1484,2619,1513"/><area shape="rect" id="node106" href="class_util_1_1_reify_notify_signal.html" title="ReifyNotifySignalThis class allows to reify the invocations to InterfaceSignal::signal..." alt="" coords="2423,1763,2599,1792"/><area shape="rect" id="node113" href="class_util_1_1_queue.html" title="Double linked list (thread unsafe)The queue descriptor is linked to the first and..." alt="" coords="1937,1309,2079,1339"/><area shape="rect" id="node128" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; CallStack \&gt;" alt="" coords="665,828,876,857"/><area shape="rect" id="node130" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; CallStack \&gt;" alt="" coords="311,943,519,972"/><area shape="rect" id="node133" href="class_util_1_1_linkable.html" title="Base class to make cells linkable in single linked listTo be (de)linkable in single..." alt="" coords="9,880,161,909"/><area shape="rect" id="node143" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; Bloc \&gt;" alt="" coords="328,795,501,824"/><area shape="rect" id="node135" href="class_util_1_1_stack_list.html" title="Thread linked list (thread unsafe)The StackList descriptor is linked to the top element..." alt="" coords="337,848,492,877"/><area shape="rect" id="node141" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; Bloc \&gt;" alt="" coords="683,753,859,783"/><area shape="rect" id="node137" href="class_net_1_1_device_factory.html" title="Net::DeviceFactory" alt="" coords="1076,317,1233,347"/><area shape="rect" id="node139" href="class_util_1_1_byte_allocator.html" title="ByteAllocator of fixed size objects with cache for fast allocation (thread unsafe)A..." alt="" coords="1081,371,1228,400"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_net_1_1_device-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a8309630e99a85c8b7da89785df7ab2d9">Device</a> (<a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *nf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#af44e8cbf51e7020527fdcba3b3c79d5b">~Device</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Device initialilization and termination</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpeb7330053803170a8a2a723932c32f3f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a222585f4329c1a38553e274809bc6069">initialize</a> (<a class="el" href="class_net_1_1_network.html">Network</a> *net)  throw (RuntimeError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#af60adaf78a2b2aa085c94187e16b7a40">commit</a> ()  throw (RuntimeError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a3dacb246262acc8a566cc5ef3078aff0">terminate</a> ()  throw (RuntimeError)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bloc memory management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp607a99b85e8a21dd416a377f7e7c62c9"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a2488452281b7c84b0a919ca39bb9c36c">size_bloc</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a4c78c7551d22ddc8e74744040fc64cc7">allocate_bloc</a> ()  throw (BadAlloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#aa4be1b660e073965a085e4e705083c4f">deallocate_bloc</a> (void *data)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a4cc0380d617922a3772083307912f965">allocate_data</a> (size_t sz)  throw (BadAlloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a2e367ea761cc83978c7e54f4b8f09c5f">deallocate_data</a> (void *data)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a71d2e60e8ce01b3a31166fd699e09302">map_zone</a> (void *begin, size_t sz)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a10285c49445e106cbf957a4ee3db0565">umap_zone</a> (void *begin, size_t sz)  throw (InvalidArgumentError)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Server interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp46a92393e302ecf654355247217f7d54"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a3d4276cb9e721566ef22688dd32c82bd">allocate_callstack</a> ()  throw (BadAlloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#af3109f4e149e51f9df67cc9e4b8337d5">deallocate_callstack</a> (<a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#ae23fea88e4eb549d024fa9519f82a148">acquire_callstack</a> ()  throw (BadAlloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a185e0f4163761fac7a57c9b50e4c66b6">release_callstack</a> (<a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *)  throw (InvalidArgumentError)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Error handling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpaf042bafd560f7bd09b37efa40772311"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a3e958644b17afc9da9fce348871cb0e4">signal</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *ch, <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a218578771d7461b26e9b4b591a6ea49f">signal</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch, <a class="el" href="class_net_1_1_header.html">Header</a> *header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a64da32b06f9e445e088c603d13590a3e">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *ch, <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a25375abf68573b9ba83f704616c55127">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch, <a class="el" href="class_net_1_1_header.html">Header</a> *header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a84a588bb50158140cc78de5758a8c913">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a> error_no)</td></tr>
<tr><td colspan="2"><h2>Management of Device</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpf204caa22cf0c49b04dcafdb62216575"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="class_net_1_1_device.html">Device</a> * &gt;::<a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#ac6dd418b895f9771feafb49bb0422a47">open_channel</a> (const std::string &amp;url)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a1fb173d97fdcb9b790afb31296ca5baf">close_channel</a> (<a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *channel)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#aa031cb9fa0068116361eddced186176c">get_factory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a8343ee00bc7177cfb55d8b0431bcd3d1">register_factory</a> (<a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *nf)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#aa543a7d0f90e8004f7a6c79465e7fdcb">get_device_factory</a> (const std::string &amp;name)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#aaf3d144975b1dc840eb84e0cbef80a2f">create_device</a> (const std::string &amp;name)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a780be817fc0b70c5eb021ab2295bfbd1">resolve_device</a> (const std::string &amp;name)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a9b3282e8b25090b430eea0c4188b4fe6">destroy_device</a> (<a class="el" href="class_net_1_1_device.html">Device</a> *net)  throw (InvalidArgumentError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a07d08de1aef5715878bbe67e3d2a39a2">begin</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a69a0378fdc03fba016f4dede77d36702">end</a> ()  throw ()</td></tr>
<tr><td colspan="2"><h2>Misc</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp74248c725e00bf9fe04df4e35b249a19"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#aaad11dd111eb3b5024d1284c4cec71a7">_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of the device.  <a href="#aaad11dd111eb3b5024d1284c4cec71a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#af0fb9f9d2d9c8f30cd7551a88a405221">_szlistcc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">size of the entries in _listscc  <a href="#af0fb9f9d2d9c8f30cd7551a88a405221"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_stack_list.html">Util::StackList</a>&lt; <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a58933d133fe315c3149858435557b1bd">_listcc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free list of call stack  <a href="#a58933d133fe315c3149858435557b1bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#af66ed700e5b8cf3fe6272f00801fc07a">_factory</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the factory of this device  <a href="#af66ed700e5b8cf3fe6272f00801fc07a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a60cc78b54a2732e5c54cebc400c8dfe4">_access_bloc_alloc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">to lock access to bloc allocator  <a href="#a60cc78b54a2732e5c54cebc400c8dfe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#afe7628a7f9d43ed2e31fa227bf2d3b07">_bloc_size</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">size of the packet  <a href="#afe7628a7f9d43ed2e31fa227bf2d3b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_byte_allocator.html">Util::ByteAllocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#ac2e2ba85985d53714712a531021bb0b0">_bloc_allocator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">packet allocator for IA and IOVect entries  <a href="#ac2e2ba85985d53714712a531021bb0b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a8ab3cf206ea4374251e7da0f6a38fb67">IODaemon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#acb1172fca541ea3cf6a9363dbbbad057">IOInstructionStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#a8db5976db3d52a50868138a3702d47e6">get_urlconnect</a> () const =0  throw (IOError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_device.html#ae889c3cef491a6fc240236450eb332a0">dump_info</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_net_1_1_device.html">Device</a> is the class to manage connexion (input / output) to a specific transport protocol (tcp, udp, taktuk,...) </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a95eb3db2ab61d710584fbd365784d45a"></a><!-- doxytag: member="Net::Device::iterator" ref="a95eb3db2ab61d710584fbd365784d45a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="class_net_1_1_device.html">Device</a>*&gt;::<a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a> <a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">Net::Device::iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8309630e99a85c8b7da89785df7ab2d9"></a><!-- doxytag: member="Net::Device::Device" ref="a8309630e99a85c8b7da89785df7ab2d9" args="(DeviceFactory *nf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Net::Device::Device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>nf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#a6a3aa9b8d4b542b320aa7e67fd9091b6">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#a244fba1f41678ac60afb69c1294f5845">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a78388bed0e4e13f8bf7bb043f476fa7d">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a002d9271f3b09b837d82ba1619daa81f">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#ac629dc4f8fce50de29fa62fdaa0c2de3">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#a2e65ff9898d4bc1cca32f627a7b0b181">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="af44e8cbf51e7020527fdcba3b3c79d5b"></a><!-- doxytag: member="Net::Device::~Device" ref="af44e8cbf51e7020527fdcba3b3c79d5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Net::Device::~Device </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#ad08da23079836e15fde8bc62e69d4644">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#aaa91ae135920af0018d4383441d571bb">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a4d7d8ba57510de9a276f547228ba07db">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a87229df1ecb56e7202ed169e7feccee5">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#a2014f49c1aeeb580d295474d602a8b58">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#a187b6685609ec8e89242d3158fbf077b">UDPNET::Device</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae23fea88e4eb549d024fa9519f82a148"></a><!-- doxytag: member="Net::Device::acquire_callstack" ref="ae23fea88e4eb549d024fa9519f82a148" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_1_1_call_stack.html">CallStack</a>* Net::Device::acquire_callstack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_bad_alloc.html">BadAlloc</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire a call context for a new incomming communication. The network store a free list of callstack : acquire_callstack first tries to allocate in the free list before call allocate_callstack. The returned call context is acquired. This method is not thread aware with respect to the network object : the caller should ensure that no multiple thread call it at the same time. </p>

</div>
</div>
<a class="anchor" id="a4c78c7551d22ddc8e74744040fc64cc7"></a><!-- doxytag: member="Net::Device::allocate_bloc" ref="a4c78c7551d22ddc8e74744040fc64cc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* Net::Device::allocate_bloc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_bad_alloc.html">BadAlloc</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new bloc Default implementation uses the _bloc_allocator initialized from bloc size option. See module options. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non null pointer to a packet or throw a BadAlloc exception </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BadAlloc</em>&nbsp;</td><td>if allocation failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d4276cb9e721566ef22688dd32c82bd"></a><!-- doxytag: member="Net::Device::allocate_callstack" ref="a3d4276cb9e721566ef22688dd32c82bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_1_1_call_stack.html">CallStack</a>* Net::Device::allocate_callstack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_bad_alloc.html">BadAlloc</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new call context to treats incomming message The method MUST no has a default implementation. </p>

</div>
</div>
<a class="anchor" id="a4cc0380d617922a3772083307912f965"></a><!-- doxytag: member="Net::Device::allocate_data" ref="a4cc0380d617922a3772083307912f965" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* Net::Device::allocate_data </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_bad_alloc.html">BadAlloc</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate sz bytes in network memory Default implantation return a new bloc of memory allocated by std::malloc </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sz</em>&nbsp;</td><td>(IN) size of the memory region in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07d08de1aef5715878bbe67e3d2a39a2"></a><!-- doxytag: member="Net::Device::begin" ref="a07d08de1aef5715878bbe67e3d2a39a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a> Net::Device::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return begin iterator over the created device </p>

</div>
</div>
<a class="anchor" id="a1fb173d97fdcb9b790afb31296ca5baf"></a><!-- doxytag: member="Net::Device::close_channel" ref="a1fb173d97fdcb9b790afb31296ca5baf" args="(OutChannel *channel)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::close_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the channel The method is called to close the channel after it all references to it have been released on the network level. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>the channel to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_net_1_1_device.html#ac6dd418b895f9771feafb49bb0422a47">open_channel</a> </dd></dl>

<p>Implemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#af2dc973a75cf0b20c23980708ff9c669">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#a8d1800fccb1e314647f09b44e2c96f4e">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a0acbbeaf9f050c8907a8eb8935e50c6a">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a525d76b638236373b2c559b9bead9215">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#aff8070cba70eb806d4dae0bd60dad4e2">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#aaa7be2ac3d18897ed8ae0e818e9d22c9">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="af60adaf78a2b2aa085c94187e16b7a40"></a><!-- doxytag: member="Net::Device::commit" ref="af60adaf78a2b2aa085c94187e16b7a40" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::commit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Second stage of initialization of a device Terminate the initialization process, accept incomming message and local node may send message to known hosts. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this method should be called from derived class to initialize data members </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidArgumentError</em>&nbsp;</td><td>bad parameters passed in properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RuntimeError</em>&nbsp;</td><td>kind of exception is thrown in case of error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#abc3908669693616efa981e5f05701c4d">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#ac1546160376030479d0d41c48deb0e8d">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a763b849598d031485dcb39209a35806a">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a89ad004c6f83b8365c3d6d095fe56433">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#a2cd1b6da527c39bc190a37cd86d08e0d">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#ae85a870f30f6d2989a5ecf47d50a04bb">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="aaf3d144975b1dc840eb84e0cbef80a2f"></a><!-- doxytag: member="Net::Device::create_device" ref="aaf3d144975b1dc840eb84e0cbef80a2f" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_net_1_1_device.html">Device</a>* Net::Device::create_device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new non initialized network object </p>

</div>
</div>
<a class="anchor" id="aa4be1b660e073965a085e4e705083c4f"></a><!-- doxytag: member="Net::Device::deallocate_bloc" ref="aa4be1b660e073965a085e4e705083c4f" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::deallocate_bloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate a new bloc </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the pointer to the packet </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidArgumentError</em>&nbsp;</td><td>if the pointer was not allocated by allocate_bloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3109f4e149e51f9df67cc9e4b8337d5"></a><!-- doxytag: member="Net::Device::deallocate_callstack" ref="af3109f4e149e51f9df67cc9e4b8337d5" args="(CallStack *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::deallocate_callstack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate a call context The method MUST no has a default implementation. </p>

</div>
</div>
<a class="anchor" id="a2e367ea761cc83978c7e54f4b8f09c5f"></a><!-- doxytag: member="Net::Device::deallocate_data" ref="a2e367ea761cc83978c7e54f4b8f09c5f" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::deallocate_data </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate a previously allocated network memory Default implantation free memory by using std::free </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>(IN) memory region to deallocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b3282e8b25090b430eea0c4188b4fe6"></a><!-- doxytag: member="Net::Device::destroy_device" ref="a9b3282e8b25090b430eea0c4188b4fe6" args="(Device *net)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Net::Device::destroy_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td>
          <td class="paramname"> <em>net</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy a created device </p>

</div>
</div>
<a class="anchor" id="ae889c3cef491a6fc240236450eb332a0"></a><!-- doxytag: member="Net::Device::dump_info" ref="ae889c3cef491a6fc240236450eb332a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::dump_info </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump on std::cout (debug) </p>

</div>
</div>
<a class="anchor" id="a69a0378fdc03fba016f4dede77d36702"></a><!-- doxytag: member="Net::Device::end" ref="a69a0378fdc03fba016f4dede77d36702" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_net_1_1_device.html#a95eb3db2ab61d710584fbd365784d45a">iterator</a> Net::Device::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return end iterator over the created device </p>

</div>
</div>
<a class="anchor" id="aa543a7d0f90e8004f7a6c79465e7fdcb"></a><!-- doxytag: member="Net::Device::get_device_factory" ref="aa543a7d0f90e8004f7a6c79465e7fdcb" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a>* Net::Device::get_device_factory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the device factory of device of name 'name' </p>

</div>
</div>
<a class="anchor" id="aa031cb9fa0068116361eddced186176c"></a><!-- doxytag: member="Net::Device::get_factory" ref="aa031cb9fa0068116361eddced186176c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a>* Net::Device::get_factory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the factory for this device </p>

</div>
</div>
<a class="anchor" id="a8db5976db3d52a50868138a3702d47e6"></a><!-- doxytag: member="Net::Device::get_urlconnect" ref="a8db5976db3d52a50868138a3702d47e6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; Net::Device::get_urlconnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_util_1_1_i_o_error.html">IOError</a>)<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the url to be broadcast if other node want to connect to this node </p>

<p>Implemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#aa083c10073174a8e1be9b161743a4113">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#aca6a7e7663682d94314b3ca5097ac112">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a90ed61191707fdab8dd0a7c58e66b122">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a8a79d50ac5236de91fe250ef71e07ab5">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#afa885c16d4b638fc70de0453884c7c75">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#a807cdffa77781dd1d8b06d46d05c8f02">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="a222585f4329c1a38553e274809bc6069"></a><!-- doxytag: member="Net::Device::initialize" ref="a222585f4329c1a38553e274809bc6069" args="(Network *net)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_network.html">Network</a> *&nbsp;</td>
          <td class="paramname"> <em>net</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialization of the device </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidArgumentError</em>&nbsp;</td><td>bad parameters passed in properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RuntimeError</em>&nbsp;</td><td>kind of exception is thrown in case of error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#aacac5104a06977147c0b9ef53f4d4fdf">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#a81e691c6894876355eef17c906e914a5">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a95060513f5d8b3c43d62bb73d8d8c431">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#aefb8787e76fb11290851eb199a7b8424">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#aa4665dbb2326006c66a5c6ee84d9a332">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#a5097004f2db03f8193153f5c316cff4c">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="a71d2e60e8ce01b3a31166fd699e09302"></a><!-- doxytag: member="Net::Device::map_zone" ref="a71d2e60e8ce01b3a31166fd699e09302" args="(void *begin, size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::map_zone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add to network memory a part of user memory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>(IN)IN) beginning address of the memory block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sz</em>&nbsp;</td><td>sz (IN)in bytes of the memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The zone is mapped. The really mapped zone is the rounding of zone in system page size unit. At this level, no registering of concurrent mappings or overlapping of zones are done. </dd>
<dd>
this function should be called once on a user memory zone. Default implantation do nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a84a588bb50158140cc78de5758a8c913"></a><!-- doxytag: member="Net::Device::notify" ref="a84a588bb50158140cc78de5758a8c913" args="(Util::ComFailure::Code error_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Method call on the server side when disconnection appears Inherited from <a class="el" href="class_util_1_1_callback.html">Util::Callback</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_callback.html#a9ac08165e43ae8373367c7bd131d3bbd">Net::Callback</a>.</p>

</div>
</div>
<a class="anchor" id="a25375abf68573b9ba83f704616c55127"></a><!-- doxytag: member="Net::Device::notify" ref="a25375abf68573b9ba83f704616c55127" args="(Util::ComFailure::Code error_no, OutChannel *ch, Header *header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_header.html">Header</a> *&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify </p>

<p>Implements <a class="el" href="class_net_1_1_callback.html#aba70566eab9ea25e04671f5ec34d997f">Net::Callback</a>.</p>

<p>Reimplemented in <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#aee08781b6581f81f987032144edc89bf">SOCKNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="a64da32b06f9e445e088c603d13590a3e"></a><!-- doxytag: member="Net::Device::notify" ref="a64da32b06f9e445e088c603d13590a3e" args="(Util::ComFailure::Code error_no, InChannel *ch, CallStack *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">Util::ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify </p>

<p>Implements <a class="el" href="class_net_1_1_upcall.html#ab77233ca34f008c05b1431363ed6c900">Net::Upcall</a>.</p>

<p>Reimplemented in <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#aabb4f24d6d99d5c1c5b6c8ccdf3836a6">SOCKNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="ac6dd418b895f9771feafb49bb0422a47"></a><!-- doxytag: member="Net::Device::open_channel" ref="ac6dd418b895f9771feafb49bb0422a47" args="(const std::string &amp;url)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>* Net::Device::open_channel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>url</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open a channel to a given url The method may return an existing opened channel to this node. The channel is not declared as a route to the node, it should be defined by calling add_route by the caller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>the url to the node on which to open channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>channel to the node or 0 if route cannot be open. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_net_1_1_device.html#a1fb173d97fdcb9b790afb31296ca5baf">close_channel</a> </dd></dl>

<p>Implemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#a372b701c949a34f6b43919ca401780d3">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#a79ab53b1b56fb28d25c42116154bd083">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a7dfc7b9f0d4e0a32e2b846510721a026">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a58a40de21b0c724f83830e9573c64756">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#ae823deb3ef4448da6e5db538b4f94267">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#a0f92bcd4b6072f03bb2fac03d859eb40">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="a8343ee00bc7177cfb55d8b0431bcd3d1"></a><!-- doxytag: member="Net::Device::register_factory" ref="a8343ee00bc7177cfb55d8b0431bcd3d1" args="(DeviceFactory *nf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Net::Device::register_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>nf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a name to a new network </p>

</div>
</div>
<a class="anchor" id="a185e0f4163761fac7a57c9b50e4c66b6"></a><!-- doxytag: member="Net::Device::release_callstack" ref="a185e0f4163761fac7a57c9b50e4c66b6" args="(CallStack *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::release_callstack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release a call context. The method releases the call context in the free list of call context iff no more reference has been acquired on the call context, i.e. iff the number of calls to <a class="el" href="class_net_1_1_call_stack.html#a4dc821e3eb58904fb27e90331fd2023f">CallStack::release</a> is equals to the number of calls to <a class="el" href="class_net_1_1_call_stack.html#ab406af5cb3aafd1da3ca8490621b3317">CallStack::acquire</a>. This method is not thread aware with respect to the network object : the caller should ensure that no multiple thread call it at the same time. </p>

</div>
</div>
<a class="anchor" id="a780be817fc0b70c5eb021ab2295bfbd1"></a><!-- doxytag: member="Net::Device::resolve_device" ref="a780be817fc0b70c5eb021ab2295bfbd1" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_net_1_1_device.html">Device</a>* Net::Device::resolve_device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resolv a created network </p>

</div>
</div>
<a class="anchor" id="a218578771d7461b26e9b4b591a6ea49f"></a><!-- doxytag: member="Net::Device::signal" ref="a218578771d7461b26e9b4b591a6ea49f" args="(ComFailure::Code error_no, OutChannel *ch, Header *header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_header.html">Header</a> *&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signal event to the upcall object associated with the device Override the definition of <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Upcall::signal</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_callback.html#a4700e876d0b4621c9d7f6f182394cc49">Net::Callback</a>.</p>

</div>
</div>
<a class="anchor" id="a3e958644b17afc9da9fce348871cb0e4"></a><!-- doxytag: member="Net::Device::signal" ref="a3e958644b17afc9da9fce348871cb0e4" args="(ComFailure::Code error_no, InChannel *ch, CallStack *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Device::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signal event to the upcall object associated with the device Override the definition of <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Upcall::signal</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Net::Upcall</a>.</p>

</div>
</div>
<a class="anchor" id="a2488452281b7c84b0a919ca39bb9c36c"></a><!-- doxytag: member="Net::Device::size_bloc" ref="a2488452281b7c84b0a919ca39bb9c36c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Net::Device::size_bloc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size in byte of a bloc </p>

</div>
</div>
<a class="anchor" id="a3dacb246262acc8a566cc5ef3078aff0"></a><!-- doxytag: member="Net::Device::terminate" ref="a3dacb246262acc8a566cc5ef3078aff0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate the device This function is automatically called at termination of the network. </p>

<p>Reimplemented from <a class="el" href="class_util_1_1_object.html#ac56dc69161e667fec85e1565509c08ac">Util::Object</a>.</p>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_device.html#a6754aeda4b1bfe5696d840378cd06a7a">FDNET::Device</a>, <a class="el" href="class_m_a_n_e_t_1_1_device.html#aa1735d84303b2b82cdd2d6b4fab26dc4">MANET::Device</a>, <a class="el" href="class_m_y_n_e_t_1_1_device.html#a5e2e799ee95ab2e20785d81429b21a9d">MYNET::Device</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_device.html#a6540a95a51e7d55e328cffc9ae925aeb">SOCKNET::Device</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_device.html#a1b88e17c8f523fea6090da73b7caacb1">TAKTUKNET::Device</a>, and <a class="el" href="class_u_d_p_n_e_t_1_1_device.html#aa779c8902982c2ec45d55c04f6e1d41d">UDPNET::Device</a>.</p>

</div>
</div>
<a class="anchor" id="a10285c49445e106cbf957a4ee3db0565"></a><!-- doxytag: member="Net::Device::umap_zone" ref="a10285c49445e106cbf957a4ee3db0565" args="(void *begin, size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Device::umap_zone </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">InvalidArgumentError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retract from network memory a part of user memory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>(IN) beginning address of the memory block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sz</em>&nbsp;</td><td>(IN) in bytes of the memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The zone is unmapped. At this level, no control of overlapping of mapping or multiples mapping of the same zone are done.. Default implantation do nothing </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8ab3cf206ea4374251e7da0f6a38fb67"></a><!-- doxytag: member="Net::Device::IODaemon" ref="a8ab3cf206ea4374251e7da0f6a38fb67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb1172fca541ea3cf6a9363dbbbad057"></a><!-- doxytag: member="Net::Device::IOInstructionStream" ref="acb1172fca541ea3cf6a9363dbbbad057" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a60cc78b54a2732e5c54cebc400c8dfe4"></a><!-- doxytag: member="Net::Device::_access_bloc_alloc" ref="a60cc78b54a2732e5c54cebc400c8dfe4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mutex <a class="el" href="class_net_1_1_device.html#a60cc78b54a2732e5c54cebc400c8dfe4">Net::Device::_access_bloc_alloc</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>to lock access to bloc allocator </p>

</div>
</div>
<a class="anchor" id="ac2e2ba85985d53714712a531021bb0b0"></a><!-- doxytag: member="Net::Device::_bloc_allocator" ref="ac2e2ba85985d53714712a531021bb0b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_byte_allocator.html">Util::ByteAllocator</a> <a class="el" href="class_net_1_1_device.html#ac2e2ba85985d53714712a531021bb0b0">Net::Device::_bloc_allocator</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>packet allocator for IA and IOVect entries </p>

</div>
</div>
<a class="anchor" id="afe7628a7f9d43ed2e31fa227bf2d3b07"></a><!-- doxytag: member="Net::Device::_bloc_size" ref="afe7628a7f9d43ed2e31fa227bf2d3b07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_net_1_1_device.html#afe7628a7f9d43ed2e31fa227bf2d3b07">Net::Device::_bloc_size</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>size of the packet </p>

</div>
</div>
<a class="anchor" id="af66ed700e5b8cf3fe6272f00801fc07a"></a><!-- doxytag: member="Net::Device::_factory" ref="af66ed700e5b8cf3fe6272f00801fc07a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device_factory.html">DeviceFactory</a>* <a class="el" href="class_net_1_1_device.html#af66ed700e5b8cf3fe6272f00801fc07a">Net::Device::_factory</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the factory of this device </p>

</div>
</div>
<a class="anchor" id="a58933d133fe315c3149858435557b1bd"></a><!-- doxytag: member="Net::Device::_listcc" ref="a58933d133fe315c3149858435557b1bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_stack_list.html">Util::StackList</a>&lt;<a class="el" href="class_net_1_1_call_stack.html">CallStack</a>&gt; <a class="el" href="class_net_1_1_device.html#a58933d133fe315c3149858435557b1bd">Net::Device::_listcc</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>free list of call stack </p>

</div>
</div>
<a class="anchor" id="aaad11dd111eb3b5024d1284c4cec71a7"></a><!-- doxytag: member="Net::Device::_name" ref="aaad11dd111eb3b5024d1284c4cec71a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_net_1_1_device.html#aaad11dd111eb3b5024d1284c4cec71a7">Net::Device::_name</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name of the device. </p>

</div>
</div>
<a class="anchor" id="af0fb9f9d2d9c8f30cd7551a88a405221"></a><!-- doxytag: member="Net::Device::_szlistcc" ref="af0fb9f9d2d9c8f30cd7551a88a405221" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_1_1_device.html#af0fb9f9d2d9c8f30cd7551a88a405221">Net::Device::_szlistcc</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>size of the entries in _listscc </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="network__device_8h.html">network_device.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:52:40 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

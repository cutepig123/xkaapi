<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Net::GlobalPointer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_net.html">Net</a>::<a class="el" href="class_net_1_1_global_pointer.html">GlobalPointer</a>
  </div>
</div>
<div class="contents">
<h1>Net::GlobalPointer Class Reference<br/>
<small>
[<a class="el" href="group___net.html">Net</a>]</small>
</h1><!-- doxytag: class="Net::GlobalPointer" --><!-- doxytag: inherits="Util::GlobalPointer" -->
<p><a class="el" href="class_net_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous...">GlobalPointer</a> is a pointer on data on a remote processThis class allows to mask heterogeneous representation of pointer (32/64bits) and is an opaque representation of a pointer of a remote process. Only the remote process may do indirection of the pointer.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;netdata_gp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Net::GlobalPointer:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_global_pointer__inherit__graph.png" border="0" usemap="#_net_1_1_global_pointer_inherit__map" alt="Inheritance graph"/></div>
<map name="_net_1_1_global_pointer_inherit__map" id="_net_1_1_global_pointer_inherit__map">
<area shape="rect" id="node2" href="class_util_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous..." alt="" coords="5,5,155,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Net::GlobalPointer:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_global_pointer__coll__graph.png" border="0" usemap="#_net_1_1_global_pointer_coll__map" alt="Collaboration graph"/></div>
<map name="_net_1_1_global_pointer_coll__map" id="_net_1_1_global_pointer_coll__map">
<area shape="rect" id="node2" href="class_util_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous..." alt="" coords="31,107,180,136"/><area shape="rect" id="node4" href="class_util_1_1_pointer.html" title="Util::Pointer" alt="" coords="5,8,109,37"/><area shape="rect" id="node6" href="class_util_1_1_global_id.html" title="Class for representing a global identifier of the distributed processusGlobal Identifier..." alt="" coords="133,8,245,37"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_net_1_1_global_pointer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_global_pointer.html#ae0d8374a1591996ebb84aa746ddacf81">write</a> (const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *f, const void *value, ka_uint32_t size, <a class="el" href="class_net_1_1_callback.html">Net::Callback</a> *cbk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_global_pointer.html#af7f16babfa50ad0dd8fa347670eb70d5">read</a> (const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *f, void *value, ka_uint32_t size, <a class="el" href="class_net_1_1_callback.html">Callback</a> *cbk_emit, <a class="el" href="class_net_1_1_upcall.html">Upcall</a> *upk_recv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_global_pointer.html#a37d60306a30b966206ee025694388f4a">swrite</a> (const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *f, const void *value, ka_uint32_t size, <a class="el" href="class_util_1_1_condition.html">Util::Condition</a> &amp;condition, <a class="el" href="class_util_1_1_mutex.html">Util::Mutex</a> &amp;mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_global_pointer.html#af49c6549de8f4ade814325f2d3f53c67">sread</a> (const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *f, void *data, ka_uint32_t size, <a class="el" href="class_util_1_1_condition.html">Util::Condition</a> &amp;condition, <a class="el" href="class_util_1_1_mutex.html">Util::Mutex</a> &amp;mutex)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_net_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous...">GlobalPointer</a> is a pointer on data on a remote process</p>
<p>This class allows to mask heterogeneous representation of pointer (32/64bits) and is an opaque representation of a pointer of a remote process. Only the remote process may do indirection of the pointer. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af7f16babfa50ad0dd8fa347670eb70d5"></a><!-- doxytag: member="Net::GlobalPointer::read" ref="af7f16babfa50ad0dd8fa347670eb70d5" args="(const Util::Format *f, void *value, ka_uint32_t size, Callback *cbk_emit, Upcall *upk_recv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::GlobalPointer::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ka_uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_callback.html">Callback</a> *&nbsp;</td>
          <td class="paramname"> <em>cbk_emit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_upcall.html">Upcall</a> *&nbsp;</td>
          <td class="paramname"> <em>upk_recv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value to the data pointed by the <a class="el" href="class_net_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous...">GlobalPointer</a> This operation may be a non blocking instruction if the the remote pointer points to data located onto an other process, then a communication will occur using active message of the communication library. This imply a two way communication protocol: First a message is send to request the data. Upon reception of the request, the remote process send an active message to write the data. The first communication is locally finish when the callback cbk_emit is notified. The second recv of the data is notify by the upcall upk_recv after the local data has been updated by the received data. If the globalpointer points to a local data, i.e. in the same address space, then the operation is synchronous: On return to the invocation the pointed data is updated with the value and the callback cbk_emit is notified before the upcall upk_recv. Error is returned during the notification of the callback and upcall. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>the format of data passed to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a local pointer where to store receivede data pointed by the global pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbk_emit</em>&nbsp;</td><td>the callback object that will be called when request has been sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>upk_recv</em>&nbsp;</td><td>the upcall object that will be called after the data has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af49c6549de8f4ade814325f2d3f53c67"></a><!-- doxytag: member="Net::GlobalPointer::sread" ref="af49c6549de8f4ade814325f2d3f53c67" args="(const Util::Format *f, void *data, ka_uint32_t size, Util::Condition &amp;condition, Util::Mutex &amp;mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> Net::GlobalPointer::sread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ka_uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_condition.html">Util::Condition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_mutex.html">Util::Mutex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronous version of asynchronous read Same as asynchronous read, except the caller is bloced until the communication to send request and received value is locally finish. The invocation return the error code that may occurs during the communication. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>the format of data passed to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>a local pointer where to store receivede data pointed by the global pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td>the Condition object that is used to signal the waiting caller </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>the Mutex object that should be lock and release if the caller should wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the error code of the communication </dd></dl>

</div>
</div>
<a class="anchor" id="a37d60306a30b966206ee025694388f4a"></a><!-- doxytag: member="Net::GlobalPointer::swrite" ref="a37d60306a30b966206ee025694388f4a" args="(const Util::Format *f, const void *value, ka_uint32_t size, Util::Condition &amp;condition, Util::Mutex &amp;mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> Net::GlobalPointer::swrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ka_uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_condition.html">Util::Condition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_mutex.html">Util::Mutex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronous version of asynchronous write Same as asynchronous write, except the caller is bloced until the communication to send value is locally finish. The invocation return the error code that may occurs during the communication. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>the format of data passed to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the pointer of the value to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td>the Condition object that is used to signal the waiting caller </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mutex</em>&nbsp;</td><td>the Mutex object that should be lock and release if the caller should wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the error code of the communication </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d8374a1591996ebb84aa746ddacf81"></a><!-- doxytag: member="Net::GlobalPointer::write" ref="ae0d8374a1591996ebb84aa746ddacf81" args="(const Util::Format *f, const void *value, ka_uint32_t size, Net::Callback *cbk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::GlobalPointer::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_format.html">Util::Format</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ka_uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_callback.html">Net::Callback</a> *&nbsp;</td>
          <td class="paramname"> <em>cbk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous write a value to the data pointed by the <a class="el" href="class_net_1_1_global_pointer.html" title="GlobalPointer is a pointer on data on a remote processThis class allows to mask heterogeneous...">GlobalPointer</a> This operation may be a non blocking instruction if the the remote pointer points to data located onto an other process, then a communication will occur using active message of the communication library. The communication is locally finish when the callback is notified. In case of the globalpointer points to a local data, i.e. in the same address space, then the operation is synchronous: On return to the invocation the pointed data is updated with the value. Error is returned during the notification of the callback. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>the format of data passed to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the pointer of the value to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbk</em>&nbsp;</td><td>the callback object that will be called when value could be locally reused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="netdata__gp_8h.html">netdata_gp.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:52:39 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

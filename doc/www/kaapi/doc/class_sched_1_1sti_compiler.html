<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Sched::stiCompiler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sched.html">Sched</a>::<a class="el" href="class_sched_1_1sti_compiler.html">stiCompiler</a>
  </div>
</div>
<div class="contents">
<h1>Sched::stiCompiler Class Reference<br/>
<small>
[<a class="el" href="group___graph.html">Graph</a>]</small>
</h1><!-- doxytag: class="Sched::stiCompiler" -->
<p>Groups some specific method to manipulate <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> and generate thread ready for executionThis class defined methods that allows to schedule a <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> on N ressources and generate code of thread for each ressource. This process is resumed in the next figure: 1/ the state of execution of a running thread is captured in order to access to its KAAPI' stack of execution; 2/ The KAAPI's stack is a <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> which is scheduled and, at the end the code for each thread is generated (the description of this process is given above); 3/ The execution of each thread generated by previous steps may be input for an other scheduling process.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;sched_compildfg.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Sched::stiCompiler:</div>
<div class="dynsection">
<div class="center"><img src="class_sched_1_1sti_compiler__coll__graph.png" border="0" usemap="#_sched_1_1sti_compiler_coll__map" alt="Collaboration graph"/></div>
<map name="_sched_1_1sti_compiler_coll__map" id="_sched_1_1sti_compiler_coll__map">
<area shape="rect" id="node2" href="class_d_f_g_1_1_thread.html" title="Flow of control with data flow graph representationThe DFG threads inherits from..." alt="" coords="2149,1400,2264,1429"/><area shape="rect" id="node4" href="class_r_f_o_1_1_thread.html" title="Flow of control with data flow graph representationThe RFO::Thread represents computation..." alt="" coords="1784,1399,1896,1428"/><area shape="rect" id="node6" href="class_core_1_1_thread.html" title="Flow of controlA Core::Thread is a flow of control which consist of its runtime environnement..." alt="" coords="867,591,981,620"/><area shape="rect" id="node37" href="class_core_1_1_processor.html" title="KAAPI ProcessorProcessor manages scheduling of a set of threads with at most one..." alt="" coords="1773,532,1907,561"/><area shape="rect" id="node71" href="class_core_1_1_thread_queue.html" title="ThreadQueue of threads." alt="" coords="1255,731,1417,760"/><area shape="rect" id="node75" href="class_core_1_1_thread_stack.html" title="ThreadStack of threadsLink using _next field of Core::Thread." alt="" coords="1259,784,1413,813"/><area shape="rect" id="node92" href="class_core_1_1_condition.html" title="Condition to signal end of steal operationThis class implements one method for synchronisation..." alt="" coords="1271,677,1401,707"/><area shape="rect" id="node8" href="class_util_1_1_thread.html" title="POSIX interface to thread." alt="" coords="481,493,588,523"/><area shape="rect" id="node10" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="51,367,165,396"/><area shape="rect" id="node13" href="class_util_1_1_key.html" title="Util::Key\&lt; ByteAllocator \&gt;" alt="" coords="7,449,209,479"/><area shape="rect" id="node15" href="class_util_1_1_key.html" title="Util::Key\&lt; Thread \&gt;" alt="" coords="27,503,189,532"/><area shape="rect" id="node17" href="class_util_1_1_o_event_stream.html" title="Output events stream: Util::OEventStream." alt="" coords="29,556,187,585"/><area shape="rect" id="node19" href="struct_util_1_1kaapi__atomic__t.html" title="Util::kaapi_atomic_t" alt="" coords="28,677,188,707"/><area shape="rect" id="node34" href="class_util_1_1_atomic.html" title="Atomic object represents atomic operation over integer.This class implements object..." alt="" coords="484,677,585,707"/><area shape="rect" id="node67" href="struct_core_1_1___spin_lock.html" title="Core::_SpinLock" alt="" coords="468,801,601,831"/><area shape="rect" id="node21" href="class_core_1_1_stealable_with_instance_reification.html" title="Interface for object that accepts steal request with instance reificationInstances..." alt="" coords="387,265,683,295"/><area shape="rect" id="node56" href="class_core_1_1_work_set.html" title="WorkSet of worksetThe workset is a set of processors with a steal interface to steal..." alt="" coords="2147,467,2267,496"/><area shape="rect" id="node23" href="class_core_1_1_stealable.html" title="Base interface for object that accepts steal request." alt="" coords="43,265,173,295"/><area shape="rect" id="node25" href="class_core_1_1_steal_algorithm.html" title="Base class to implement an algorithm for work stealingAll objects that inherit from..." alt="" coords="24,1001,192,1031"/><area shape="rect" id="node116" href="class_r_f_o_1_1_thread_steal_algorithm.html" title="StealAlgorithm of a RFO threadAn instance of this class is attached for all instance..." alt="" coords="1228,1277,1444,1307"/><area shape="rect" id="node27" href="class_util_1_1_interface_notify.html" title="InterfaceNotify for the local signal." alt="" coords="453,924,616,953"/><area shape="rect" id="node29" href="class_core_1_1_printable.html" title="Core::Printable" alt="" coords="471,600,599,629"/><area shape="rect" id="node126" href="class_sched_1_1_collection.html" title="Collection of distributed global data." alt="" coords="2135,1333,2279,1363"/><area shape="rect" id="node41" href="class_core_1_1_idleable_with_instance_reification.html" title="Interface for object that allows reification of idle_activity." alt="" coords="1192,953,1480,983"/><area shape="rect" id="node43" href="class_core_1_1_idleable.html" title="Interface for object that has idle_activity interface..." alt="" coords="863,1016,985,1045"/><area shape="rect" id="node46" href="class_util_1_1_interface_allocator.html" title="Util::InterfaceAllocator" alt="" coords="1245,263,1427,292"/><area shape="rect" id="node48" href="class_util_1_1_interface_deallocator.html" title="Util::InterfaceDeallocator" alt="" coords="1235,316,1437,345"/><area shape="rect" id="node51" href="class_util_1_1_callback_collect_counters.html" title="Callback function to collect countersThe class defines interface that should overloaded..." alt="" coords="1223,369,1449,399"/><area shape="rect" id="node54" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="1276,108,1396,137"/><area shape="rect" id="node61" href="class_util_1_1_counters.html" title="Counters generate by each gid and accumulated on the collector processSuch object..." alt="" coords="1277,1057,1395,1087"/><area shape="rect" id="node65" href="struct_core_1_1_spin_lock.html" title="Core::SpinLock" alt="" coords="861,872,987,901"/><area shape="rect" id="node98" href="class_r_f_o_1_1_stack_frame.html" title="Stack of frames (LIFO queue)." alt="" coords="1263,1513,1409,1543"/><area shape="rect" id="node81" href="class_util_1_1_key.html" title="Util::Key\&lt; Processor \&gt;" alt="" coords="1247,476,1425,505"/><area shape="rect" id="node83" href="class_util_1_1_byte_allocator.html" title="ByteAllocator of fixed size objects with cache for fast allocation (thread unsafe)A..." alt="" coords="1263,1337,1409,1367"/><area shape="rect" id="node130" href="class_r_f_o_1_1_stack_frame_with_allocator.html" title="Stack of frames with bloc allocator." alt="" coords="1721,1495,1959,1524"/><area shape="rect" id="node85" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; Bloc \&gt;" alt="" coords="836,1365,1012,1395"/><area shape="rect" id="node87" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; Bloc \&gt;" alt="" coords="448,1365,621,1395"/><area shape="rect" id="node90" href="class_util_1_1_stack_list.html" title="Thread linked list (thread unsafe)The StackList descriptor is linked to the top element..." alt="" coords="457,1419,612,1448"/><area shape="rect" id="node96" href="class_core_1_1_thread_format.html" title="Format for a Thread." alt="" coords="452,547,617,576"/><area shape="rect" id="node100" href="class_r_f_o_1_1_stack_mem.html" title="Stack memory allocatorStackMem object allows a stack allocation of bytes." alt="" coords="467,1608,603,1637"/><area shape="rect" id="node104" href="class_r_f_o_1_1_frame.html" title="Frame is a list of ordered closure.The frame correspond to an activation frame associated..." alt="" coords="871,1513,977,1543"/><area shape="rect" id="node108" href="class_r_f_o_1_1_closure.html" title="A closure object is a call to a function. It is also called task.Closure of type..." alt="" coords="477,1513,592,1543"/><area shape="rect" id="node111" href="class_r_f_o_1_1_dotifiable.html" title="The Dotifiable class defines interfaces to dump a dot graph representation of the..." alt="" coords="1272,1391,1400,1420"/><area shape="rect" id="node120" href="class_d_f_g_1_1_thread_steal_algorithm.html" title="StealAlgorithm of a RFO threadAn instance of this class is attached for all instance..." alt="" coords="1732,1345,1948,1375"/><area shape="rect" id="node134" href="class_sched_1_1_logical_collection.html" title="LogicalCollection represents mapping of objects onto a partition set." alt="" coords="2109,1675,2304,1704"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_sched_1_1sti_compiler-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a02fe70438b0e93b295dc94a68239305c">stiCompiler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a0296cea832787de594dd2e33b9d61785">~stiCompiler</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scheduling the graph</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1d6852bd6a9b47de9a374c15973d47c6"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a8fb87b404652b00f5e13a70638c567b9">schedule</a> (<a class="el" href="class_sched_1_1_scheduler.html">Scheduler</a> *pSched, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *pFrame, unsigned int Ninput, <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;realPart, std::map&lt; <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a>, <a class="el" href="class_r_f_o_1_1_site.html">Site</a> &gt; &amp;fixed_sites)  throw ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitioning a scheduled graph</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5de1d4b465a7829b558a32064c9d893a"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a14690ed09b6fd8b6f2a29eee919e99de">partition</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;set, unsigned int Nframes, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> **array_of_frames, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids)  throw ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mergin a partitionned graph</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp56f163722fa1d62ecd533b120658a296"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#abc67d7561758f5fa64786487db454318">merge</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *array_of_frames, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame)  throw ()</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">driving compilation process</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdee8d3381d7f4bb45ac5c09caf53e5ac"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a9045cf5e85769c43f74f8f1162871f21">compile</a> (<a class="el" href="class_sched_1_1_thread_group.html">ThreadGroup</a> *threadgroup, int npart, <a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a> *input_thread, int &amp;count_threads, int niter, <a class="el" href="struct_sched_1_1_partition_task.html">PartitionTask</a> *part_clo)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a6b86eac44808d8a6c601460f106cdcb8">ComputeFA</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *pFrame)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#af0701ce0c5a071c7b9d2c36bdf0e2ce7">DetectReaders</a> (<a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;pAccess, <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;ReaderSet, <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;ReaderSetLocal, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;ProcSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a14b0677eac4f3a1628bf18037bb354f1">CreateBroadcast</a> (const <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;mapMasterSite, <a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;lastOther, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;ReaderSet, <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;ReaderSetLocal, <a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a> *gd, <a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *pNextW, bool isMaster, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a821b50989855908b1553f5a3096ea9fb">CreateReduce</a> (<a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> masterPart, <a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;lastOther, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;sCWriter, <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;sCWriterLocal, <a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a> *gd, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#acbc6a87f30923b8b206efc5fda504c24">ManageCW</a> (<a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;pAccess, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;procSet, <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;outMasterSite, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#aa7daf94cfe92c9c13b90ff24e36cf365">ManageW</a> (const <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;masterSite, <a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;pAccess, const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;procSet, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a0ca866ec9b572ce698c4aa280aa1560b">fill_collection</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a0104cde2a5be964e525c018aac87e845">init_all_shared_flat</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a3334932e6e8f6531326095ad68b0d7d5">fill_logicalcollection</a> (<a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#ac4419e9c8b25342c69f8d4ee0ac0490e">insert_data_in_collection</a> (<a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *access, <a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;col, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a597db2031d17b9aac02a6b4c516a0064">insert_readers</a> (<a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *a, <a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;col, <a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_collection.html">Collection</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#ad4d6f520b499cfc3159ce98f19d8de00">get_collection_out0</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a57f2c8c1faacb0ae4782897b170d8412">get_collection_in</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a7dc2054dd5872739c2eb8b71dcd64499">get_collection_out</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a7b5ef3d05d3a8baba100e5be8f5716bb">Noutput</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of partition returned by the scheduler.  <a href="#a7b5ef3d05d3a8baba100e5be8f5716bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_f_o_1_1_stack_frame_with_allocator.html">RFO::StackFrameWithAllocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a5ec376e1e685b4dd796bec963ff07a4d">tmpStack</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary stack storage.  <a href="#a5ec376e1e685b4dd796bec963ff07a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a> <br class="typebreak"/>
*, <a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a4e70e328f32981b2af1332d1e32dee81">mFirstAccess</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of initial accesses.  <a href="#a4e70e328f32981b2af1332d1e32dee81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#aa36c0b06d1423fcfe66101ca8270fd36">tagcom</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag for communication.  <a href="#aa36c0b06d1423fcfe66101ca8270fd36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_r_f_o_1_1_closure.html">RFO::Closure</a> <br class="typebreak"/>
*, <a class="el" href="class_r_f_o_1_1_closure.html">RFO::Closure</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a2c4c8a92d739097838a9e85429dcb358">mPredRFO</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a closure, return the previous closure in <a class="el" href="namespace_r_f_o.html" title="Basic class to allows the definition of reference order execution.">RFO</a>.  <a href="#a2c4c8a92d739097838a9e85429dcb358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a362a74315518470ef945244859c28a42">pcurth</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The current thread that is being processed.  <a href="#a362a74315518470ef945244859c28a42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_collection.html">Collection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#ab6b1b9b32606fc5e9ac30e57c7b8a70f">_output0_collection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the first read versions (globaldata of all_shared that are read).  <a href="#ab6b1b9b32606fc5e9ac30e57c7b8a70f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a0cc7211f8a75baaf17b88aaa3f3fa463">_input_collection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the first read versions for kernel loop.  <a href="#a0cc7211f8a75baaf17b88aaa3f3fa463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#acbfe314a5c727e29e401a708de521ec9">_output_collection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the last write versions for kernel loop.  <a href="#acbfe314a5c727e29e401a708de521ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sched_1_1_thread_group.html#ae3a61a6e323ac8c3142eaf8dfc6b821e">ThreadGroup::Id</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a76df9afd24ca8566e470244234cdea86">_tgid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sched_1_1_thread_group.html" title="Local view of Group of Sched::ThreadSuch object exists on each site where a ThreadGroup...">ThreadGroup</a> id it is working on.  <a href="#a76df9afd24ca8566e470244234cdea86"></a><br/></td></tr>
<tr><td colspan="2"><h2>Basic methods</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp9b9a169d6b388243eb6a50772b0a95e1"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#ae96f1f78ad81b8e29da13026ec334121">initialize</a> (<a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a> *pth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#ab960b8d8d318c77b35c69344a817e17c">terminate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#aa2cd40e7cba07fad659669ff11c5d09d">flatten_stack</a> (<a class="el" href="class_r_f_o_1_1_stack_frame.html">RFO::StackFrame</a> *pStack, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *pFrame)  throw (Util::InvalidArgumentError)</td></tr>
<tr><td colspan="2"><h2>Back-End methods</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb7869d72d4ff346b64d5eeb4661e671a"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a32e810226d749027dc836ede9083286b">apply</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *outputFrame, <a class="el" href="class_sched_1_1_optimizer.html">Optimizer</a> *optimizer)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a85ce5c51041676a268e29083a2756bf5">generate</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *inputFrame, <a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *pFrame, <a class="el" href="class_sched_1_1_thread.html">Thread</a> *pThread)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a773ceba0218a2ade5863a20bed785bad">generate_main</a> (<a class="el" href="class_sched_1_1_thread_group.html">ThreadGroup</a> *threadgroup)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sched_1_1sti_compiler.html#a7cb6128cda990c964a4dd7f86bcc8374">buildchains</a> (<a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *ioFrame)  throw ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Groups some specific method to manipulate <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> and generate thread ready for execution</p>
<p>This class defined methods that allows to schedule a <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> on N ressources and generate code of thread for each ressource. This process is resumed in the next figure: 1/ the state of execution of a running thread is captured in order to access to its KAAPI' stack of execution; 2/ The KAAPI's stack is a <a class="el" href="namespace_d_f_g.html" title="Basic class to allows the definition of the data flow graph.">DFG</a> which is scheduled and, at the end the code for each thread is generated (the description of this process is given above); 3/ The execution of each thread generated by previous steps may be input for an other scheduling process. </p>
<div align="center">
<img src="inline_dotgraph_5.dot.png" alt="inline_dotgraph_5.dot" border="0" usemap="#inline_dotgraph_5.dot.map">
<map name="inline_dotgraph_5.dot.map" id="inline_dotgraph_5.dot.map"></map>
</div>
<p>Useful when using static scheduling. Basically, it implements scheduling alogrithms in order to affect site to tasks. It also implements some methods to generate communication tasks between clusters of tasks and makes some optimisations on the resulted graph structure. This class implements basic function to manipulate a program in order to generate the code to be executed on multiple thread. The flowsheet of these methods is: </p>
<div align="center">
<img src="inline_dotgraph_6.dot.png" alt="inline_dotgraph_6.dot" border="0" usemap="#inline_dotgraph_6.dot.map">
<map name="inline_dotgraph_6.dot.map" id="inline_dotgraph_6.dot.map"></map>
</div>
<p>An example of using the interface is the following: </p>
<div class="fragment"><pre class="fragment">     Graph compiler;
     Thread* thread_to_partition = ...;
     Frame <a class="code" href="class_sched_1_1sti_compiler.html#aa2cd40e7cba07fad659669ff11c5d09d">flatten_stack</a>;

     <span class="comment">// linearize the recursive structure of stack in &#39;thread_to_partition&#39;</span>
     <span class="comment">// After the return to the method, the previous stack pointed by &#39;thread_to_partition&#39;</span>
     <span class="comment">// is incorrect: links between closures have changed and the entry point in the data flow</span>
     <span class="comment">// graph through thread_to_partition is invalid and should never be used again.</span>
     compiler.flatten_stack( thread_to_partition, &amp;flatten_stack );
     
     <span class="comment">// Partition into 2 using the scheduler DSC.</span>
     <span class="comment">// On return, the closure have be set to </span>
     Scheduler* sched_dsc = ...;
     <span class="keywordtype">int</span> npartitions = compiler.schedule( sched_dsc, &amp;flatten_stack, 3);
     
     <span class="comment">// </span>
</pre></div> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02fe70438b0e93b295dc94a68239305c"></a><!-- doxytag: member="Sched::stiCompiler::stiCompiler" ref="a02fe70438b0e93b295dc94a68239305c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sched::stiCompiler::stiCompiler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor Do nothing, the user should invoke initialize </p>

</div>
</div>
<a class="anchor" id="a0296cea832787de594dd2e33b9d61785"></a><!-- doxytag: member="Sched::stiCompiler::~stiCompiler" ref="a0296cea832787de594dd2e33b9d61785" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sched::stiCompiler::~stiCompiler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default destructor Do nothing, the user should invoke terminate </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a32e810226d749027dc836ede9083286b"></a><!-- doxytag: member="Sched::stiCompiler::apply" ref="a32e810226d749027dc836ede9083286b" args="(RFO::Frame *inputFrame, RFO::Frame *outputFrame, Optimizer *optimizer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>outputFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_optimizer.html">Optimizer</a> *&nbsp;</td>
          <td class="paramname"> <em>optimizer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an optimizer object to the graph The optimizer should be an object which inherits from <a class="el" href="class_sched_1_1_optimizer.html" title="Optmizer interface.">Optimizer</a> and redefined the virtual method optimize(). See <a class="el" href="class_sched_1_1_optimizer.html">Optimizer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputFrame</em>&nbsp;</td><td>the list of closures to optimize </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outputFrame</em>&nbsp;</td><td>the optimized closures </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>NOT YET IMPLEMENTED </dd></dl>

</div>
</div>
<a class="anchor" id="a7cb6128cda990c964a4dd7f86bcc8374"></a><!-- doxytag: member="Sched::stiCompiler::buildchains" ref="a7cb6128cda990c964a4dd7f86bcc8374" args="(RFO::Frame *ioFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Sched::stiCompiler::buildchains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>ioFrame</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update chains of accesses from a list of closures This method is used to restore, for each global data, the chain between accesses to it. It is used at the end of generate to restore the chains of accesses after having copied closures. It could be used by optimizer if the data flow structure is incompleted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ioFrame</em>&nbsp;</td><td>The list of closures to convert into frame </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9045cf5e85769c43f74f8f1162871f21"></a><!-- doxytag: member="Sched::stiCompiler::compile" ref="a9045cf5e85769c43f74f8f1162871f21" args="(ThreadGroup *threadgroup, int npart, DFG::Thread *input_thread, int &amp;count_threads, int niter, PartitionTask *part_clo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Sched::stiCompiler::compile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_thread_group.html">ThreadGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>threadgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>npart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a> *&nbsp;</td>
          <td class="paramname"> <em>input_thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>count_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>niter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sched_1_1_partition_task.html">PartitionTask</a> *&nbsp;</td>
          <td class="paramname"> <em>part_clo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compile the thread with a static scheduling approach This method drives the whole compilation of the top frame of a thread. The output is a set of thread attached to the same parent workset as the input thread. The array of pointer threads is allocated by the function call and should be released by the user. The method returns the thread group that contains all informations required to manage execution and distribute the workload. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>npart</em>&nbsp;</td><td>is the request number of partitions </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>input_thread</em>&nbsp;</td><td>is the input thread to partition in npart </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>count_threads</em>&nbsp;</td><td>is the number of computed partition </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>threads</em>&nbsp;</td><td>is the pointer to the array of partition (thread) computed </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>thread group </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b86eac44808d8a6c601460f106cdcb8"></a><!-- doxytag: member="Sched::stiCompiler::ComputeFA" ref="a6b86eac44808d8a6c601460f106cdcb8" args="(RFO::Frame *pFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::ComputeFA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the initial access for the all chains of accesses. This method is used by partition to compute the chains of accesses. For iterative simulation, find readers which needs data from i-1 step </p>

</div>
</div>
<a class="anchor" id="a14b0677eac4f3a1628bf18037bb354f1"></a><!-- doxytag: member="Sched::stiCompiler::CreateBroadcast" ref="a14b0677eac4f3a1628bf18037bb354f1" args="(const Partition &amp;mapMasterSite, DFG::Access *&amp;lastOther, const PartitionSet &amp;ReaderSet, PartitionSet &amp;ReaderSetLocal, DFG::GlobalData *gd, DFG::Access *pNextW, bool isMaster, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::CreateBroadcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mapMasterSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>lastOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ReaderSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ReaderSetLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a> *&nbsp;</td>
          <td class="paramname"> <em>gd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&nbsp;</td>
          <td class="paramname"> <em>pNextW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isMaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a821b50989855908b1553f5a3096ea9fb"></a><!-- doxytag: member="Sched::stiCompiler::CreateReduce" ref="a821b50989855908b1553f5a3096ea9fb" args="(Partition masterPart, DFG::Access *&amp;lastOther, const PartitionSet &amp;sCWriter, PartitionSet &amp;sCWriterLocal, DFG::GlobalData *gd, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::CreateReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_partition.html">Partition</a>&nbsp;</td>
          <td class="paramname"> <em>masterPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>lastOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sCWriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sCWriterLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a> *&nbsp;</td>
          <td class="paramname"> <em>gd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create <a class="el" href="struct_sched_1_1_reduce_task.html">ReduceTask</a> For all partitions in sCWriterLocal in order to send partial result to site masterSite. The task is added after access prev in the reference order. </p>

</div>
</div>
<a class="anchor" id="af0701ce0c5a071c7b9d2c36bdf0e2ce7"></a><!-- doxytag: member="Sched::stiCompiler::DetectReaders" ref="af0701ce0c5a071c7b9d2c36bdf0e2ce7" args="(DFG::Access *&amp;pAccess, PartitionSet &amp;ReaderSet, PartitionSet &amp;ReaderSetLocal, const PartitionSet &amp;ProcSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sched::stiCompiler::DetectReaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>pAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ReaderSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ReaderSetLocal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ProcSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DetectReaders The method is called to detect the reader's set. The input value of pAccess should points to the first access after a writer. This could be an r or rw mode of accesses. The output value points to past the last detected reader which is considered to the next writer. </p>

</div>
</div>
<a class="anchor" id="a0ca866ec9b572ce698c4aa280aa1560b"></a><!-- doxytag: member="Sched::stiCompiler::fill_collection" ref="a0ca866ec9b572ce698c4aa280aa1560b" args="(RFO::Frame *inputFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::fill_collection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the _output0_collection. (old init_all_shared) </p>

</div>
</div>
<a class="anchor" id="a3334932e6e8f6531326095ad68b0d7d5"></a><!-- doxytag: member="Sched::stiCompiler::fill_logicalcollection" ref="a3334932e6e8f6531326095ad68b0d7d5" args="(Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::fill_logicalcollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill (respectively) _input_collection and _output_collection with GlobalDatas:</p>
<ul>
<li>that have a GlobalData::Id (it means not local)</li>
<li>and that are (respectively) first readers or last writers </li>
</ul>

</div>
</div>
<a class="anchor" id="aa2cd40e7cba07fad659669ff11c5d09d"></a><!-- doxytag: member="Sched::stiCompiler::flatten_stack" ref="aa2cd40e7cba07fad659669ff11c5d09d" args="(RFO::StackFrame *pStack, RFO::Frame *pFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Sched::stiCompiler::flatten_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_stack_frame.html">RFO::StackFrame</a> *&nbsp;</td>
          <td class="paramname"> <em>pStack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (<a class="el" href="class_util_1_1_invalid_argument_error.html">Util::InvalidArgumentError</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flattens the stack into a frame. This method flattens the input stack into a frame preserving the reference order. The output frame may be empty, if the stack is empty </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pStack</em>&nbsp;</td><td>The stack that has to be flattened </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pFrame</em>&nbsp;</td><td>the frame where to store the flattened stack, should be allocated by the caller </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_util_1_1_invalid_argument_error.html">Util::InvalidArgumentError</a></em>&nbsp;</td><td>if some effective parameters are nul pointers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85ce5c51041676a268e29083a2756bf5"></a><!-- doxytag: member="Sched::stiCompiler::generate" ref="a85ce5c51041676a268e29083a2756bf5" args="(RFO::Frame *inputFrame, RFO::Frame *pFrame, Thread *pThread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_thread.html">Thread</a> *&nbsp;</td>
          <td class="paramname"> <em>pThread</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy a list of closures from a frame to a frame using a stack allocator This method allows to get back a frame from a list of closures. Once all of the process had made on the graph, we can re-convert the list into a frame in order to run it. This method recopies closures and access of the data flow graph into a compact representation. The newly generated graph will stored into a new frame pushed into the stack. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputFrame</em>&nbsp;</td><td>The list of closures to convert into frame </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pFrame</em>&nbsp;</td><td>The frame where closures are stored </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pThread</em>&nbsp;</td><td>The <a class="el" href="class_sched_1_1_thread.html" title="Flow of control with data flow graph representation.">Sched::Thread</a> used for allocation </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a773ceba0218a2ade5863a20bed785bad"></a><!-- doxytag: member="Sched::stiCompiler::generate_main" ref="a773ceba0218a2ade5863a20bed785bad" args="(ThreadGroup *threadgroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::generate_main </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_thread_group.html">ThreadGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>threadgroup</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57f2c8c1faacb0ae4782897b170d8412"></a><!-- doxytag: member="Sched::stiCompiler::get_collection_in" ref="a57f2c8c1faacb0ae4782897b170d8412" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp; Sched::stiCompiler::get_collection_in </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get back the logical collection of the first read versions The logical collection reference the mapping of threads that reclaims data on the corresponding partition </p>

</div>
</div>
<a class="anchor" id="a7dc2054dd5872739c2eb8b71dcd64499"></a><!-- doxytag: member="Sched::stiCompiler::get_collection_out" ref="a7dc2054dd5872739c2eb8b71dcd64499" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp; Sched::stiCompiler::get_collection_out </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get back the collection of the last write versions The logical collection reference the mapping of threads that write data on the corresponding partition </p>

</div>
</div>
<a class="anchor" id="ad4d6f520b499cfc3159ce98f19d8de00"></a><!-- doxytag: member="Sched::stiCompiler::get_collection_out0" ref="ad4d6f520b499cfc3159ce98f19d8de00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_collection.html">Collection</a> &amp; Sched::stiCompiler::get_collection_out0 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get back the collection of the first read versions </p>

</div>
</div>
<a class="anchor" id="a0104cde2a5be964e525c018aac87e845"></a><!-- doxytag: member="Sched::stiCompiler::init_all_shared_flat" ref="a0104cde2a5be964e525c018aac87e845" args="(RFO::Frame *inputFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::init_all_shared_flat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign Id to GlobalData from parameters (if needed) and fill all_shared table. It also fill the _output0_collection. It assumes that there is no local Shared </p>

</div>
</div>
<a class="anchor" id="ae96f1f78ad81b8e29da13026ec334121"></a><!-- doxytag: member="Sched::stiCompiler::initialize" ref="ae96f1f78ad81b8e29da13026ec334121" args="(DFG::Thread *pth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a> *&nbsp;</td>
          <td class="paramname"> <em>pth</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to initialize private member when calling partition This method should be invoked in order to initialize the object before any call to other methods. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pth</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4419e9c8b25342c69f8d4ee0ac0490e"></a><!-- doxytag: member="Sched::stiCompiler::insert_data_in_collection" ref="ac4419e9c8b25342c69f8d4ee0ac0490e" args="(DFG::Access *access, LogicalCollection &amp;col, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::insert_data_in_collection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&nbsp;</td>
          <td class="paramname"> <em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert data associated to access to the <a class="el" href="class_sched_1_1_logical_collection.html" title="LogicalCollection represents mapping of objects onto a partition set.">LogicalCollection</a> col according to the partition of its closure. </p>

</div>
</div>
<a class="anchor" id="a597db2031d17b9aac02a6b4c516a0064"></a><!-- doxytag: member="Sched::stiCompiler::insert_readers" ref="a597db2031d17b9aac02a6b4c516a0064" args="(DFG::Access *a, LogicalCollection &amp;col, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::insert_readers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert in <a class="el" href="class_sched_1_1_logical_collection.html" title="LogicalCollection represents mapping of objects onto a partition set.">LogicalCollection</a> col all sites of accesses that read the same version that Access a reads. </p>

</div>
</div>
<a class="anchor" id="acbc6a87f30923b8b206efc5fda504c24"></a><!-- doxytag: member="Sched::stiCompiler::ManageCW" ref="acbc6a87f30923b8b206efc5fda504c24" args="(DFG::Access *&amp;pAccess, const PartitionSet &amp;procSet, Partition &amp;outMasterSite, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::ManageCW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>pAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>procSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outMasterSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A COMMENTER SUR L'AVANCEMENT DES ACCESS Generate reduction of cw access. Add tasks after the last cw of the chain of accesses. The input value of pAccess should points onto the first cw of the chain of accesses. The output value of pAccess points to the last access of the cw or the may be added reduce task: the next access of pAccess is either 0 or a r or rw or w access. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pAccess</em>&nbsp;</td><td>[in,out] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>procSet</em>&nbsp;</td><td>[in] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outMasterSite</em>&nbsp;</td><td>[out] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7daf94cfe92c9c13b90ff24e36cf365"></a><!-- doxytag: member="Sched::stiCompiler::ManageW" ref="aa7daf94cfe92c9c13b90ff24e36cf365" args="(const Partition &amp;masterSite, DFG::Access *&amp;pAccess, const PartitionSet &amp;procSet, Core::ContextId *tcids, std::map&lt; int, int &gt; &amp;rmap_partid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::ManageW </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>masterSite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>pAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>procSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rmap_partid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A COMMENTER SUR L'AVANCEMENT DES ACCESS The input value of pAccess should points to the last writer (cw, w, rw) of the chain of accesses. The method generates tasks to broadcast the data from masterSite to the consumers: the tasks are added after the tasks associated to the input value of pAccess. The output value of pAccess is the next writer of the chain of accesses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>masterSite</em>&nbsp;</td><td>[in] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pAccess</em>&nbsp;</td><td>[in,out] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>procSet</em>&nbsp;</td><td>[in] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc67d7561758f5fa64786487db454318"></a><!-- doxytag: member="Sched::stiCompiler::merge" ref="abc67d7561758f5fa64786487db454318" args="(RFO::Frame *array_of_frames, RFO::Frame *inputFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>array_of_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merge a set of frames into a unique frame. </p>
<div align="center">
<img src="inline_dotgraph_7.dot.png" alt="inline_dotgraph_7.dot" border="0" usemap="#inline_dotgraph_7.dot.map">
<map name="inline_dotgraph_7.dot.map" id="inline_dotgraph_7.dot.map"></map>
</div>
 <div class="fragment"><pre class="fragment"></pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>array_of_frames</em>&nbsp;</td><td>the array of frames of closures that will be produced containing closures from set </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>inputFrame</em>&nbsp;</td><td>The input list from which the sets of closures has to be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>NOT YET IMPLEMENTED </dd></dl>

</div>
</div>
<a class="anchor" id="a14690ed09b6fd8b6f2a29eee919e99de"></a><!-- doxytag: member="Sched::stiCompiler::partition" ref="a14690ed09b6fd8b6f2a29eee919e99de" args="(RFO::Frame *inputFrame, const PartitionSet &amp;set, unsigned int Nframes, RFO::Frame **array_of_frames, Core::ContextId *tcids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>inputFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>Nframes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> **&nbsp;</td>
          <td class="paramname"> <em>array_of_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_context_id.html">Core::ContextId</a> *&nbsp;</td>
          <td class="paramname"> <em>tcids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates some closures sets from the input list of closures creating communication task for each set. This method generates 'set.size()' clusters of closures from the input list by creating communication tasks needed to realize communications on these sets. Exceptions will be produced if the input list is empty or if the processors set is not correct or if one of the cluster to generate is empty. It has to be noticed that the input and ouput lists are chained following the reference order. This method doesn't create communication tasks for the others sets which are not included in the input set parameter. For example: Considering the following graph (a) (execution site are presented between []): </p>
<div align="center">
<img src="inline_dotgraph_8.dot.png" alt="inline_dotgraph_8.dot" border="0" usemap="#inline_dotgraph_8.dot.map">
<map name="inline_dotgraph_8.dot.map" id="inline_dotgraph_8.dot.map"></map>
</div>
<p>And considering that one wants to generate the processors set {5, 6}. It means that 2 output lists will be produced: one corresponding to the set of closures which are elements of 5 (b) and another set of closures which are elements of 6 (c).</p>
<p>For instance the following code generate clusters using a remap function: </p>
<div class="fragment"><pre class="fragment">        Site my_rempfunc( Site i)
        {
          <span class="keywordflow">return</span> (i % 2 == 0 ? 0 : 1)
        }
        ...
        Frame* frame_partition[2];
        frame_partition[0] = ...; <span class="comment">// select one frame into existing thread</span>
        frame_partition[1] = ...; <span class="comment">// select one frame into existing thread</span>
        graph.partition( inputFrame, myset_after_remp, myframe &amp;my_rempfunc );
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputFrame</em>&nbsp;</td><td>The input list from which the sets of closures has to be generated. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>set</em>&nbsp;</td><td>Processors set from which closures have to be extracted </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Nframes</em>&nbsp;</td><td>the number of array_of_frames </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>array_of_frames</em>&nbsp;</td><td>the array of frames of closures that will be produced containing closures from set </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fb87b404652b00f5e13a70638c567b9"></a><!-- doxytag: member="Sched::stiCompiler::schedule" ref="a8fb87b404652b00f5e13a70638c567b9" args="(Scheduler *pSched, RFO::Frame *pFrame, unsigned int Ninput, PartitionSet &amp;realPart, std::map&lt; Partition, Site &gt; &amp;fixed_sites)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Sched::stiCompiler::schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_scheduler.html">Scheduler</a> *&nbsp;</td>
          <td class="paramname"> <em>pSched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_f_o_1_1_frame.html">RFO::Frame</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>Ninput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sched_1_1_partition_set.html">PartitionSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>realPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_r_f_o_1_1_partition.html">Partition</a>, <a class="el" href="class_r_f_o_1_1_site.html">Site</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fixed_sites</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedules the frame, i.e., affects sites to closures following the number of available processors. This method tries to schedule the Frame aFrame using a particular scheduler pSched on a set of iProc processors. if the number of processors that has to be used is equal to 0, it raises an exception. It takes into account the special ocr attribute that specify that a task has to be scheduled on a particular site. Be careful, this might slant the scheduling. On return to the invocation, the site of un-assigned closures are initialized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pSched</em>&nbsp;</td><td>The scheduler to use: some information might be updated inside </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pFrame</em>&nbsp;</td><td>The frame which has to be schedule. Each closure of the frame aFrame is assigned to a site (from 1 to iProc) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Ninput</em>&nbsp;</td><td>Number of available processors: must be a positive value </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>realPart</em>&nbsp;</td><td>because partitions can be added or deleted, partiton numbering may be not contiguous. This map return the partition_id for each element between 0..number_of_partitions </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Number</em>&nbsp;</td><td>of clusters procuded by the scheduler </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>No</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab960b8d8d318c77b35c69344a817e17c"></a><!-- doxytag: member="Sched::stiCompiler::terminate" ref="ab960b8d8d318c77b35c69344a817e17c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sched::stiCompiler::terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to terminate the object </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0cc7211f8a75baaf17b88aaa3f3fa463"></a><!-- doxytag: member="Sched::stiCompiler::_input_collection" ref="a0cc7211f8a75baaf17b88aaa3f3fa463" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> <a class="el" href="class_sched_1_1sti_compiler.html#a0cc7211f8a75baaf17b88aaa3f3fa463">Sched::stiCompiler::_input_collection</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the first read versions for kernel loop. </p>

</div>
</div>
<a class="anchor" id="ab6b1b9b32606fc5e9ac30e57c7b8a70f"></a><!-- doxytag: member="Sched::stiCompiler::_output0_collection" ref="ab6b1b9b32606fc5e9ac30e57c7b8a70f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_collection.html">Collection</a> <a class="el" href="class_sched_1_1sti_compiler.html#ab6b1b9b32606fc5e9ac30e57c7b8a70f">Sched::stiCompiler::_output0_collection</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the first read versions (globaldata of all_shared that are read). </p>

</div>
</div>
<a class="anchor" id="acbfe314a5c727e29e401a708de521ec9"></a><!-- doxytag: member="Sched::stiCompiler::_output_collection" ref="acbfe314a5c727e29e401a708de521ec9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_logical_collection.html">LogicalCollection</a> <a class="el" href="class_sched_1_1sti_compiler.html#acbfe314a5c727e29e401a708de521ec9">Sched::stiCompiler::_output_collection</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_sched_1_1_collection.html" title="Collection of distributed global data.">Collection</a> of the last write versions for kernel loop. </p>

</div>
</div>
<a class="anchor" id="a76df9afd24ca8566e470244234cdea86"></a><!-- doxytag: member="Sched::stiCompiler::_tgid" ref="a76df9afd24ca8566e470244234cdea86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sched_1_1_thread_group.html#ae3a61a6e323ac8c3142eaf8dfc6b821e">ThreadGroup::Id</a> <a class="el" href="class_sched_1_1sti_compiler.html#a76df9afd24ca8566e470244234cdea86">Sched::stiCompiler::_tgid</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_sched_1_1_thread_group.html" title="Local view of Group of Sched::ThreadSuch object exists on each site where a ThreadGroup...">ThreadGroup</a> id it is working on. </p>

</div>
</div>
<a class="anchor" id="a4e70e328f32981b2af1332d1e32dee81"></a><!-- doxytag: member="Sched::stiCompiler::mFirstAccess" ref="a4e70e328f32981b2af1332d1e32dee81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_d_f_g_1_1_global_data.html">DFG::GlobalData</a>*,<a class="el" href="class_d_f_g_1_1_access.html">DFG::Access</a>*&gt; <a class="el" href="class_sched_1_1sti_compiler.html#a4e70e328f32981b2af1332d1e32dee81">Sched::stiCompiler::mFirstAccess</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set of initial accesses. </p>

</div>
</div>
<a class="anchor" id="a2c4c8a92d739097838a9e85429dcb358"></a><!-- doxytag: member="Sched::stiCompiler::mPredRFO" ref="a2c4c8a92d739097838a9e85429dcb358" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_r_f_o_1_1_closure.html">RFO::Closure</a>*, <a class="el" href="class_r_f_o_1_1_closure.html">RFO::Closure</a>*&gt; <a class="el" href="class_sched_1_1sti_compiler.html#a2c4c8a92d739097838a9e85429dcb358">Sched::stiCompiler::mPredRFO</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a closure, return the previous closure in <a class="el" href="namespace_r_f_o.html" title="Basic class to allows the definition of reference order execution.">RFO</a>. </p>

</div>
</div>
<a class="anchor" id="a7b5ef3d05d3a8baba100e5be8f5716bb"></a><!-- doxytag: member="Sched::stiCompiler::Noutput" ref="a7b5ef3d05d3a8baba100e5be8f5716bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sched_1_1sti_compiler.html#a7b5ef3d05d3a8baba100e5be8f5716bb">Sched::stiCompiler::Noutput</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of partition returned by the scheduler. </p>

</div>
</div>
<a class="anchor" id="a362a74315518470ef945244859c28a42"></a><!-- doxytag: member="Sched::stiCompiler::pcurth" ref="a362a74315518470ef945244859c28a42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_f_g_1_1_thread.html">DFG::Thread</a>* <a class="el" href="class_sched_1_1sti_compiler.html#a362a74315518470ef945244859c28a42">Sched::stiCompiler::pcurth</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current thread that is being processed. </p>

</div>
</div>
<a class="anchor" id="aa36c0b06d1423fcfe66101ca8270fd36"></a><!-- doxytag: member="Sched::stiCompiler::tagcom" ref="aa36c0b06d1423fcfe66101ca8270fd36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint32_t <a class="el" href="class_sched_1_1sti_compiler.html#aa36c0b06d1423fcfe66101ca8270fd36">Sched::stiCompiler::tagcom</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tag for communication. </p>

</div>
</div>
<a class="anchor" id="a5ec376e1e685b4dd796bec963ff07a4d"></a><!-- doxytag: member="Sched::stiCompiler::tmpStack" ref="a5ec376e1e685b4dd796bec963ff07a4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_f_o_1_1_stack_frame_with_allocator.html">RFO::StackFrameWithAllocator</a> <a class="el" href="class_sched_1_1sti_compiler.html#a5ec376e1e685b4dd796bec963ff07a4d">Sched::stiCompiler::tmpStack</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporary stack storage. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="sched__compildfg_8h.html">sched_compildfg.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:53:05 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

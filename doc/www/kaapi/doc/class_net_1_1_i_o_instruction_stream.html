<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Net::IOInstructionStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_net.html">Net</a>::<a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a>
  </div>
</div>
<div class="contents">
<h1>Net::IOInstructionStream Class Reference</h1><!-- doxytag: class="Net::IOInstructionStream" --><!-- doxytag: inherits="Queable&lt; IOInstructionStream &gt;" -->
<p><code>#include &lt;network_ioinststream.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Net::IOInstructionStream:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_i_o_instruction_stream__inherit__graph.png" border="0" usemap="#_net_1_1_i_o_instruction_stream_inherit__map" alt="Inheritance graph"/></div>
<map name="_net_1_1_i_o_instruction_stream_inherit__map" id="_net_1_1_i_o_instruction_stream_inherit__map">
<area shape="rect" id="node7" href="class_net_1_1_out_channel.html" title="Net::OutChannel" alt="" coords="971,219,1112,248"/><area shape="rect" id="node2" href="class_util_1_1_queable.html" title="Util::Queable\&lt; IOInstructionStream \&gt;" alt="" coords="383,219,668,248"/><area shape="rect" id="node4" href="class_util_1_1_queable.html" title="Base class of object queueable into double linked list.To be en(de)queueable in a..." alt="" coords="7,219,159,248"/><area shape="rect" id="node9" href="class_f_d_n_e_t_1_1_out_channel.html" title="FDNET::OutChannel" alt="" coords="1181,5,1344,35"/><area shape="rect" id="node11" href="class_f_t_1_1_o_channel_file.html" title="OChannelFile." alt="" coords="1191,59,1335,88"/><area shape="rect" id="node13" href="class_f_t_1_1_out_channel_ida.html" title="FT::OutChannelIda" alt="" coords="1185,112,1340,141"/><area shape="rect" id="node15" href="class_m_a_n_e_t_1_1_out_channel.html" title="MANET::OutChannel" alt="" coords="1180,165,1345,195"/><area shape="rect" id="node17" href="class_m_y_n_e_t_1_1_out_channel.html" title="MYNET::OutChannel" alt="" coords="1180,219,1345,248"/><area shape="rect" id="node19" href="class_net_1_1_bast_out_channel.html" title="Net::BastOutChannel" alt="" coords="1177,272,1348,301"/><area shape="rect" id="node21" href="class_s_o_c_k_n_e_t_1_1_channel.html" title="SOCKNET::Channel" alt="" coords="1184,325,1341,355"/><area shape="rect" id="node23" href="class_t_a_k_t_u_k_n_e_t_1_1_out_channel.html" title="TAKTUKNET::OutChannel" alt="" coords="1164,379,1361,408"/><area shape="rect" id="node25" href="class_u_d_p_n_e_t_1_1_out_channel.html" title="UDPNET::OutChannel" alt="" coords="1176,432,1349,461"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Net::IOInstructionStream:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_i_o_instruction_stream__coll__graph.png" border="0" usemap="#_net_1_1_i_o_instruction_stream_coll__map" alt="Collaboration graph"/></div>
<map name="_net_1_1_i_o_instruction_stream_coll__map" id="_net_1_1_i_o_instruction_stream_coll__map">
<area shape="rect" id="node31" href="class_net_1_1_out_channel.html" title="Net::OutChannel" alt="" coords="1592,1172,1733,1201"/><area shape="rect" id="node2" href="class_util_1_1_queable.html" title="Util::Queable\&lt; IOInstructionStream \&gt;" alt="" coords="657,272,943,301"/><area shape="rect" id="node104" href="class_util_1_1_queue.html" title="Util::Queue\&lt; IOInstructionStream \&gt;" alt="" coords="1221,39,1496,68"/><area shape="rect" id="node5" href="class_util_1_1_queable.html" title="Base class of object queueable into double linked list.To be en(de)queueable in a..." alt="" coords="264,687,416,716"/><area shape="rect" id="node134" href="class_util_1_1_queable.html" title="Util::Queable\&lt; OutChannel \&gt;" alt="" coords="969,1193,1196,1223"/><area shape="rect" id="node7" href="struct_net_1_1_i_o_instruction.html" title="Net::IOInstruction" alt="" coords="727,1319,873,1348"/><area shape="rect" id="node9" href="struct_net_1_1_i_o_put_instruction.html" title="Net::IOPutInstruction" alt="" coords="255,1185,425,1215"/><area shape="rect" id="node19" href="struct_net_1_1_i_o_put_i_a_instruction.html" title="Net::IOPutIAInstruction" alt="" coords="248,1239,432,1268"/><area shape="rect" id="node22" href="struct_net_1_1_i_o_new_instruction.html" title="Net::IONewInstruction" alt="" coords="251,1292,429,1321"/><area shape="rect" id="node13" href="struct_net_1_1_i_o_del_instruction.html" title="Net::IODelInstruction" alt="" coords="255,1399,425,1428"/><area shape="rect" id="node15" href="struct_net_1_1_i_o_end_instruction.html" title="Net::IOEndInstruction" alt="" coords="253,1345,427,1375"/><area shape="rect" id="node17" href="struct_net_1_1_i_o_c_b_instruction.html" title="Net::IOCBInstruction" alt="" coords="5,1345,173,1375"/><area shape="rect" id="node25" href="struct_net_1_1_i_o_begin_instruction.html" title="Net::IOBeginInstruction" alt="" coords="245,1452,435,1481"/><area shape="rect" id="node27" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="280,1067,400,1096"/><area shape="rect" id="node35" href="class_util_1_1_object.html" title="Object with synchronisation mutex and condition variablesThe Object class defines..." alt="" coords="751,576,849,605"/><area shape="rect" id="node84" href="class_net_1_1_i_o_daemon.html" title="Net::IODaemon" alt="" coords="3328,271,3461,300"/><area shape="rect" id="node49" href="class_net_1_1_network.html" title="Net::Network" alt="" coords="2689,535,2804,564"/><area shape="rect" id="node67" href="class_net_1_1_node_info.html" title="Net::NodeInfo" alt="" coords="1948,828,2071,857"/><area shape="rect" id="node33" href="class_net_1_1_channel.html" title="Net::Channel" alt="" coords="3788,1135,3903,1164"/><area shape="rect" id="node44" href="class_net_1_1_device.html" title="Net::Device" alt="" coords="3341,784,3448,813"/><area shape="rect" id="node37" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="283,149,397,179"/><area shape="rect" id="node86" href="class_util_1_1_thread.html" title="POSIX interface to thread." alt="" coords="2337,241,2444,271"/><area shape="rect" id="node39" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors..." alt="" coords="291,316,389,345"/><area shape="rect" id="node42" href="class_net_1_1_device_object.html" title="Net::DeviceObject" alt="" coords="3585,979,3735,1008"/><area shape="rect" id="node63" href="class_net_1_1_cluster.html" title="Net::Cluster" alt="" coords="2337,712,2444,741"/><area shape="rect" id="node47" href="class_net_1_1_network_object.html" title="Net::NetworkObject" alt="" coords="3016,619,3176,648"/><area shape="rect" id="node52" href="class_net_1_1_callback.html" title="Net::Callback" alt="" coords="2332,393,2449,423"/><area shape="rect" id="node54" href="class_util_1_1_callback.html" title="Util::Callback" alt="" coords="1952,465,2067,495"/><area shape="rect" id="node60" href="class_net_1_1_upcall.html" title="Net::Upcall" alt="" coords="2341,465,2440,495"/><area shape="rect" id="node56" href="class_util_1_1_atomic.html" title="Atomic object represents atomic operation over integer.This class implements object..." alt="" coords="1612,463,1713,492"/><area shape="rect" id="node58" href="struct_util_1_1kaapi__atomic__t.html" title="Util::kaapi_atomic_t" alt="" coords="1279,459,1439,488"/><area shape="rect" id="node73" href="class_util_1_1_global_id.html" title="Class for representing a global identifier of the distributed processusGlobal Identifier..." alt="" coords="1607,757,1719,787"/><area shape="rect" id="node97" href="class_util_1_1_o_event_stream.html" title="Output events stream: Util::OEventStream." alt="" coords="1931,412,2088,441"/><area shape="rect" id="node76" href="class_util_1_1_r_w_lock.html" title="Read&#45;Write lockThis class implements interface for Posix Read&#45;Write lock. All errors..." alt="" coords="1955,775,2064,804"/><area shape="rect" id="node90" href="class_util_1_1_key.html" title="Util::Key\&lt; ByteAllocator \&gt;" alt="" coords="1908,225,2111,255"/><area shape="rect" id="node92" href="class_util_1_1_key.html" title="Thread private attributeThis class provides an interface to posix pthread specific..." alt="" coords="1603,199,1723,228"/><area shape="rect" id="node94" href="class_util_1_1_key.html" title="Util::Key\&lt; Thread \&gt;" alt="" coords="1928,172,2091,201"/><area shape="rect" id="node107" href="class_util_1_1_queue.html" title="Double linked list (thread unsafe)The queue descriptor is linked to the first and..." alt="" coords="729,39,871,68"/><area shape="rect" id="node112" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; CallStack \&gt;" alt="" coords="2641,889,2852,919"/><area shape="rect" id="node114" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; CallStack \&gt;" alt="" coords="2287,857,2495,887"/><area shape="rect" id="node117" href="class_util_1_1_linkable.html" title="Base class to make cells linkable in single linked listTo be (de)linkable in single..." alt="" coords="1933,955,2085,984"/><area shape="rect" id="node127" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; Bloc \&gt;" alt="" coords="2304,1005,2477,1035"/><area shape="rect" id="node119" href="class_util_1_1_stack_list.html" title="Thread linked list (thread unsafe)The StackList descriptor is linked to the top element..." alt="" coords="2313,911,2468,940"/><area shape="rect" id="node125" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; Bloc \&gt;" alt="" coords="2659,953,2835,983"/><area shape="rect" id="node121" href="class_net_1_1_device_factory.html" title="Net::DeviceFactory" alt="" coords="3017,732,3175,761"/><area shape="rect" id="node123" href="class_util_1_1_byte_allocator.html" title="ByteAllocator of fixed size objects with cache for fast allocation (thread unsafe)A..." alt="" coords="3023,952,3169,981"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_net_1_1_i_o_instruction_stream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a19b22deca3312bc800aa245f9287aabe">~IOInstructionStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a93882c4aaa14201ab166b9466413aca2">initialize</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a0a62511b637dbbaa672e5df6d4702b58">setup</a> (<a class="el" href="class_net_1_1_device.html">Device</a> *device, <a class="el" href="class_util_1_1_object.html">Util::Object</a> *obj, void *buffer, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a08492aed7b60d0bd20d56f54fa0d09b5">terminate</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_header_a_m.html">HeaderAM</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#acdd7a4b8cb5b129696fb2fa52d7bee23">pack_ibegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#afe91a1f05591675faa8cf3e7d49765a2">pack_iend</a> (<a class="el" href="namespace_net.html#a081b39e662b93d931f3b18d5ed0fa048">Callback_fnc</a> cbk, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a7b1daf08ce994a2e499e63d79bd16eb2">pack_inew</a> (void *ptr, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad5d4ad2b53db5c2a621e897f132a9349">pack_idel</a> (void *beg, void *last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a526c01363005a4e9386c3cbfd4460be2">pack_iput</a> (void *ptr, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#aaf307e39e464426dff9b43f33c9b7a02">pack_iput_ia</a> (void *ptr, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a0bba5b9d883f8fb647c73dfab6afe859">pack_data</a> (const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a457d5dde638cc0847be062eb0988a024">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a20745cfdd21385894739115da675a61c">full</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a73825d874d16d5b581367892f1946452">size_readyinstructions</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a4ed545e844f35599105ac29f87f7f010">suspend_producer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a534cc39907d73c690a75abb30a388b81">set_todel</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to acquire a bloc of instructions and decode them</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp05ea1d18260a033e325c077c9c0bfd55"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a919da848a1d7b3704f34262dcb5b0031">acquire_bloc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a27fd0bc84232c6d731f54e445067e6da">release_bloc</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_code, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch, bool onlytimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_vect_entry.html">IOVectEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a7c21bc5456888833eb041584d97ce853">decode</a> (void *buffer, int &amp;count)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#abba94876dfabe06b08b602a8f6911bff">set_channel</a> (<a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *chout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a91415e47558ec6149bd56230269a834f">get_channel</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae5689abfc325f42582197447e0f0c490">allocate_data</a> (size_t len)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a83e75e8e27ccc5eec80e89e395351564">_manager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a97f80c6fbb8737446d91fb9c7e2590af">_iodattach</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bloc allocator  <a href="#a97f80c6fbb8737446d91fb9c7e2590af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae4ce37c794841d82c8ecde354883e7ea">_time_first_error</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true iff the <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a> is attached  <a href="#ae4ce37c794841d82c8ecde354883e7ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#af1e90264faf6411c9af05c9921bafc54">_delay</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time of the last polled with error.  <a href="#af1e90264faf6411c9af05c9921bafc54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_object.html">Util::Object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a44fdf9e0d6b5b8cea8232f903f05bcc5">_sync</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay if _time_first_error !=0 for the next tentative.  <a href="#a44fdf9e0d6b5b8cea8232f903f05bcc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad6db3d0d4034e39c77d1c16fb0398cf7">_chout</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">object for synchronisation  <a href="#ad6db3d0d4034e39c77d1c16fb0398cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a14d47f8ad9e37ee13e4513031ba95a80">_markdel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">output channel  <a href="#a14d47f8ad9e37ee13e4513031ba95a80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae52429dc9122732d547e8c9ea4cb1626">_full</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">mark to be delete when empty  <a href="#ae52429dc9122732d547e8c9ea4cb1626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a5d593129a42afacd7eb276ccd5297647">_wait_prod</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">== true iff full  <a href="#a5d593129a42afacd7eb276ccd5297647"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_util_1_1_condition.html">Util::Condition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a87299910ea0632e48420a8f8fefcfba7">_cond_prod</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">== true iff producer is blocked until someone flush the buffer  <a href="#a87299910ea0632e48420a8f8fefcfba7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ac4e3c2c04b9888e2aa999f4ff08ea23d">_start</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">condition to wakeup producer  <a href="#ac4e3c2c04b9888e2aa999f4ff08ea23d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad27d8ea39476d3f4af69df4b8140b283">_last</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">first instruction in the buffer  <a href="#ad27d8ea39476d3f4af69df4b8140b283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#aeb7d84dc833d1e65b051bd8b3f374dca">_pos_r</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">past the last instruction in the buffer  <a href="#aeb7d84dc833d1e65b051bd8b3f374dca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae349b71ac4a89236b13c4d0c3a09c50c">_pos_last</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">next position for reading an entry in _first  <a href="#ae349b71ac4a89236b13c4d0c3a09c50c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a3c5ccae663f18d2286de3684f96600b5">_pos_w</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">past the last position of last reading entry end of message  <a href="#a3c5ccae663f18d2286de3684f96600b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a4a0a682bd22954d9dfc0f529a5b85fa2">_pos_close</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">next position for writing an entry in _curr  <a href="#a4a0a682bd22954d9dfc0f529a5b85fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a7cdf6c329829de84809fa158f35ea05c">_data_start</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">past the last position of the previous end of message  <a href="#a7cdf6c329829de84809fa158f35ea05c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a22f662d7c9eff55b1c9b5ca24b989e6b">_data_pos</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">first byte of the current bloc of data  <a href="#a22f662d7c9eff55b1c9b5ca24b989e6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad6de828d6b3a33fb5f9d82ff856aefd1">_data_last</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">current position  <a href="#ad6de828d6b3a33fb5f9d82ff856aefd1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#a8ab3cf206ea4374251e7da0f6a38fb67">IODaemon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_i_o_instruction_stream.html#adce0e5a099b05b583a2e1a66f47cc656">SOCKNET::Channel</a></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19b22deca3312bc800aa245f9287aabe"></a><!-- doxytag: member="Net::IOInstructionStream::~IOInstructionStream" ref="a19b22deca3312bc800aa245f9287aabe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Net::IOInstructionStream::~IOInstructionStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a919da848a1d7b3704f34262dcb5b0031"></a><!-- doxytag: member="Net::IOInstructionStream::acquire_bloc" ref="a919da848a1d7b3704f34262dcb5b0031" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Net::IOInstructionStream::acquire_bloc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the current bloc of instructions available for sending This method should be called before call to decode. The call mark the last instruction to read for sending and the corresponding release umark it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no instruction is available for sending </dd>
<dd>
&gt;0 the size of the buffer to be allocated for the call to decode </dd></dl>

</div>
</div>
<a class="anchor" id="ae5689abfc325f42582197447e0f0c490"></a><!-- doxytag: member="Net::IOInstructionStream::allocate_data" ref="ae5689abfc325f42582197447e0f0c490" args="(size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Net::IOInstructionStream::allocate_data </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocated data into the data stream The method reserves 'len' bytes into the data stream and returns a pointer into the buffer. The length 'len' should be less or equal to the size of the bloc allocated by the network. In case of success, the method returns a non null pointer. In case of error, the return value is 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the size of the reserved bytes into the data stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer of a bloc of size len in the data stream or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7c21bc5456888833eb041584d97ce853"></a><!-- doxytag: member="Net::IOInstructionStream::decode" ref="a7c21bc5456888833eb041584d97ce853" args="(void *buffer, int &amp;count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_vect_entry.html">IOVectEntry</a>* Net::IOInstructionStream::decode </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode the instruction stream and generate a iovect_entry of data to send over the network The methode requires the caller provides a buffer for internal purpose. The buffer to not be used before the call to notify. On return to the call, the return value points to the first iovecentry to be send. The value of the pointer is into the buffer. The number of iovectentry is set into count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>(INOUT) is a buffer of at least the size returned by acquire </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>(OUT) the number of <a class="el" href="struct_net_1_1_i_o_vect_entry.html">IOVectEntry</a> to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the first <a class="el" href="struct_net_1_1_i_o_vect_entry.html">IOVectEntry</a> to send </dd></dl>

</div>
</div>
<a class="anchor" id="a457d5dde638cc0847be062eb0988a024"></a><!-- doxytag: member="Net::IOInstructionStream::empty" ref="a457d5dde638cc0847be062eb0988a024" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Net::IOInstructionStream::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the buffer is empty </p>

</div>
</div>
<a class="anchor" id="a20745cfdd21385894739115da675a61c"></a><!-- doxytag: member="Net::IOInstructionStream::full" ref="a20745cfdd21385894739115da675a61c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Net::IOInstructionStream::full </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the buffer is full </p>

</div>
</div>
<a class="anchor" id="a91415e47558ec6149bd56230269a834f"></a><!-- doxytag: member="Net::IOInstructionStream::get_channel" ref="a91415e47558ec6149bd56230269a834f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> * Net::IOInstructionStream::get_channel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the output channel for this <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a93882c4aaa14201ab166b9466413aca2"></a><!-- doxytag: member="Net::IOInstructionStream::initialize" ref="a93882c4aaa14201ab166b9466413aca2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Net::IOInstructionStream::initialize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>initialize the <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> object. </p>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_out_channel.html#aec2099bc7b5896bc3639c752daf16b2d">FDNET::OutChannel</a>, <a class="el" href="class_m_a_n_e_t_1_1_out_channel.html#a1181a6877cedceaaee1d66d7cd35396f">MANET::OutChannel</a>, <a class="el" href="class_net_1_1_bast_out_channel.html#a7d0fc8e28924c942ac65a914d093736d">Net::BastOutChannel</a>, <a class="el" href="class_net_1_1_out_channel.html#a6348006160876b2bff041f93ed08c975">Net::OutChannel</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_channel.html#adf7087846a29453536fa37b4eb5f9d60">SOCKNET::Channel</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_out_channel.html#a29cb14750b9e72375de99c7414c751a0">TAKTUKNET::OutChannel</a>, and <a class="el" href="class_f_t_1_1_o_channel_file.html#a6be1dffb8b26ed71ee4d86cd325ecde0">FT::OChannelFile</a>.</p>

</div>
</div>
<a class="anchor" id="a0bba5b9d883f8fb647c73dfab6afe859"></a><!-- doxytag: member="Net::IOInstructionStream::pack_data" ref="a0bba5b9d883f8fb647c73dfab6afe859" args="(const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Net::IOInstructionStream::pack_data </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack data into the data stream. The method may allocates a new bloc of memory in order to pack all the len bytes, thus it also add instructions to flush old buffer and to mark the new bloc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>is the local pointer of the bloc to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the size of the bloc to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of packed data </dd></dl>

</div>
</div>
<a class="anchor" id="acdd7a4b8cb5b129696fb2fa52d7bee23"></a><!-- doxytag: member="Net::IOInstructionStream::pack_ibegin" ref="acdd7a4b8cb5b129696fb2fa52d7bee23" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_header_a_m.html">HeaderAM</a>* Net::IOInstructionStream::pack_ibegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a begin instruction. This instruction marks the begining of a message in the instruction stream. It may bloc the calling thread if no more space are available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer on the data stream on a region with at least sizeof(HeaderAM) bytes </dd>
<dd>
0 in case of failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad5d4ad2b53db5c2a621e897f132a9349"></a><!-- doxytag: member="Net::IOInstructionStream::pack_idel" ref="ad5d4ad2b53db5c2a621e897f132a9349" args="(void *beg, void *last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::pack_idel </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a flush instruction. This instruction indicates that the memory between the current top position until the last position in the bloc should be send and the current bloc may be destroy at the end of the send operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>beg</em>&nbsp;</td><td>the first pointer of the bloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>the last pointer of the bloc to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe91a1f05591675faa8cf3e7d49765a2"></a><!-- doxytag: member="Net::IOInstructionStream::pack_iend" ref="afe91a1f05591675faa8cf3e7d49765a2" args="(Callback_fnc cbk, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::pack_iend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_net.html#a081b39e662b93d931f3b18d5ed0fa048">Callback_fnc</a>&nbsp;</td>
          <td class="paramname"> <em>cbk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a end instruction. This instruction marks the end of a message in the instruction stream with the associated pointer on the position on the current data bloc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cbk</em>&nbsp;</td><td>the object to notify when this instruction is executed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>is argument for the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b1daf08ce994a2e499e63d79bd16eb2"></a><!-- doxytag: member="Net::IOInstructionStream::pack_inew" ref="a7b1daf08ce994a2e499e63d79bd16eb2" args="(void *ptr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::pack_inew </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a new bloc instruction. This instruction marks the allocation of a new bloc of data with the reference of the start address (ptr) and the length in bytes of this bloc </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the first pointer of the new allocated bloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the size of the bloc to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True iff success </dd></dl>

</div>
</div>
<a class="anchor" id="a526c01363005a4e9386c3cbfd4460be2"></a><!-- doxytag: member="Net::IOInstructionStream::pack_iput" ref="a526c01363005a4e9386c3cbfd4460be2" args="(void *ptr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::pack_iput </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a put instruction. This instruction indicates that the user bloc (ptr,len) should be put into the network. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the local pointer of the bloc to transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the size of the bloc to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf307e39e464426dff9b43f33c9b7a02"></a><!-- doxytag: member="Net::IOInstructionStream::pack_iput_ia" ref="aaf307e39e464426dff9b43f33c9b7a02" args="(void *ptr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::pack_iput_ia </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pack a put instruction. This instruction indicates that the user bloc (ptr,len) should be put into the network as a immediate data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>the local pointer of the bloc to transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the size of the bloc to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27fd0bc84232c6d731f54e445067e6da"></a><!-- doxytag: member="Net::IOInstructionStream::release_bloc" ref="a27fd0bc84232c6d731f54e445067e6da" args="(ComFailure::Code error_code, OutChannel *ch, bool onlytimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::release_bloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlytimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the bloc of instructions available for sending This method should be called after sending data generated by the method decode in order to garbage instructions in the instruction stream. The error_code may indicates an error if the value difers from <a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978fa9f0c47b1afec5abf407f7f9f055ff27d" title="No error return value.">ComFailure::OK</a>. The ch points to the output channel used for sending the message. If onlytimeout is true then the method only convert back to host representation all the headers. Memory bloc is not deleted and last read instruction is not changed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_code</em>&nbsp;</td><td>(IN) error code, see ComFailure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>(IN) output channel used to send message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>onlytimeout</em>&nbsp;</td><td>true if call with E_TIMEOUT error : do not release bloc or call callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abba94876dfabe06b08b602a8f6911bff"></a><!-- doxytag: member="Net::IOInstructionStream::set_channel" ref="abba94876dfabe06b08b602a8f6911bff" args="(OutChannel *chout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::set_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>chout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the output channel for this <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chout</em>&nbsp;</td><td>(INOU) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a534cc39907d73c690a75abb30a388b81"></a><!-- doxytag: member="Net::IOInstructionStream::set_todel" ref="a534cc39907d73c690a75abb30a388b81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::set_todel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark the object to as no more used and could be deleted </p>

</div>
</div>
<a class="anchor" id="a0a62511b637dbbaa672e5df6d4702b58"></a><!-- doxytag: member="Net::IOInstructionStream::setup" ref="a0a62511b637dbbaa672e5df6d4702b58" args="(Device *device, Util::Object *obj, void *buffer, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_util_1_1_object.html">Util::Object</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>initialize the <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> object. Should be call before any use of the object. An <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> is an infinite stream of IO instructions stored into a circular buffer coupled with an infinite stream of data (immediate data, pass by copy). The producer and the consumer are synchronized when the buffer is empty or full. The stream is message oriented in the sens that it contains marker for the begin and the end of a message. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manager</em>&nbsp;</td><td>(IN) the device object used for allocating bloc of memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>(INOUT) a pointer to the Object for synchronisation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>(INOUT) the buffer used to store IO instruction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>(IN) the size of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73825d874d16d5b581367892f1946452"></a><!-- doxytag: member="Net::IOInstructionStream::size_readyinstructions" ref="a73825d874d16d5b581367892f1946452" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Net::IOInstructionStream::size_readyinstructions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of instructions into the buffer ready to be decode </p>

</div>
</div>
<a class="anchor" id="a4ed545e844f35599105ac29f87f7f010"></a><!-- doxytag: member="Net::IOInstructionStream::suspend_producer" ref="a4ed545e844f35599105ac29f87f7f010" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::IOInstructionStream::suspend_producer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend the producer until the consumer flush the buffer This method should be implemented in order to suspend the thread that generates <a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a> until some of them are executed by the <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a>. </p>

</div>
</div>
<a class="anchor" id="a08492aed7b60d0bd20d56f54fa0d09b5"></a><!-- doxytag: member="Net::IOInstructionStream::terminate" ref="a08492aed7b60d0bd20d56f54fa0d09b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Net::IOInstructionStream::terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Should be call to clear and delete internal state of the object. </p>

<p>Reimplemented in <a class="el" href="class_f_d_n_e_t_1_1_out_channel.html#aab3aff10dc1ab04ce74be518730a207b">FDNET::OutChannel</a>, <a class="el" href="class_m_a_n_e_t_1_1_out_channel.html#a66d5b88b295955d949833674054603a0">MANET::OutChannel</a>, <a class="el" href="class_m_y_n_e_t_1_1_out_channel.html#a66d0959251f204df483d17b8af8e18b5">MYNET::OutChannel</a>, <a class="el" href="class_net_1_1_bast_out_channel.html#a2d52455721aad09e20723ad01c58b4bb">Net::BastOutChannel</a>, <a class="el" href="class_net_1_1_out_channel.html#a01939c605072b99484451defd35c88aa">Net::OutChannel</a>, <a class="el" href="class_s_o_c_k_n_e_t_1_1_channel.html#a651e8fde23a96cde0dce30d3a0508acf">SOCKNET::Channel</a>, <a class="el" href="class_t_a_k_t_u_k_n_e_t_1_1_out_channel.html#ab01ec693bdce4a2f16761d7643fa4491">TAKTUKNET::OutChannel</a>, <a class="el" href="class_u_d_p_n_e_t_1_1_out_channel.html#a61baeb50b42249a9f07b6b85055bdb2d">UDPNET::OutChannel</a>, and <a class="el" href="class_f_t_1_1_o_channel_file.html#a03f437d1da1119ad3bdea9b361e09630">FT::OChannelFile</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8ab3cf206ea4374251e7da0f6a38fb67"></a><!-- doxytag: member="Net::IOInstructionStream::IODaemon" ref="a8ab3cf206ea4374251e7da0f6a38fb67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="class_net_1_1_out_channel.html#a8ab3cf206ea4374251e7da0f6a38fb67">Net::OutChannel</a>.</p>

</div>
</div>
<a class="anchor" id="adce0e5a099b05b583a2e1a66f47cc656"></a><!-- doxytag: member="Net::IOInstructionStream::SOCKNET::Channel" ref="adce0e5a099b05b583a2e1a66f47cc656" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_s_o_c_k_n_e_t_1_1_channel.html">SOCKNET::Channel</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad6db3d0d4034e39c77d1c16fb0398cf7"></a><!-- doxytag: member="Net::IOInstructionStream::_chout" ref="ad6db3d0d4034e39c77d1c16fb0398cf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad6db3d0d4034e39c77d1c16fb0398cf7">Net::IOInstructionStream::_chout</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>object for synchronisation </p>

</div>
</div>
<a class="anchor" id="a87299910ea0632e48420a8f8fefcfba7"></a><!-- doxytag: member="Net::IOInstructionStream::_cond_prod" ref="a87299910ea0632e48420a8f8fefcfba7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_condition.html">Util::Condition</a> <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a87299910ea0632e48420a8f8fefcfba7">Net::IOInstructionStream::_cond_prod</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>== true iff producer is blocked until someone flush the buffer </p>

</div>
</div>
<a class="anchor" id="ad6de828d6b3a33fb5f9d82ff856aefd1"></a><!-- doxytag: member="Net::IOInstructionStream::_data_last" ref="ad6de828d6b3a33fb5f9d82ff856aefd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint8_t* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad6de828d6b3a33fb5f9d82ff856aefd1">Net::IOInstructionStream::_data_last</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>current position </p>

</div>
</div>
<a class="anchor" id="a22f662d7c9eff55b1c9b5ca24b989e6b"></a><!-- doxytag: member="Net::IOInstructionStream::_data_pos" ref="a22f662d7c9eff55b1c9b5ca24b989e6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint8_t* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a22f662d7c9eff55b1c9b5ca24b989e6b">Net::IOInstructionStream::_data_pos</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>first byte of the current bloc of data </p>

</div>
</div>
<a class="anchor" id="a7cdf6c329829de84809fa158f35ea05c"></a><!-- doxytag: member="Net::IOInstructionStream::_data_start" ref="a7cdf6c329829de84809fa158f35ea05c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint8_t* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a7cdf6c329829de84809fa158f35ea05c">Net::IOInstructionStream::_data_start</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>past the last position of the previous end of message </p>

</div>
</div>
<a class="anchor" id="af1e90264faf6411c9af05c9921bafc54"></a><!-- doxytag: member="Net::IOInstructionStream::_delay" ref="af1e90264faf6411c9af05c9921bafc54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_net_1_1_i_o_instruction_stream.html#af1e90264faf6411c9af05c9921bafc54">Net::IOInstructionStream::_delay</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time of the last polled with error. </p>

</div>
</div>
<a class="anchor" id="ae52429dc9122732d547e8c9ea4cb1626"></a><!-- doxytag: member="Net::IOInstructionStream::_full" ref="ae52429dc9122732d547e8c9ea4cb1626" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae52429dc9122732d547e8c9ea4cb1626">Net::IOInstructionStream::_full</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>mark to be delete when empty </p>

</div>
</div>
<a class="anchor" id="a97f80c6fbb8737446d91fb9c7e2590af"></a><!-- doxytag: member="Net::IOInstructionStream::_iodattach" ref="a97f80c6fbb8737446d91fb9c7e2590af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a97f80c6fbb8737446d91fb9c7e2590af">Net::IOInstructionStream::_iodattach</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>bloc allocator </p>

</div>
</div>
<a class="anchor" id="ad27d8ea39476d3f4af69df4b8140b283"></a><!-- doxytag: member="Net::IOInstructionStream::_last" ref="ad27d8ea39476d3f4af69df4b8140b283" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ad27d8ea39476d3f4af69df4b8140b283">Net::IOInstructionStream::_last</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>first instruction in the buffer </p>

</div>
</div>
<a class="anchor" id="a83e75e8e27ccc5eec80e89e395351564"></a><!-- doxytag: member="Net::IOInstructionStream::_manager" ref="a83e75e8e27ccc5eec80e89e395351564" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device.html">Device</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a83e75e8e27ccc5eec80e89e395351564">Net::IOInstructionStream::_manager</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14d47f8ad9e37ee13e4513031ba95a80"></a><!-- doxytag: member="Net::IOInstructionStream::_markdel" ref="a14d47f8ad9e37ee13e4513031ba95a80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a14d47f8ad9e37ee13e4513031ba95a80">Net::IOInstructionStream::_markdel</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>output channel </p>

</div>
</div>
<a class="anchor" id="a4a0a682bd22954d9dfc0f529a5b85fa2"></a><!-- doxytag: member="Net::IOInstructionStream::_pos_close" ref="a4a0a682bd22954d9dfc0f529a5b85fa2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a4a0a682bd22954d9dfc0f529a5b85fa2">Net::IOInstructionStream::_pos_close</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>next position for writing an entry in _curr </p>

</div>
</div>
<a class="anchor" id="ae349b71ac4a89236b13c4d0c3a09c50c"></a><!-- doxytag: member="Net::IOInstructionStream::_pos_last" ref="ae349b71ac4a89236b13c4d0c3a09c50c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae349b71ac4a89236b13c4d0c3a09c50c">Net::IOInstructionStream::_pos_last</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>next position for reading an entry in _first </p>

</div>
</div>
<a class="anchor" id="aeb7d84dc833d1e65b051bd8b3f374dca"></a><!-- doxytag: member="Net::IOInstructionStream::_pos_r" ref="aeb7d84dc833d1e65b051bd8b3f374dca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#aeb7d84dc833d1e65b051bd8b3f374dca">Net::IOInstructionStream::_pos_r</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>past the last instruction in the buffer </p>

</div>
</div>
<a class="anchor" id="a3c5ccae663f18d2286de3684f96600b5"></a><!-- doxytag: member="Net::IOInstructionStream::_pos_w" ref="a3c5ccae663f18d2286de3684f96600b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a3c5ccae663f18d2286de3684f96600b5">Net::IOInstructionStream::_pos_w</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>past the last position of last reading entry end of message </p>

</div>
</div>
<a class="anchor" id="ac4e3c2c04b9888e2aa999f4ff08ea23d"></a><!-- doxytag: member="Net::IOInstructionStream::_start" ref="ac4e3c2c04b9888e2aa999f4ff08ea23d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_net_1_1_i_o_instruction.html">IOInstruction</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ac4e3c2c04b9888e2aa999f4ff08ea23d">Net::IOInstructionStream::_start</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>condition to wakeup producer </p>

</div>
</div>
<a class="anchor" id="a44fdf9e0d6b5b8cea8232f903f05bcc5"></a><!-- doxytag: member="Net::IOInstructionStream::_sync" ref="a44fdf9e0d6b5b8cea8232f903f05bcc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_util_1_1_object.html">Util::Object</a>* <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a44fdf9e0d6b5b8cea8232f903f05bcc5">Net::IOInstructionStream::_sync</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delay if _time_first_error !=0 for the next tentative. </p>

</div>
</div>
<a class="anchor" id="ae4ce37c794841d82c8ecde354883e7ea"></a><!-- doxytag: member="Net::IOInstructionStream::_time_first_error" ref="ae4ce37c794841d82c8ecde354883e7ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_net_1_1_i_o_instruction_stream.html#ae4ce37c794841d82c8ecde354883e7ea">Net::IOInstructionStream::_time_first_error</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true iff the <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a> is attached </p>

</div>
</div>
<a class="anchor" id="a5d593129a42afacd7eb276ccd5297647"></a><!-- doxytag: member="Net::IOInstructionStream::_wait_prod" ref="a5d593129a42afacd7eb276ccd5297647" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool <a class="el" href="class_net_1_1_i_o_instruction_stream.html#a5d593129a42afacd7eb276ccd5297647">Net::IOInstructionStream::_wait_prod</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>== true iff full </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="network__ioinststream_8h.html">network_ioinststream.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:52:44 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Kaapi: Net::Network Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_net.html">Net</a>::<a class="el" href="class_net_1_1_network.html">Network</a>
  </div>
</div>
<div class="contents">
<h1>Net::Network Class Reference</h1><!-- doxytag: class="Net::Network" --><!-- doxytag: inherits="Util::Object,Net::Callback,Net::Upcall" -->
<p><code>#include &lt;network_network.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Net::Network:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_network__inherit__graph.png" border="0" usemap="#_net_1_1_network_inherit__map" alt="Inheritance graph"/></div>
<map name="_net_1_1_network_inherit__map" id="_net_1_1_network_inherit__map">
<area shape="rect" id="node2" href="class_util_1_1_object.html" title="Object with synchronisation mutex and condition variablesThe Object class defines..." alt="" coords="149,83,248,112"/><area shape="rect" id="node4" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="5,5,120,35"/><area shape="rect" id="node6" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors..." alt="" coords="144,5,243,35"/><area shape="rect" id="node8" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="267,5,387,35"/><area shape="rect" id="node10" href="class_net_1_1_callback.html" title="Net::Callback" alt="" coords="277,83,395,112"/><area shape="rect" id="node12" href="class_util_1_1_callback.html" title="Util::Callback" alt="" coords="411,5,525,35"/><area shape="rect" id="node14" href="class_net_1_1_upcall.html" title="Net::Upcall" alt="" coords="419,83,517,112"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Net::Network:</div>
<div class="dynsection">
<div class="center"><img src="class_net_1_1_network__coll__graph.png" border="0" usemap="#_net_1_1_network_coll__map" alt="Collaboration graph"/></div>
<map name="_net_1_1_network_coll__map" id="_net_1_1_network_coll__map">
<area shape="rect" id="node23" href="class_net_1_1_network_object.html" title="Net::NetworkObject" alt="" coords="1799,579,1959,608"/><area shape="rect" id="node2" href="class_util_1_1_object.html" title="Object with synchronisation mutex and condition variablesThe Object class defines..." alt="" coords="800,1187,899,1216"/><area shape="rect" id="node32" href="class_net_1_1_channel.html" title="Net::Channel" alt="" coords="2865,1283,2980,1312"/><area shape="rect" id="node37" href="class_net_1_1_device.html" title="Net::Device" alt="" coords="2235,505,2341,535"/><area shape="rect" id="node66" href="class_net_1_1_i_o_instruction_stream.html" title="Net::IOInstructionStream" alt="" coords="2553,832,2751,861"/><area shape="rect" id="node100" href="class_net_1_1_i_o_daemon.html" title="Net::IODaemon" alt="" coords="2221,1075,2355,1104"/><area shape="rect" id="node4" href="class_util_1_1_object_id.html" title="Object with identifierThe Object class defines object that needs to have and identifier..." alt="" coords="465,1459,580,1488"/><area shape="rect" id="node102" href="class_util_1_1_thread.html" title="POSIX interface to thread." alt="" coords="1825,1879,1932,1908"/><area shape="rect" id="node6" href="class_util_1_1_mutex.html" title="Exclusive code execution.This class implements interface for Posix mutex. All errors..." alt="" coords="473,1791,572,1820"/><area shape="rect" id="node125" href="class_util_1_1_event_buffer_manager.html" title="A Generic Buffer Manager : EventBufferManager EventBufferManager is an implementation..." alt="" coords="2187,1768,2389,1797"/><area shape="rect" id="node8" href="class_util_1_1_condition.html" title="Posix conditionsThis class implements interface to posix condition variable. All..." alt="" coords="463,1037,583,1067"/><area shape="rect" id="node10" href="class_net_1_1_callback.html" title="Net::Callback" alt="" coords="791,484,908,513"/><area shape="rect" id="node12" href="class_util_1_1_callback.html" title="Util::Callback" alt="" coords="465,484,580,513"/><area shape="rect" id="node18" href="class_net_1_1_upcall.html" title="Net::Upcall" alt="" coords="800,393,899,423"/><area shape="rect" id="node14" href="class_util_1_1_atomic.html" title="Atomic object represents atomic operation over integer.This class implements object..." alt="" coords="247,1576,348,1605"/><area shape="rect" id="node16" href="struct_util_1_1kaapi__atomic__t.html" title="Util::kaapi_atomic_t" alt="" coords="5,1877,165,1907"/><area shape="rect" id="node21" href="class_net_1_1_cluster.html" title="Net::Cluster" alt="" coords="2599,541,2705,571"/><area shape="rect" id="node27" href="class_net_1_1_node_info.html" title="Net::NodeInfo" alt="" coords="3368,592,3491,621"/><area shape="rect" id="node30" href="class_net_1_1_out_channel.html" title="Net::OutChannel" alt="" coords="3083,887,3224,916"/><area shape="rect" id="node35" href="class_net_1_1_device_object.html" title="Net::DeviceObject" alt="" coords="2577,609,2727,639"/><area shape="rect" id="node43" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; CallStack \&gt;" alt="" coords="1215,97,1425,127"/><area shape="rect" id="node45" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; CallStack \&gt;" alt="" coords="745,47,953,76"/><area shape="rect" id="node48" href="class_util_1_1_linkable.html" title="Base class to make cells linkable in single linked listTo be (de)linkable in single..." alt="" coords="447,121,599,151"/><area shape="rect" id="node58" href="class_util_1_1_linkable.html" title="Util::Linkable\&lt; Bloc \&gt;" alt="" coords="763,195,936,224"/><area shape="rect" id="node50" href="class_util_1_1_stack_list.html" title="Thread linked list (thread unsafe)The StackList descriptor is linked to the top element..." alt="" coords="772,100,927,129"/><area shape="rect" id="node56" href="class_util_1_1_stack_list.html" title="Util::StackList\&lt; Bloc \&gt;" alt="" coords="1232,185,1408,215"/><area shape="rect" id="node52" href="class_net_1_1_device_factory.html" title="Net::DeviceFactory" alt="" coords="1800,525,1957,555"/><area shape="rect" id="node54" href="class_util_1_1_byte_allocator.html" title="ByteAllocator of fixed size objects with cache for fast allocation (thread unsafe)A..." alt="" coords="1805,185,1952,215"/><area shape="rect" id="node63" href="class_util_1_1_global_id.html" title="Class for representing a global identifier of the distributed processusGlobal Identifier..." alt="" coords="1823,1436,1935,1465"/><area shape="rect" id="node113" href="class_util_1_1_o_event_stream.html" title="Output events stream: Util::OEventStream." alt="" coords="2573,1635,2731,1664"/><area shape="rect" id="node117" href="class_util_1_1_event_buffer.html" title="A Generic Trace Buffer class: Util::EventBuffer." alt="" coords="2219,1547,2357,1576"/><area shape="rect" id="node68" href="class_util_1_1_queable.html" title="Util::Queable\&lt; IOInstructionStream \&gt;" alt="" coords="1177,1097,1463,1127"/><area shape="rect" id="node143" href="class_util_1_1_queue.html" title="Util::Queue\&lt; IOInstructionStream \&gt;" alt="" coords="1741,1107,2016,1136"/><area shape="rect" id="node71" href="class_util_1_1_queable.html" title="Base class of object queueable into double linked list.To be en(de)queueable in a..." alt="" coords="773,1353,925,1383"/><area shape="rect" id="node85" href="class_util_1_1_queable.html" title="Util::Queable\&lt; OutChannel \&gt;" alt="" coords="1489,1368,1716,1397"/><area shape="rect" id="node119" href="class_util_1_1_queable.html" title="Util::Queable\&lt; EventBuffer \&gt;" alt="" coords="1207,1517,1433,1547"/><area shape="rect" id="node73" href="struct_net_1_1_i_o_instruction.html" title="Net::IOInstruction" alt="" coords="2215,937,2361,967"/><area shape="rect" id="node75" href="struct_net_1_1_i_o_put_instruction.html" title="Net::IOPutInstruction" alt="" coords="1793,884,1964,913"/><area shape="rect" id="node77" href="struct_net_1_1_i_o_del_instruction.html" title="Net::IODelInstruction" alt="" coords="1793,937,1964,967"/><area shape="rect" id="node92" href="class_util_1_1_r_w_lock.html" title="Read&#45;Write lockThis class implements interface for Posix Read&#45;Write lock. All errors..." alt="" coords="2233,452,2343,481"/><area shape="rect" id="node106" href="class_util_1_1_key.html" title="Util::Key\&lt; ByteAllocator \&gt;" alt="" coords="1219,1875,1421,1904"/><area shape="rect" id="node108" href="class_util_1_1_key.html" title="Thread private attributeThis class provides an interface to posix pthread specific..." alt="" coords="789,1821,909,1851"/><area shape="rect" id="node110" href="class_util_1_1_key.html" title="Util::Key\&lt; Thread \&gt;" alt="" coords="1239,1821,1401,1851"/><area shape="rect" id="node115" href="class_util_1_1_context_id.html" title="Util::ContextId" alt="" coords="1817,1568,1940,1597"/><area shape="rect" id="node132" href="class_util_1_1_queue.html" title="Util::Queue\&lt; EventBuffer \&gt;" alt="" coords="1771,1621,1987,1651"/><area shape="rect" id="node128" href="class_util_1_1_reify_notify_signal.html" title="ReifyNotifySignalThis class allows to reify the invocations to InterfaceSignal::signal..." alt="" coords="1791,1784,1967,1813"/><area shape="rect" id="node135" href="class_util_1_1_queue.html" title="Double linked list (thread unsafe)The queue descriptor is linked to the first and..." alt="" coords="1249,1405,1391,1435"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_net_1_1_network-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aa0e0c21560872f62af8ceb991b4d8e4b">Network</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9564c8f67b15d78690c99ae1d7d71aae">~Network</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Network initialilization and termination</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp89d113491e853c3efbc93954f2d5ddd0"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a1cc46e69e455659258eb9fd0b3b8063f">initialize</a> ()  throw (RuntimeError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a89c257af540a06918dc35998eb674b67">commit</a> ()  throw (RuntimeError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#af6bda4dc882254c8f0ebf4ac9379011e">terminate</a> ()  throw (RuntimeError)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties and name management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6790a514b13a0fa7bf642b7c274374ca"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a23061412c684b1661ff37bf270364ad2">get_name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#af0367a07e532a6cd84ee1bb61389a5dc">set_name</a> (const std::string &amp;name)</td></tr>
<tr><td colspan="2"><h2>Routing</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp786c4135070aa1910d2f4ac8b2253235"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="class_net_1_1_node_info.html">Net::NodeInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a743b74e598f17d5039b43e8bce00d881">NodeInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> * &gt;<br class="typebreak"/>
::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">iterator_node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> * &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">const_iterator_node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> * &gt;::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a7196732628d224c75defb55d30dd652f">iterator_route</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> * &gt;<br class="typebreak"/>
::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a8407005d50d245bb650cdb47e422271c">const_iterator_route</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a01ea1b5625cb6c012fdf09bab137b512">localid_to_nodeinfo</a> (ka_uint16_t lid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a90274f393b63b22c5bd70729978b6718">globalid_to_nodeinfo</a> (<a class="el" href="class_util_1_1_global_id.html">GlobalId</a> gid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_node_info.html">Network::NodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a79ec0beb46292d6e30f3e7f1e003b4d9">resolve_nodeinfo</a> (<a class="el" href="class_util_1_1_global_id.html">GlobalId</a> gid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_cluster.html">Cluster</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ad2d6b9a77e5fba4845f651d89c55fd1a">resolve_cluster</a> (const std::string &amp;clusterpath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aa9357f70c2456ab6629692eeba2fe921">register_cluster</a> (<a class="el" href="class_net_1_1_cluster.html">Cluster</a> *<a class="el" href="class_net_1_1_network.html#a9e7f5676dc2a27a7210bbf3b537e8b15">cluster</a>, const std::string &amp;clusterpath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a08c7d3982aa320b0739a17716f151f3b">add_node</a> (<a class="el" href="class_util_1_1_global_id.html">GlobalId</a> gid, const std::string &amp;url_peer, const std::string &amp;<a class="el" href="class_net_1_1_network.html#a9e7f5676dc2a27a7210bbf3b537e8b15">cluster</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a73caf1dd96f2998e2312575c7dd15d67">del_node</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a145aa1304cf6b06f751dd70b0bfd9c1a">add_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9effb562a16c39a2b91b3cd7f4e8f383">del_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a89593d1ba8afa5cf140152bb2c876971">del_routes</a> (<a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a3e540196a8b34eb59d10dc5f2cda102d">get_default_local_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a56350a6570ef5b114edfde5ed8b4dcad">get_default_local_route</a> (<a class="el" href="class_net_1_1_device.html">Device</a> *device, <a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ab8007c4d359d95f27156c65827692d36">set_default_local_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a2163516065b9456ac1444c2bed8a15cb">open_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni, const std::string &amp;url)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a3d12d296ad8f55c9f17988fc8f4c9650">close_route</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9c1f1ef003514d1c895ea59b6cb8eb0d">close_routes</a> (<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *ni)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ade9985bddd27159d54ab67e3ebf15c4a">count_nodes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">iterator_node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aac2f09d4af9e7468962a276e134da64a">begin_node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">const_iterator_node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a569919daf3ea3bd1d0b88029410cfcb4">begin_node</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">iterator_node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a532b50a06ba168b7a09a3c432b395529">end_node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">const_iterator_node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aae041f337a3360205002b2a9496e11c9">end_node</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ade00d4ff727d4a66b56c7dd84d2499e8">print_node</a> (std::ostream &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a92549b2d8f88b9ad728e95c617faff2c">print_route</a> (std::ostream &amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a0ca6e1b84c7de85c7601f61df3ebe8c6">dump_info</a> ()</td></tr>
<tr><td colspan="2"><h2>Misc</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp74248c725e00bf9fe04df4e35b249a19"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">clustername</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of the cluster for this process.  <a href="#aee4527b16b6e4c285d3902b4baf44a81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_cluster.html">Cluster</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9e7f5676dc2a27a7210bbf3b537e8b15">cluster</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cluster for the running process.  <a href="#a9e7f5676dc2a27a7210bbf3b537e8b15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_cluster.html">Cluster</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#adda8e3582eb2c017ce5ac9caf95d8adc">parentcluster</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cluster for the running process and its brothers.  <a href="#adda8e3582eb2c017ce5ac9caf95d8adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_net_1_1_cluster.html">Cluster</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a77c36a0ebc1a94b2f9af542f11db0d52">rootcluster</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root cluster of the whole computation.  <a href="#a77c36a0ebc1a94b2f9af542f11db0d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="class_net_1_1_cluster.html">Cluster</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a44db41913d6c1674130c9c6d6758e0aa">_cluster</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">known clusters  <a href="#a44db41913d6c1674130c9c6d6758e0aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="class_util_1_1_global_id.html">GlobalId</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a98c10d69e31250864883c0d1e08f1a8c">_leaders</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">known clusters  <a href="#a98c10d69e31250864883c0d1e08f1a8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aa834f0ee2967ae879632fff1b9a3e9a0">_nid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the network instance  <a href="#aa834f0ee2967ae879632fff1b9a3e9a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9a3e0cc31330e95ac7835102856afb10">_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of the network.  <a href="#a9a3e0cc31330e95ac7835102856afb10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_net_1_1_cluster.html">Cluster</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a7d470e79e54736088d00564e404e3620">_all_clusters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_upcall.html">Upcall</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ae7d63901cc55a75e61416670605b79f7">_upcall</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">all the clusters  <a href="#ae7d63901cc55a75e61416670605b79f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_callback.html">Callback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a5601e595078dda4244f34b77f9e4ad15">_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">object to forward callback, default is the network object  <a href="#a5601e595078dda4244f34b77f9e4ad15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aa2d5eef7e14b57a3c86661d5223aafca">_next_lid</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">next local id for a node  <a href="#aa2d5eef7e14b57a3c86661d5223aafca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::list&lt; ka_uint16_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a214f1f7409673a9b2bca49f4532d0ae9">_free_lid_entries</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of free entries in _known_nodes  <a href="#a214f1f7409673a9b2bca49f4532d0ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a507c94607f3ed02fa1f63c003e4a0f51">_known_nodes</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">known nodes from local id  <a href="#a507c94607f3ed02fa1f63c003e4a0f51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ac1bbae6b663fd89d1a2f383597795e6a">_count_nodes</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of nodes  <a href="#ac1bbae6b663fd89d1a2f383597795e6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_util_1_1_global_id.html">GlobalId</a>, <a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a35c5ec8aa070b43fe234969f77affc6a">_gid2nodes</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">global to nodeinfo lookup table  <a href="#a35c5ec8aa070b43fe234969f77affc6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a41fb366d4be2babe3d38f48ce8878279">_iodaemon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a4e8ee55314511cf341340c6e7dc3bcd4">_default_device</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default device.  <a href="#a4e8ee55314511cf341340c6e7dc3bcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a8ab3cf206ea4374251e7da0f6a38fb67">IODaemon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#acb1172fca541ea3cf6a9363dbbbad057">IOInstructionStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a74ef9b808cea5532adf31656aca64b97">get_urlconnect</a> () const   throw (IOError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9f762e2e596dbf84f5e97439e23df51e">get_devicename_from_url</a> (const std::string &amp;url_peer) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a2d541b3e4b2bd63709d0ecc463cec78a">get_device_from_url</a> (const std::string &amp;url_peer) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a37dcaf8c54e74c3cdfca717274ac8836">get_device_for_this_cluster</a> (const std::string &amp;<a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">clustername</a>) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a9acd8a037d8fcefb0dd2692e6c04f0df">get_leader_for_this_cluster</a> (const std::string &amp;<a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">clustername</a>)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ace11b07a5276a3eb93b5b18b49b14837">set_leader_for_this_cluster</a> (const <a class="el" href="class_util_1_1_global_id.html">Util::GlobalId</a> &amp;gid, const std::string &amp;<a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">clustername</a>)  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a8f63e058a7a5189362de19f714ac0f76">is_leader</a> () const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#af0234b8edf1f6a01f086f644a6d26867">is_a_leader</a> (const <a class="el" href="class_util_1_1_global_id.html">Util::GlobalId</a> &amp;gid, const std::string &amp;<a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">clustername</a>) const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ka_uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aaedb47b037106231be10a5be40e12677">get_id</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a56d245562fa16f87d37c416ccb0c6b51">wakeup_iodaemon</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#ac863d2b6579a046cf333162d0e74ca22">flush_channels</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_upcall.html">Upcall</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a8bfd9e2bb5f1611c797f965095dacd9a">set_upcall</a> (<a class="el" href="class_net_1_1_upcall.html">Upcall</a> *new_upcall)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_net_1_1_callback.html">Callback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#af71fecf796b74bfe1a1ad73d59eaf37d">set_callback</a> (<a class="el" href="class_net_1_1_callback.html">Callback</a> *new_callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a6b76206209f3fff3a2e78d95ac2cef08">signal</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *ch, <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aca4e5df35e3f5ad518b37c41021973f4">signal</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch, <a class="el" href="class_net_1_1_header.html">Header</a> *header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a3c9df0e70c3196968a09da993b18a46c">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a5c36226132c8c991a8c109b8802ac081">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *ch, <a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#aeb8c33fa08b8759c540f5bd5dfce9006">notify</a> (<a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a> error_no, <a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *ch, <a class="el" href="class_net_1_1_header.html">Header</a> *header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a7a8a02260202d056bb72e7c5b4d579b2">attach_iostream</a> (<a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> *ios)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_net_1_1_network.html#a147b0c6fd905d3f516812aceaa1c1264">deattach_iostream</a> (<a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> *ios)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_net_1_1_network.html">Network</a> is the class for network adapter interface. <a class="el" href="class_net_1_1_network.html">Network</a> object has only local vision of the topology. A network object only known its neighbors. Numbering if local. For instance, let us consider two <a class="el" href="class_net_1_1_network.html">Network</a> objects connected by a channel I : I NO1 &lt;-------------&gt; NO2 3 1 On the object NO1, NO2 has label 3 and NO1 has, by convention label 0. On the object NO2, NO1 has label 1 and NO2 has, by convention label 0. The peer node for I on node NO1 is 3. The peer node for I on node NO2 is 1. The channel I has an identifier and several channels between NO1 and NO2 may exists. The channel is associated to a <a class="el" href="class_net_1_1_device.html">Net::Device</a> that manage connexion between node. On top of <a class="el" href="class_net_1_1_network.html">Network</a> and local numbering of nodes, distributed algorithms have to be used to provide more convenient numbering.</p>
<p>Default properties: net.blocsize = &lt;integer&gt;; // the size in bytes for bloc allocation </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a83a1dad097cac06ab8af48c9f94773d3"></a><!-- doxytag: member="Net::Network::const_iterator_node" ref="a83a1dad097cac06ab8af48c9f94773d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>*&gt;::const_iterator <a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">Net::Network::const_iterator_node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator over known nodes </p>

</div>
</div>
<a class="anchor" id="a8407005d50d245bb650cdb47e422271c"></a><!-- doxytag: member="Net::Network::const_iterator_route" ref="a8407005d50d245bb650cdb47e422271c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>*&gt;::const_iterator <a class="el" href="class_net_1_1_network.html#a8407005d50d245bb650cdb47e422271c">Net::Network::const_iterator_route</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator over declared routes </p>

</div>
</div>
<a class="anchor" id="ae99877e02d624ee69e8fe8d8aeaf5f0d"></a><!-- doxytag: member="Net::Network::iterator_node" ref="ae99877e02d624ee69e8fe8d8aeaf5f0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>*&gt;::iterator <a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">Net::Network::iterator_node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator over known nodes </p>

</div>
</div>
<a class="anchor" id="a7196732628d224c75defb55d30dd652f"></a><!-- doxytag: member="Net::Network::iterator_route" ref="a7196732628d224c75defb55d30dd652f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>*&gt;::iterator <a class="el" href="class_net_1_1_network.html#a7196732628d224c75defb55d30dd652f">Net::Network::iterator_route</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>iterator over declared routes </p>

</div>
</div>
<a class="anchor" id="a743b74e598f17d5039b43e8bce00d881"></a><!-- doxytag: member="Net::Network::NodeInfo" ref="a743b74e598f17d5039b43e8bce00d881" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="class_net_1_1_node_info.html">Net::NodeInfo</a> <a class="el" href="class_net_1_1_node_info.html">Net::Network::NodeInfo</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Typedef </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa0e0c21560872f62af8ceb991b4d8e4b"></a><!-- doxytag: member="Net::Network::Network" ref="aa0e0c21560872f62af8ceb991b4d8e4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Net::Network::Network </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a class="anchor" id="a9564c8f67b15d78690c99ae1d7d71aae"></a><!-- doxytag: member="Net::Network::~Network" ref="a9564c8f67b15d78690c99ae1d7d71aae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Net::Network::~Network </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a08c7d3982aa320b0739a17716f151f3b"></a><!-- doxytag: member="Net::Network::add_node" ref="a08c7d3982aa320b0739a17716f151f3b" args="(GlobalId gid, const std::string &amp;url_peer, const std::string &amp;cluster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>* Net::Network::add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_global_id.html">GlobalId</a>&nbsp;</td>
          <td class="paramname"> <em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>url_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>cluster</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new node with its global identifier and url to connect If the global id as already been declared, the return value is the previously delcared node. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gid</em>&nbsp;</td><td>the global identifier of the new node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>url_peer</em>&nbsp;</td><td>the url of the added node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the node info of the new added node with a local id </dd></dl>

</div>
</div>
<a class="anchor" id="a145aa1304cf6b06f751dd70b0bfd9c1a"></a><!-- doxytag: member="Net::Network::add_route" ref="a145aa1304cf6b06f751dd70b0bfd9c1a" args="(NodeInfo *ni, OutChannel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::add_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a route to node If the same route exists to this node then it is not added. A same channel may declared as a route to several nodes. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ni</em>&nbsp;</td><td>the pointer to the node info structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>the new route to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a8a02260202d056bb72e7c5b4d579b2"></a><!-- doxytag: member="Net::Network::attach_iostream" ref="a7a8a02260202d056bb72e7c5b4d579b2" args="(IOInstructionStream *ios)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::attach_iostream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> *&nbsp;</td>
          <td class="paramname"> <em>ios</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attach an <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> to the process of sending message </p>

</div>
</div>
<a class="anchor" id="a569919daf3ea3bd1d0b88029410cfcb4"></a><!-- doxytag: member="Net::Network::begin_node" ref="a569919daf3ea3bd1d0b88029410cfcb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">const_iterator_node</a> Net::Network::begin_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the iterator over the first known node It is to the responsability of the caller to assure that the iteration is protected against concurrent modification of the set of node by locking the network object. </p>

</div>
</div>
<a class="anchor" id="aac2f09d4af9e7468962a276e134da64a"></a><!-- doxytag: member="Net::Network::begin_node" ref="aac2f09d4af9e7468962a276e134da64a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">iterator_node</a> Net::Network::begin_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the iterator over the first known node It is to the responsability of the caller to assure that the iteration is protected against concurrent modification of the set of node by locking the network object. </p>

</div>
</div>
<a class="anchor" id="a3d12d296ad8f55c9f17988fc8f4c9650"></a><!-- doxytag: member="Net::Network::close_route" ref="a3d12d296ad8f55c9f17988fc8f4c9650" args="(NodeInfo *ni, OutChannel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::close_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>close a route channel to ni This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>

</div>
</div>
<a class="anchor" id="a9c1f1ef003514d1c895ea59b6cb8eb0d"></a><!-- doxytag: member="Net::Network::close_routes" ref="a9c1f1ef003514d1c895ea59b6cb8eb0d" args="(NodeInfo *ni)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::close_routes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>close all routes channel to ni This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>

</div>
</div>
<a class="anchor" id="a89c257af540a06918dc35998eb674b67"></a><!-- doxytag: member="Net::Network::commit" ref="a89c257af540a06918dc35998eb674b67" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Network::commit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Second stage of initialization of a network Terminate the initialization process, accept incomming message and local node may send message to known hosts. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this method should be called from derived class to initialize data members </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidArgumentError</em>&nbsp;</td><td>bad parameters passed in properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RuntimeError</em>&nbsp;</td><td>kind of exception is thrown in case of error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade9985bddd27159d54ab67e3ebf15c4a"></a><!-- doxytag: member="Net::Network::count_nodes" ref="ade9985bddd27159d54ab67e3ebf15c4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Net::Network::count_nodes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the number of known node including myself This method is reentrant. </p>

</div>
</div>
<a class="anchor" id="a147b0c6fd905d3f516812aceaa1c1264"></a><!-- doxytag: member="Net::Network::deattach_iostream" ref="a147b0c6fd905d3f516812aceaa1c1264" args="(IOInstructionStream *ios)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::deattach_iostream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> *&nbsp;</td>
          <td class="paramname"> <em>ios</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deattach an <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a> from the process of sending message </p>

</div>
</div>
<a class="anchor" id="a73caf1dd96f2998e2312575c7dd15d67"></a><!-- doxytag: member="Net::Network::del_node" ref="a73caf1dd96f2998e2312575c7dd15d67" args="(NodeInfo *ni)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::del_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Del a node from the routing tables The invocation call supress all known route to this node. The channels associated to the routes are not close neither deallocated. The node info data structure should be deallocated using delete. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ni</em>&nbsp;</td><td>the node info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9effb562a16c39a2b91b3cd7f4e8f383"></a><!-- doxytag: member="Net::Network::del_route" ref="a9effb562a16c39a2b91b3cd7f4e8f383" args="(NodeInfo *ni, OutChannel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::del_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the route to the node info using the channel This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>the route to del </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89593d1ba8afa5cf140152bb2c876971"></a><!-- doxytag: member="Net::Network::del_routes" ref="a89593d1ba8afa5cf140152bb2c876971" args="(OutChannel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::del_routes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete all the routes to any node info using the channel This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>the route to del </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ca6e1b84c7de85c7601f61df3ebe8c6"></a><!-- doxytag: member="Net::Network::dump_info" ref="a0ca6e1b84c7de85c7601f61df3ebe8c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::dump_info </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump on std::cout (debug) </p>

</div>
</div>
<a class="anchor" id="aae041f337a3360205002b2a9496e11c9"></a><!-- doxytag: member="Net::Network::end_node" ref="aae041f337a3360205002b2a9496e11c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_network.html#a83a1dad097cac06ab8af48c9f94773d3">const_iterator_node</a> Net::Network::end_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the iterator over the past-the-last known node It is to the responsability of the caller to assure that the iteration is protected against concurrent modification of the set of node by locking the network object. </p>

</div>
</div>
<a class="anchor" id="a532b50a06ba168b7a09a3c432b395529"></a><!-- doxytag: member="Net::Network::end_node" ref="a532b50a06ba168b7a09a3c432b395529" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_network.html#ae99877e02d624ee69e8fe8d8aeaf5f0d">iterator_node</a> Net::Network::end_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the iterator over the past-the-last known node It is to the responsability of the caller to assure that the iteration is protected against concurrent modification of the set of node by locking the network object. </p>

</div>
</div>
<a class="anchor" id="ac863d2b6579a046cf333162d0e74ca22"></a><!-- doxytag: member="Net::Network::flush_channels" ref="ac863d2b6579a046cf333162d0e74ca22" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::flush_channels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flush all channel </p>

</div>
</div>
<a class="anchor" id="a56350a6570ef5b114edfde5ed8b4dcad"></a><!-- doxytag: member="Net::Network::get_default_local_route" ref="a56350a6570ef5b114edfde5ed8b4dcad" args="(Device *device, NodeInfo *ni)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>* Net::Network::get_default_local_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_device.html">Device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the route (channel) to send data to local node identifier using a specific device This method is reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object is locked during the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ni</em>&nbsp;</td><td>the node info </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the default route to reach the node or 0 if route doesnot exist </dd></dl>

</div>
</div>
<a class="anchor" id="a3e540196a8b34eb59d10dc5f2cda102d"></a><!-- doxytag: member="Net::Network::get_default_local_route" ref="a3e540196a8b34eb59d10dc5f2cda102d" args="(NodeInfo *ni)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>* Net::Network::get_default_local_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the route (channel) to send data to local node identifier This method is reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object is locked during the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ni</em>&nbsp;</td><td>the node info </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the default route to reach the node or 0 if route doesnot exist </dd></dl>

</div>
</div>
<a class="anchor" id="a37dcaf8c54e74c3cdfca717274ac8836"></a><!-- doxytag: member="Net::Network::get_device_for_this_cluster" ref="a37dcaf8c54e74c3cdfca717274ac8836" args="(const std::string &amp;clustername) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device.html">Device</a>* Net::Network::get_device_for_this_cluster </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clustername</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return default device for a cluster name in a hierarchy </p>

</div>
</div>
<a class="anchor" id="a2d541b3e4b2bd63709d0ecc463cec78a"></a><!-- doxytag: member="Net::Network::get_device_from_url" ref="a2d541b3e4b2bd63709d0ecc463cec78a" args="(const std::string &amp;url_peer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device.html">Device</a>* Net::Network::get_device_from_url </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>url_peer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the device of the address </p>

</div>
</div>
<a class="anchor" id="a9f762e2e596dbf84f5e97439e23df51e"></a><!-- doxytag: member="Net::Network::get_devicename_from_url" ref="a9f762e2e596dbf84f5e97439e23df51e" args="(const std::string &amp;url_peer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Net::Network::get_devicename_from_url </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>url_peer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the device name of the address </p>

</div>
</div>
<a class="anchor" id="aaedb47b037106231be10a5be40e12677"></a><!-- doxytag: member="Net::Network::get_id" ref="aaedb47b037106231be10a5be40e12677" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint8_t Net::Network::get_id </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the identifier of this type of <a class="el" href="class_net_1_1_network.html">Network</a> used to identify network </p>

<p>Reimplemented from <a class="el" href="class_util_1_1_object_id.html#a6d599f3e2e4e53408b60e9a82a4e4b42">Util::ObjectId</a>.</p>

</div>
</div>
<a class="anchor" id="a9acd8a037d8fcefb0dd2692e6c04f0df"></a><!-- doxytag: member="Net::Network::get_leader_for_this_cluster" ref="a9acd8a037d8fcefb0dd2692e6c04f0df" args="(const std::string &amp;clustername)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>* Net::Network::get_leader_for_this_cluster </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clustername</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return default leader for this cluster name in a hierarchy </p>

</div>
</div>
<a class="anchor" id="a23061412c684b1661ff37bf270364ad2"></a><!-- doxytag: member="Net::Network::get_name" ref="a23061412c684b1661ff37bf270364ad2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Net::Network::get_name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the network. This method equivalent to calling 'get_property("name")'. </p>

</div>
</div>
<a class="anchor" id="a74ef9b808cea5532adf31656aca64b97"></a><!-- doxytag: member="Net::Network::get_urlconnect" ref="a74ef9b808cea5532adf31656aca64b97" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Net::Network::get_urlconnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_util_1_1_i_o_error.html">IOError</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the url to be broadcast if other node want to connect to this node </p>

</div>
</div>
<a class="anchor" id="a90274f393b63b22c5bd70729978b6718"></a><!-- doxytag: member="Net::Network::globalid_to_nodeinfo" ref="a90274f393b63b22c5bd70729978b6718" args="(GlobalId gid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>* Net::Network::globalid_to_nodeinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_global_id.html">GlobalId</a>&nbsp;</td>
          <td class="paramname"> <em>gid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the node information from its global identifier This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gid</em>&nbsp;</td><td>the global id of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the node info structure if the node is known or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc46e69e455659258eb9fd0b3b8063f"></a><!-- doxytag: member="Net::Network::initialize" ref="a1cc46e69e455659258eb9fd0b3b8063f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Network::initialize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First stage of initialization of a network Remark: All recognized arguments are deleted from the command line </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>On return the network is not necessarily initilized. </dd>
<dd>
A call to commit must be performed to terminate the initilialization This function is called should to initialize a secondary network. It is automatically called at initilization of the network layer for each secondary network. At the end of the first stage of initialisation, all local initializations are done, but communication may failed to reach other node. </dd>
<dd>
this method should be called from derived class to initialize data members </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidArgumentError</em>&nbsp;</td><td>bad parameters passed in properties </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RuntimeError</em>&nbsp;</td><td>kind of exception is thrown in case of error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_util_1_1_object.html#a5c586b3aab6eee1a05d0374b9592e18f">Util::Object</a>.</p>

</div>
</div>
<a class="anchor" id="af0234b8edf1f6a01f086f644a6d26867"></a><!-- doxytag: member="Net::Network::is_a_leader" ref="af0234b8edf1f6a01f086f644a6d26867" args="(const Util::GlobalId &amp;gid, const std::string &amp;clustername) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Net::Network::is_a_leader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_global_id.html">Util::GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clustername</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the ni is leader of the cluster </p>

</div>
</div>
<a class="anchor" id="a8f63e058a7a5189362de19f714ac0f76"></a><!-- doxytag: member="Net::Network::is_leader" ref="a8f63e058a7a5189362de19f714ac0f76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Net::Network::is_leader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the local process is leader of its cluster </p>

</div>
</div>
<a class="anchor" id="a01ea1b5625cb6c012fdf09bab137b512"></a><!-- doxytag: member="Net::Network::localid_to_nodeinfo" ref="a01ea1b5625cb6c012fdf09bab137b512" args="(ka_uint16_t lid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>* Net::Network::localid_to_nodeinfo </td>
          <td>(</td>
          <td class="paramtype">ka_uint16_t&nbsp;</td>
          <td class="paramname"> <em>lid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the node information from its local identifier The method allocates a new local id for the given node if it is not known. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lid</em>&nbsp;</td><td>the local identifier of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the node info structure if the node is known or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="aeb8c33fa08b8759c540f5bd5dfce9006"></a><!-- doxytag: member="Net::Network::notify" ref="aeb8c33fa08b8759c540f5bd5dfce9006" args="(ComFailure::Code error_no, OutChannel *ch, Header *header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_header.html">Header</a> *&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Method call on the client side when disconnection appears Inherited from <a class="el" href="class_net_1_1_callback.html">Callback</a> </p>

<p>Implements <a class="el" href="class_net_1_1_callback.html#aba70566eab9ea25e04671f5ec34d997f">Net::Callback</a>.</p>

</div>
</div>
<a class="anchor" id="a5c36226132c8c991a8c109b8802ac081"></a><!-- doxytag: member="Net::Network::notify" ref="a5c36226132c8c991a8c109b8802ac081" args="(ComFailure::Code error_no, InChannel *ch, CallStack *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Method call on the server side when disconnection appears Inherited from <a class="el" href="class_net_1_1_upcall.html">Upcall</a> </p>

<p>Implements <a class="el" href="class_net_1_1_upcall.html#ab77233ca34f008c05b1431363ed6c900">Net::Upcall</a>.</p>

</div>
</div>
<a class="anchor" id="a3c9df0e70c3196968a09da993b18a46c"></a><!-- doxytag: member="Net::Network::notify" ref="a3c9df0e70c3196968a09da993b18a46c" args="(ComFailure::Code error_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Method call on the server side when disconnection appears Inherited from <a class="el" href="class_util_1_1_callback.html">Util::Callback</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_callback.html#a9ac08165e43ae8373367c7bd131d3bbd">Net::Callback</a>.</p>

</div>
</div>
<a class="anchor" id="a2163516065b9456ac1444c2bed8a15cb"></a><!-- doxytag: member="Net::Network::open_route" ref="a2163516065b9456ac1444c2bed8a15cb" args="(NodeInfo *ni, const std::string &amp;url)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a>* Net::Network::open_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>url</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>open a route to ni using url as connection address May return an existing route. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>

</div>
</div>
<a class="anchor" id="ade00d4ff727d4a66b56c7dd84d2499e8"></a><!-- doxytag: member="Net::Network::print_node" ref="ade00d4ff727d4a66b56c7dd84d2499e8" args="(std::ostream &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Net::Network::print_node </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print routing nodes information </p>

</div>
</div>
<a class="anchor" id="a92549b2d8f88b9ad728e95c617faff2c"></a><!-- doxytag: member="Net::Network::print_route" ref="a92549b2d8f88b9ad728e95c617faff2c" args="(std::ostream &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Net::Network::print_route </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print routing routes information </p>

</div>
</div>
<a class="anchor" id="aa9357f70c2456ab6629692eeba2fe921"></a><!-- doxytag: member="Net::Network::register_cluster" ref="aa9357f70c2456ab6629692eeba2fe921" args="(Cluster *cluster, const std::string &amp;clusterpath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::register_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_cluster.html">Cluster</a> *&nbsp;</td>
          <td class="paramname"> <em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clusterpath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register the cluster object with its clusterpath This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clusterpath</em>&nbsp;</td><td>the name of the cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the node info of the new added node with a local id </dd></dl>

</div>
</div>
<a class="anchor" id="ad2d6b9a77e5fba4845f651d89c55fd1a"></a><!-- doxytag: member="Net::Network::resolve_cluster" ref="ad2d6b9a77e5fba4845f651d89c55fd1a" args="(const std::string &amp;clusterpath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_cluster.html">Cluster</a>* Net::Network::resolve_cluster </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clusterpath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cluster object with clustername If the object does not exist allocate it and register it. This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clustername</em>&nbsp;</td><td>the name of the cluster </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the node info of the new added node with a local id </dd></dl>

</div>
</div>
<a class="anchor" id="a79ec0beb46292d6e30f3e7f1e003b4d9"></a><!-- doxytag: member="Net::Network::resolve_nodeinfo" ref="a79ec0beb46292d6e30f3e7f1e003b4d9" args="(GlobalId gid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_node_info.html">Network::NodeInfo</a>* Net::Network::resolve_nodeinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_global_id.html">GlobalId</a>&nbsp;</td>
          <td class="paramname"> <em>gid</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the node information from its global identifier This method lock the <a class="el" href="class_net_1_1_network.html">Network</a> object. If not found, try it will ask to the nameserver. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gid</em>&nbsp;</td><td>the global id of the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the node info structure if the node is known or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="af71fecf796b74bfe1a1ad73d59eaf37d"></a><!-- doxytag: member="Net::Network::set_callback" ref="af71fecf796b74bfe1a1ad73d59eaf37d" args="(Callback *new_callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_callback.html">Callback</a>* Net::Network::set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_callback.html">Callback</a> *&nbsp;</td>
          <td class="paramname"> <em>new_callback</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new <a class="el" href="class_net_1_1_callback.html">Callback</a> object to forward callback from network </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_callback</em>&nbsp;</td><td>the new object used to forward callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the previous callback object </dd></dl>

</div>
</div>
<a class="anchor" id="ab8007c4d359d95f27156c65827692d36"></a><!-- doxytag: member="Net::Network::set_default_local_route" ref="ab8007c4d359d95f27156c65827692d36" args="(NodeInfo *ni, OutChannel *ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::set_default_local_route </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_node_info.html">NodeInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a channel as a default channel to the destination to the local node identifier This method is not reentrant and the <a class="el" href="class_net_1_1_network.html">Network</a> object may be locked before the invocation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ni</em>&nbsp;</td><td>the node info </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>the default route to define for the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace11b07a5276a3eb93b5b18b49b14837"></a><!-- doxytag: member="Net::Network::set_leader_for_this_cluster" ref="ace11b07a5276a3eb93b5b18b49b14837" args="(const Util::GlobalId &amp;gid, const std::string &amp;clustername)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::set_leader_for_this_cluster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_util_1_1_global_id.html">Util::GlobalId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>gid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>clustername</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the default leader for this cluster name in a hierarchy </p>

</div>
</div>
<a class="anchor" id="af0367a07e532a6cd84ee1bb61389a5dc"></a><!-- doxytag: member="Net::Network::set_name" ref="af0367a07e532a6cd84ee1bb61389a5dc" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Net::Network::set_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the name of the network. This method equivalent to calling 'set_property("name")'. </p>

</div>
</div>
<a class="anchor" id="a8bfd9e2bb5f1611c797f965095dacd9a"></a><!-- doxytag: member="Net::Network::set_upcall" ref="a8bfd9e2bb5f1611c797f965095dacd9a" args="(Upcall *new_upcall)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_upcall.html">Upcall</a>* Net::Network::set_upcall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_net_1_1_upcall.html">Upcall</a> *&nbsp;</td>
          <td class="paramname"> <em>new_upcall</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new upcall object to forward upcall from network </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_upcall</em>&nbsp;</td><td>the new object used to forward upcall </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the previous upcall object </dd></dl>

</div>
</div>
<a class="anchor" id="aca4e5df35e3f5ad518b37c41021973f4"></a><!-- doxytag: member="Net::Network::signal" ref="aca4e5df35e3f5ad518b37c41021973f4" args="(ComFailure::Code error_no, OutChannel *ch, Header *header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_out_channel.html">OutChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_header.html">Header</a> *&nbsp;</td>
          <td class="paramname"> <em>header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signal event to the upcall object associated with the network Override the definition of <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Upcall::signal</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_callback.html#a4700e876d0b4621c9d7f6f182394cc49">Net::Callback</a>.</p>

</div>
</div>
<a class="anchor" id="a6b76206209f3fff3a2e78d95ac2cef08"></a><!-- doxytag: member="Net::Network::signal" ref="a6b76206209f3fff3a2e78d95ac2cef08" args="(ComFailure::Code error_no, InChannel *ch, CallStack *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_util_1_1_com_failure.html#a764e8dfecee4130ac320079858f6978f">ComFailure::Code</a>&nbsp;</td>
          <td class="paramname"> <em>error_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_in_channel.html">InChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_net_1_1_call_stack.html">CallStack</a> *&nbsp;</td>
          <td class="paramname"> <em>cc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signal event to the upcall object associated with the network Override the definition of <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Upcall::signal</a> </p>

<p>Reimplemented from <a class="el" href="class_net_1_1_upcall.html#a69ef342b6de1e72b50b782e9168fd307">Net::Upcall</a>.</p>

</div>
</div>
<a class="anchor" id="af6bda4dc882254c8f0ebf4ac9379011e"></a><!-- doxytag: member="Net::Network::terminate" ref="af6bda4dc882254c8f0ebf4ac9379011e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Net::Network::terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_util_1_1_runtime_error.html">RuntimeError</a>)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate a network This function is automatically called at termination of the network layer for each network. </p>

<p>Reimplemented from <a class="el" href="class_util_1_1_object.html#ac56dc69161e667fec85e1565509c08ac">Util::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a56d245562fa16f87d37c416ccb0c6b51"></a><!-- doxytag: member="Net::Network::wakeup_iodaemon" ref="a56d245562fa16f87d37c416ccb0c6b51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Net::Network::wakeup_iodaemon </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wakeup <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a> </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a8ab3cf206ea4374251e7da0f6a38fb67"></a><!-- doxytag: member="Net::Network::IODaemon" ref="a8ab3cf206ea4374251e7da0f6a38fb67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acb1172fca541ea3cf6a9363dbbbad057"></a><!-- doxytag: member="Net::Network::IOInstructionStream" ref="acb1172fca541ea3cf6a9363dbbbad057" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_net_1_1_i_o_instruction_stream.html">IOInstructionStream</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7d470e79e54736088d00564e404e3620"></a><!-- doxytag: member="Net::Network::_all_clusters" ref="a7d470e79e54736088d00564e404e3620" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_net_1_1_cluster.html">Cluster</a>*&gt; <a class="el" href="class_net_1_1_network.html#a7d470e79e54736088d00564e404e3620">Net::Network::_all_clusters</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5601e595078dda4244f34b77f9e4ad15"></a><!-- doxytag: member="Net::Network::_callback" ref="a5601e595078dda4244f34b77f9e4ad15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_callback.html">Callback</a>* <a class="el" href="class_net_1_1_network.html#a5601e595078dda4244f34b77f9e4ad15">Net::Network::_callback</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>object to forward callback, default is the network object </p>

</div>
</div>
<a class="anchor" id="a44db41913d6c1674130c9c6d6758e0aa"></a><!-- doxytag: member="Net::Network::_cluster" ref="a44db41913d6c1674130c9c6d6758e0aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_net_1_1_cluster.html">Cluster</a>*&gt; <a class="el" href="class_net_1_1_network.html#a44db41913d6c1674130c9c6d6758e0aa">Net::Network::_cluster</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>known clusters </p>

</div>
</div>
<a class="anchor" id="ac1bbae6b663fd89d1a2f383597795e6a"></a><!-- doxytag: member="Net::Network::_count_nodes" ref="ac1bbae6b663fd89d1a2f383597795e6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_net_1_1_network.html#ac1bbae6b663fd89d1a2f383597795e6a">Net::Network::_count_nodes</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of nodes </p>

</div>
</div>
<a class="anchor" id="a4e8ee55314511cf341340c6e7dc3bcd4"></a><!-- doxytag: member="Net::Network::_default_device" ref="a4e8ee55314511cf341340c6e7dc3bcd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_device.html">Device</a>* <a class="el" href="class_net_1_1_network.html#a4e8ee55314511cf341340c6e7dc3bcd4">Net::Network::_default_device</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default device. </p>

</div>
</div>
<a class="anchor" id="a214f1f7409673a9b2bca49f4532d0ae9"></a><!-- doxytag: member="Net::Network::_free_lid_entries" ref="a214f1f7409673a9b2bca49f4532d0ae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;ka_uint16_t&gt; <a class="el" href="class_net_1_1_network.html#a214f1f7409673a9b2bca49f4532d0ae9">Net::Network::_free_lid_entries</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>list of free entries in _known_nodes </p>

</div>
</div>
<a class="anchor" id="a35c5ec8aa070b43fe234969f77affc6a"></a><!-- doxytag: member="Net::Network::_gid2nodes" ref="a35c5ec8aa070b43fe234969f77affc6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_util_1_1_global_id.html">GlobalId</a>,<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>*&gt; <a class="el" href="class_net_1_1_network.html#a35c5ec8aa070b43fe234969f77affc6a">Net::Network::_gid2nodes</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>global to nodeinfo lookup table </p>

</div>
</div>
<a class="anchor" id="a41fb366d4be2babe3d38f48ce8878279"></a><!-- doxytag: member="Net::Network::_iodaemon" ref="a41fb366d4be2babe3d38f48ce8878279" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_i_o_daemon.html">IODaemon</a>* <a class="el" href="class_net_1_1_network.html#a41fb366d4be2babe3d38f48ce8878279">Net::Network::_iodaemon</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a507c94607f3ed02fa1f63c003e4a0f51"></a><!-- doxytag: member="Net::Network::_known_nodes" ref="a507c94607f3ed02fa1f63c003e4a0f51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_net_1_1_node_info.html">NodeInfo</a>*&gt; <a class="el" href="class_net_1_1_network.html#a507c94607f3ed02fa1f63c003e4a0f51">Net::Network::_known_nodes</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>known nodes from local id </p>

</div>
</div>
<a class="anchor" id="a98c10d69e31250864883c0d1e08f1a8c"></a><!-- doxytag: member="Net::Network::_leaders" ref="a98c10d69e31250864883c0d1e08f1a8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_util_1_1_global_id.html">GlobalId</a>&gt; <a class="el" href="class_net_1_1_network.html#a98c10d69e31250864883c0d1e08f1a8c">Net::Network::_leaders</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>known clusters </p>

</div>
</div>
<a class="anchor" id="a9a3e0cc31330e95ac7835102856afb10"></a><!-- doxytag: member="Net::Network::_name" ref="a9a3e0cc31330e95ac7835102856afb10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_net_1_1_network.html#a9a3e0cc31330e95ac7835102856afb10">Net::Network::_name</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name of the network. </p>

</div>
</div>
<a class="anchor" id="aa2d5eef7e14b57a3c86661d5223aafca"></a><!-- doxytag: member="Net::Network::_next_lid" ref="aa2d5eef7e14b57a3c86661d5223aafca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint16_t <a class="el" href="class_net_1_1_network.html#aa2d5eef7e14b57a3c86661d5223aafca">Net::Network::_next_lid</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>next local id for a node </p>

</div>
</div>
<a class="anchor" id="aa834f0ee2967ae879632fff1b9a3e9a0"></a><!-- doxytag: member="Net::Network::_nid" ref="aa834f0ee2967ae879632fff1b9a3e9a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ka_uint8_t <a class="el" href="class_net_1_1_network.html#aa834f0ee2967ae879632fff1b9a3e9a0">Net::Network::_nid</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>id of the network instance </p>

</div>
</div>
<a class="anchor" id="ae7d63901cc55a75e61416670605b79f7"></a><!-- doxytag: member="Net::Network::_upcall" ref="ae7d63901cc55a75e61416670605b79f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_upcall.html">Upcall</a>* <a class="el" href="class_net_1_1_network.html#ae7d63901cc55a75e61416670605b79f7">Net::Network::_upcall</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>all the clusters </p>
<p>object to forward upcall, default is the network object </p>

</div>
</div>
<a class="anchor" id="a9e7f5676dc2a27a7210bbf3b537e8b15"></a><!-- doxytag: member="Net::Network::cluster" ref="a9e7f5676dc2a27a7210bbf3b537e8b15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_cluster.html">Cluster</a>* <a class="el" href="class_net_1_1_network.html#a9e7f5676dc2a27a7210bbf3b537e8b15">Net::Network::cluster</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The cluster for the running process. </p>

</div>
</div>
<a class="anchor" id="aee4527b16b6e4c285d3902b4baf44a81"></a><!-- doxytag: member="Net::Network::clustername" ref="aee4527b16b6e4c285d3902b4baf44a81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_net_1_1_network.html#aee4527b16b6e4c285d3902b4baf44a81">Net::Network::clustername</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name of the cluster for this process. </p>

</div>
</div>
<a class="anchor" id="adda8e3582eb2c017ce5ac9caf95d8adc"></a><!-- doxytag: member="Net::Network::parentcluster" ref="adda8e3582eb2c017ce5ac9caf95d8adc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_cluster.html">Cluster</a>* <a class="el" href="class_net_1_1_network.html#adda8e3582eb2c017ce5ac9caf95d8adc">Net::Network::parentcluster</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The cluster for the running process and its brothers. </p>

</div>
</div>
<a class="anchor" id="a77c36a0ebc1a94b2f9af542f11db0d52"></a><!-- doxytag: member="Net::Network::rootcluster" ref="a77c36a0ebc1a94b2f9af542f11db0d52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_net_1_1_cluster.html">Cluster</a>* <a class="el" href="class_net_1_1_network.html#a77c36a0ebc1a94b2f9af542f11db0d52">Net::Network::rootcluster</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The root cluster of the whole computation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="network__network_8h.html">network_network.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 08:52:45 2010 for Kaapi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

<html lang="en">
<head>
<title>arrays through iterators - kaapi</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="kaapi">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="sharing-arrays.html#sharing-arrays" title="sharing arrays">
<link rel="prev" href="arrays-through-verctors.html#arrays-through-verctors" title="arrays through verctors">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for KAAPI (version 2.4.1, 16 June 2010),
Hyantes is free software; you can redistribute it and/or modify
it under the terms of the GPL License

Copyright (C) 2007 LIG-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
pre, hr, code, .file, .command, .option, h1, h2, h3, h4, h5 { color: #007676; }
pre { border:thin dashed #808080; }

pre {
    padding:2px;
    margin-left:2%;
    width:90%;
}

address {
    margin-left:1%;
}

div.contents {
    border-left:thin dashed #808080;
    margin-left:1%;
}

code, .command, .option {
    font-size:100%;
    /*border:thin dashed #808080;*/
    font-family:monospace;
    font-weight:bolder;
    padding:2px;
}

.node {
    font-size:70%;
}


a:link, a:visited, a:hover {
	color: #666666;
}

a.download:before {
    content:url(download.png);
}
/*
p a:before {
    content:url(url.png)
}
*/
dt:before {
    content:url(circle.png);
}

body {
  font-family: arial, serif;
  background-color: #ffffff;
  margin: 0px auto 10px auto;
  padding: 0px;
}

p, dl {
    margin: 5px 10px 10px 10px;
	line-height: 130%;
}

ul li {
  margin: 5px 0px 5px 0px;
}

h1 {
    font-size:200%;
    font-variant:small-caps;
    margin: 10px 10px 10px 10px;
    text-align: center;
}

h2 {
    font-variant:small-caps;
	font-size: 110%;
    margin: 10px 10px 5px 2px;
}

h3 {
	font-size: 100%;
    margin: 10px 10px 5px 4px;
}
h4 {
	font-size: 100%;
    margin: 10px 10px 5px 6px;
}
h5 {
	font-size: 100%;
    margin: 10px 10px 5px 8px;
}

.menu {
  margin-top: 5px;
  margin-bottom: 15px;
  list-style-image: url("arrow.png");
}
	

ul {
  margin-top: 5px;
  margin-bottom: 15px;
  list-style-image: url("arrow.png");
}

hr {
  border: 1;
  width: 80%;
  text-align:left;
}

--></style>
</head>
<body>
<div class="node">
<a name="arrays-through-iterators"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="arrays-through-verctors.html#arrays-through-verctors">arrays through verctors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="sharing-arrays.html#sharing-arrays">sharing arrays</a>
<hr>
</div>

<h5 class="subsubsection">4.4.2.3 Arrays through iterators</h5>

<p>A remote iterator is a communicable type used to keep the reference of an array across the network, thus allowing access to large amount of remote data. 
This does not provide any synchronization as a Shared does, so you have to manage dependencies using other means (usually a fake Shared dependencie).

   <p>To use remote iterators, you first declare them, and then init them from a local data
<pre class="example">     int array[256];
     // for read-write access
     a1::remote&lt;int*&gt; begin, end;
     a1::init(begin, end, array, array + 256);
     // for read only access
     a1::const_remote&lt;int*&gt; cbegin, cend;
     a1::init(cbegin, cend, array, array + 256);
</pre>
   <p>The <code>const_remote</code> class will give you a read-only iterator, while the <code>remote</code> class will give you read-write access.

   <p>You can now use the remote iterators as you would use random access iterators : incrementation, copy, dereferencing and so on is allowded. 
Of course those iterator can be used as arguments of any STL algoroithm as native iterator would. 
They have the Random access iterator tag. 
As they are communicable, you can pass them as parameters to an athapascan'task.

   <p>To get a reference on data pointed by the iteratore, you must first ensure a copy of the real data is available on your local machine. 
You must do so using the <code>fetch</code> function :
Not using the fetch function may result in a SEGFAULT, for you're trying to access data that may not exist in memory.

<pre class="example">     struct task
     {
         void operator() ( a1::remote&lt;int*&gt; b, a1::remote&lt;int*&gt; e)
         {
             size_t n = e -b;
             if( n &lt; 4)
             {
                 a1::fetch(b,e);
                 while(b&lt;e)
                     std::cout &lt;&lt; *b++ &lt;&lt; std::endl;
             }
             else
             {
                 a1::Fork&lt;task&gt;()( b, b+n/2);
                 a1::Fork&lt;task&gt;()( b +n/2, e);
             }
         }
     };
</pre>
   <p>No guarantee is given if the split overrides. Try to avoid it. 
The detailed interface is given in <a href="API.html#API">API</a>.

<!--  -->
   </body></html>


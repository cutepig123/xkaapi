\documentclass[a4paper, 11pt]{article}

\usepackage{graphicx}
\usepackage{graphics}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{RR}
\usepackage{hyperref}

%%\usepackage[frenchb]{babel} % optionnel
%%
%% date de publication du rapport
\RRdate{November 2011}
%%
%% Cas d'une version deux
%% \RRversion{2}
%% date de publication de la version 2
%% \RRdater{Novembre  2006}
\usepackage{listings}

\usepackage{amssymb}
\usepackage{xspace} 
\usepackage{array} 
\usepackage{multirow}
\newcommand\hyph{\nobreak\hskip0pt-\nobreak\hskip0pt\relax}
\newlength\savedwidth
\newcommand\whline{\noalign{\global\savedwidth
  \arrayrulewidth\global\arrayrulewidth 1.5pt}
  \hline \noalign{\global\arrayrulewidth
  \savedwidth}
}
\newcolumntype{I}{!{\vrule width 1.5pt}}
\renewcommand{\arraystretch}{1.5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{commentstyle=\color{blue}}
\lstset{language=C}
\lstset{stringstyle=\ttfamily}
\lstset{ classoffset=1
           }
\lstset{ classoffset=2 
           }
\lstset{ classoffset=3
           }
\lstset{classoffset=0, showstringspaces=false}

\lstnewenvironment{code}{%
  \small%
  \lstset{commentstyle=\color{blue}}%
  \lstset{language=C}%
  \lstset{frame=tb}%
}{%
}
\makeatletter
\newcommand{\apirefp}[2][\@empty]{%
  \def\api@part{#1}%
  \def\api@partref{\@empty}%
  \ifx\api@part\api@partref%
    \def\api@lab{api@#2}%
  \else%
    \def\api@lab{api@#2@#1}%
  \fi%
  \expandafter\ref\expandafter{\api@lab} on page \pageref{\api@lab}%
}
\newenvironment{apisection}[2][noshortnameprovided]{%
  % 1: section short name (for ref)
  % 2: section name
  \newpage
  \section{#2}
  \label{api@#1}
  \newcommand{\api@newpart}[4][noshortpartnameprovided]{%
    \newenvironment{##1}{%
      \subsection{##2}%
      \label{api@#1@##1}%
      ##3%
    }{##4}%
  }%
  \api@newpart[synopsis]{Synopsis}{}{}%
  \api@newpart[desc]{Description}{}{}%
  \api@newpart[params]{Parameters}{%
    \let\api@indesc\@empty
    \newcommand{\param}[1]{%r
      \def\api@indesc{yes}%
      \begin{description}%
        \renewcommand{\param}[1]{\item[########1]}%
      \item[####1]
      }%
      %\bgroup%
      \newenvironment{parameters}{%
        \begin{description}%
          \renewcommand{\param}[1]{\item[########1]}%
        }{%
        \end{description}%
      }
    }{%
      %\egroup%
      \ifx\api@indesc\@empty\relax\else%
    \end{description}%
    \fi%
  }%
  \api@newpart[ret]{Return value}{%
    \newcommand{\otherret}{\par\medskip\noindent}%
  }{}%
  \api@newpart[example]{Example}{}{}%
}{}
\makeatother

\newcommand{\fn}[1]{\textit{#1}}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\kaapi}{\textsc{X-Kaapi}\xspace}

%%% For all listing figures
\definecolor{MyDarkBlue}{rgb}{0.254901960784314, 0.411764705882353, 0.882352941176471}


\RRdate{November 2011}

%%
\RRauthor{
Fabien Le Mentec
  \and
Vincent Danjean
  \and
Thierry Gautier
}

\authorhead{Gautier \& Danjean \& Le Mentec}
\RRtitle{\kaapi C programming interface}
\RRetitle{\kaapi C programming interface}
\titlehead{\kaapi C programming interface}

\RRabstract{This report defines the \kaapi C programming interface.
}
\RRresume{The rapport décrit l'interface de programmation C pour \kaapi
}

\RRmotcle{calcul parallel, \kaapi, C}
\RRkeyword{parallel computing, \kaapi, C}
\RRprojets{MOAIS}
\RRdomaine{3} % cas du domaine numero 1
\RRthemeProj{moais} % theme du projet Apics
\RCGrenoble % Grenoble - Rh\^one-Alpes

\begin{document}

% \makeRR % cas d'un rapport de recherche
\makeRT % cas d'un rapport technique.

\tableofcontents
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}

\newpage
\section{Software installation}\label{sec:userinstall}

\kaapi is both a programming model and a runtime for high performance parallelism targeting multicore and distributed architectures. 
It relies on the work stealing paradigm.
\kaapi was developed in the MOAIS INRIA project by Thierry Gautier, Fabien Le Mentec, Vincent Danjean, and Christophe Laferrière in the early stage of the library.

In this report, only the programming model based on the C API is presented.
The runtime library also comes with a full set of complementary programming interfaces: C, C++, and STL-like interfaces. The C++ and STL interfaces, at a higher level than the C interface, may be directly used for developing parallel programs or libraries.

\subsubsection*{Supported Platforms}
\kaapi targets essentially SMP and NUMA platforms. The runtime should run
on any system providing:
\begin{itemize}
\item a GNU toolchain ($\textrm{GCC} \ge 4.3$),
\item the pthread library,
\item Unix based environment.
\end{itemize}
It has been extensively tested on the following operating systems:
\begin{itemize}
\item GNU-Linux with x86\_64 architectures,
\item MacOSX/Intel processor.
\end{itemize}

There is no version for Windows yet.

\subsubsection*{\kaapi Contacts}
If you wish to contact the XKaapi team, please visite the web site at:
\begin{center}
\url{http://kaapi.gforge.inria.fr}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[init]{Initialization and termination}
  \begin{synopsis}%
    \begin{code}
int kaapic_init(int flags)
int kaapic_finalize(void)      
     \end{code}
  \end{synopsis}
  \begin{desc}
    \fn{kaapic\_init} initializes the runtime. 
    It must be called  by the program before using any of the other routines. 
    If successful, there must be a
    corresponding \fn{kaapic\_finalize} at the end of the program.
  \end{desc}
  \begin{params}
    \param{flags} if not zero, only start the main thread to avoid
    disturbing the execution until tasks are actually scheduled. The
    other threads are suspended waiting for a parallel region to be
    entered (refer to kaapic\_begin\_parallel in part
    \apirefp{parallel}).
  \end{params}
  \begin{ret}
    \begin{itemize}
    \item [0] in case of success
    \item [else] an error code
    \end{itemize}
  \end{ret}
  \begin{example}
    \begin{code}
  int main()
  {
    int err = kaapic_init(1);

    ...

    kaapic_finalize();
  }      
    \end{code}
  \end{example}
\end{apisection}

%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[concurrency]{Concurrency}

  \begin{synopsis}
    \begin{code}
int kaapic_get_concurrency(void)
int kaapic_get_thread_num(void)
    \end{code}
  \end{synopsis}
  \begin{desc}
    Concurrency related routines.
  \end{desc}
  \begin{ret}
    \fn{kaapic\_get\_concurrency} returns the number of parallel
    threads available to the \kaapi runtime.

    \otherret
    \fn{kaapic\_get\_thread\_num} returns the current thread
    identifier. Note it should only be called in the context of a
    \kaapi thread.
  \end{ret}
  \begin{example}
    \begin{code}
  int main()
  {
    int err = kaapic_init(1);

   printf("#available threads: %i\n", 
      kaapic_get_concurrency() );
   printf("My thread identifier is: %i\n", 
      kaapic_get_thread_num() );
    ...

    kaapic_finalize();
  }
    \end{code}
  \end{example}
\end{apisection}


%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[perf]{Performance}
  \begin{synopsis}
    \begin{code}
double kaapic_get_time(void)
    \end{code}
  \end{synopsis}
  \begin{desc}
    Capture the current time. Used to measure the time spent in a code
    region.
  \end{desc}
  \begin{params}
    None.
  \end{params}
  \begin{ret}
    Time in seconds since an arbitrary time in the past.
  \end{ret}
  \begin{example}
    \begin{code}
  int main() {
    double start, stop;
    int err = kaapic_init(1);
    start = kaapi_get_time();
    ...
    stop = kaapi_get_time();

    printf("Time : %f (s)\n", stop-start );
    kaapic_finalize();
  }
    \end{code}
  \end{example}
\end{apisection}

%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[loop]{Independent loops}

  \begin{synopsis}
    \begin{code}
int kaapic_foreach( 
  int first, 
  int last,
  kaapic_foreach_attr_t* attr,
  int32_t nparam,
  ...
 ) 

int kaapic_foreach_withformat( 
  int first, 
  int last,
  kaapic_foreach_attr_t* attr,
  int32_t nparam,
  ...
 ) 
    \end{code}
  \end{synopsis}

  \begin{desc}
    Those routines run a parallel loop over the range [\textit{first},
    \textit{last})\footnote{ This is an \textbf{exclusive} interval in
      the C interface and an \textbf{inclusive} interval in the
      Fortran interface.}  The loop is given as function with its
    parameters. The body function has \textit{nparam} parameters and
    it is passed in the \textit{...} optional effective parameter list
    of the foreach interface.

    At runtime, the initial interval is dynamically split in $K$
    disjoint intervals $[b_i, e_i)$ such that $\cup_{i=0..K-1} [b_i,
    e_i) = [first, last)$. The \kaapi threads call \textit{body(
      $b_i$, $e_i$, tid, $e_0$, ..., $e_{nparam-1}$)} for each of
    these sub-intervals. Hence, \textit{tid} is the thread identifier
    of the thread that makes the call. And the different calls can
    occur in parallel if they are done by different threads.

    \textit{attr} is a pointer to an attribute that can be
    pass tuning parameter to the runtime. It should be null for now,
    until future extensions are developed and stabilized.
  \end{desc}

  \begin{params}
    For \fn{kaapi\_foreach} interface, the format of the optional
    parameter list is:
    \begin{parameters}
    \param{body} the function with signature\\
      \hspace*{5ex}\textit{void (*)(int, int, int [,type$_0$, .., type$_{nparam-1}$])}.\\
      Each type \textit{type$_i$} could be:
      \begin{itemize}
      \item a pointer to a memory data
      \item a scalar value with size equal to the size of a pointer.
      \end{itemize}
    
      \param{$e_0$} first effective parameter passed to \fn{body}.
      \param{\ldots}
      \param{$e_{nparam-1}$} last effective parameters passed to
      \fn{body}.
    \end{parameters}
    
  
    For \fn{kaapi\_foreach\_with\_format} interface extend
    \fn{kaapi\_foreach} interface in order to pass the size, the type
    and the access mode of each of the effective parameter. The format
    of the optional parameter list is:
    \begin{parameters}
    \param{body} the function with signature\\
      \hspace*{5ex}\textit{void (*)(int, int, int [,type$_0$, .., type$_{nparam-1}$])}.\\
      Each type \textit{type$_i$} could be:
      \begin{itemize}
      \item a pointer to a memory data
      \item a scalar value with size equal to the size of a pointer.
      \end{itemize}
      
    \param{mode, $e_0$, count, type} access mode, first effective
      parameter passed to \fn{body}, the number of type elements pointed
      by $e_0$ and the type of each element.
    \param{\ldots}
    \param{mode, $e_{nparam-1}$, count, type} access mode, last
      effective parameter passed to \fn{body}, the number of type
      elements pointed by $e_{nparam-1}$ and the type of each element.
    \end{parameters}
    Please refer to the data flow programming section
    (\apirefp{dataflow}) to have a description of \textit{mode} and
    \textit{type} informations.
  \end{params}

  \begin{ret}
    In case of success the function return 0, else it returns an error
    code.
  \end{ret}
  \begin{example}
    Refer to examples/kaapic subdirectory in sources\\

    \begin{code}
  /* loop body */
  static void body(
    int i, int j, int tid, double* array, double* value
  ) 
  {
    int k;
    for (k = i; k < j; ++k)
      array[k] += *value;
  }

  int main()
  {
    double* array;
    double value;
    int err = kaapic_init(1);
    start = kaapi_get_time(); 
    /* apply body on array[0..size-1] */
    kaapic_foreach( 0, size, 2, body, array, &value );
    stop = kaapi_get_time(); 

    printf("Time : %f (s)\n", stop-start );
    kaapic_finalize();
  }
    \end{code}

    The next example is equivalent to the previous:
    \begin{code}
  /* loop body */
  static void body(
    int i, int j, int tid, double* array, double* value
  ) 
  {
    int k;
    for (k = i; k < j; ++k)
      array[k] += *value;
  }

  int main()
  {
    double* array;
    double value;
    int err = kaapic_init(1);
    start = kaapi_get_time(); 
    /* apply body on array[0..size-1] */
    kaapic_foreach_with_format( 0, size, 2, body, 
        KAAPIC_MODE_RW, array, size, KAAPIC_TYPE_DOUBLE
        KAAPIC_MODE_V, &value, 1,  KAAPIC_TYPE_DOUBLE
    );
    stop = kaapi_get_time(); 

    printf("Time : %f (s)\n", stop-start );
    kaapic_finalize();
  }
    \end{code}
  \end{example}
\end{apisection}


%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[dataflow]{Dataflow programming}
  \begin{synopsis}
    \begin{code}
int kaapic_spawn(int32_t nargs, ...)
    \end{code}
  \end{synopsis}
  \begin{desc}
    Create a new computation task implemented by a call to a function
    \fn{body} with effective parameters \textit{e$_i$}.

    The function \fn{body} as well as its effective parameters are pass in the optional parameter list of \fn{kaapic\_spawn}.
    The format of the optional parameter list is:
    \begin{description}
    \item [body]: the function with signature\\
      \hspace*{5ex}\textit{void (*)([type$_0$, .., type$_{nparam-1}$])}.\\
      Each type \textit{type$_i$} could be:
      \begin{itemize}
      \item a pointer to a memory data
      \item a scalar value with size equal to the size of a pointer.
      \end{itemize}
    \end{description}
    
    \fn{body} is called with the user specified arguments, there is no argument added by \kaapi:\\
    \begin{small}
      \lstset{language=C}
      \begin{lstlisting}[frame=tb]
        body(e0, e1, ..., )
      \end{lstlisting}
    \end{small}
  \end{desc}

  \begin{params}    
    \begin{parameters}
    \param{nargs} the argument count;
    \param{...} the \fn{body} followed by a list of groups of 4
    arguments (\textit{mode}, \textit{value}, \textit{count}, \textit{type}).
    \end{parameters}

    \subsubsection{Format of each 4 successive arguments}

    Each task parameter is described by 4 successive arguments including:
    \begin{itemize}
    \item the access \textit{mode}.
    \item the argument \textit{value},
    \item the element \textit{cound},
    \item the parameter \textit{type}
    \end{itemize}
    
    \subsubsection{Mode information}
    \paragraph{}
    The parameter \textit{mode} is one of the following:
    \begin{itemize}
    \item KAAPIC\_MODE\_R for a read access,
    \item KAAPIC\_MODE\_W for a write access,
    \item KAAPIC\_MODE\_RW for a read write access,
    \item KAAPIC\_MODE\_V for a parameter passed by value.
    \end{itemize}
    
    \subsubsection{Type information}
    \paragraph{}
    The \textit{type} is one of the following:
    \begin{itemize}
    \item KAAPIC\_TYPE\_CHAR,
    \item KAAPIC\_TYPE\_INT,
    \item KAAPIC\_TYPE\_REAL,
    \item KAAPIC\_TYPE\_DOUBLE.
    \end{itemize}
    
    \paragraph{}
    If a parameter is an array, \textit{count} must be set to the number of the element of the array.
    For a scalar value, it must be set to 1.
    
  \end{params}
    
  
  \begin{ret}
    None.
  \end{ret}

  \begin{example}\label{fibo}
    \paragraph{}
    Refer to examples/kaapif/dfg subdirectory in sources
    
    \begin{code}
  /* computation task entry point */
  void fibonacci(int n, int* result)
  {
    /* task user specific code */
    if (n <2)
      *result = n;
     else 
     {
        int result1, result2;
        kaapic_spawn( 2, fibonacci, 
          KAAPIC_MODE_V, n-1, 1, KAAPIC_TYPE_INT
          KAAPIC_MODE_W, &result1, 1,  KAAPIC_TYPE_INT
        );
        kaapic_spawn( 2, fibonacci, 
          KAAPIC_MODE_V, n-2, 1, KAAPIC_TYPE_INT
          KAAPIC_MODE_W, &result2, 1,  KAAPIC_TYPE_INT
        );
        kaapic_sync();
        *result = result1 + result2;
     }
  }

  int main()
  {
    int n = 30;
    int result= 0;
    int err = kaapic_init(1);

    start = kaapi_get_time(); 
    /* apply body on array[0..size-1] */
    kaapic_spawn( 2, fibonacci, 
        KAAPIC_MODE_V, n, 1, KAAPIC_TYPE_INT
        KAAPIC_MODE_W, &result, 1,  KAAPIC_TYPE_INT
    );
    stop = kaapi_get_time(); 

    printf("Time : %f (s)\n", stop-start );
    kaapic_finalize();
  }
    \end{code}
  \end{example}
\end{apisection}


%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[parallel]{Parallel regions}

  \begin{synopsis}
    \begin{code}
int kaapic_begin_parallel(void)
int kaapic_end_parallel(int flag)
    \end{code}
  \end{synopsis}
  \begin{desc}
    \fn{kaapic\_begin\_parallel} and \fn{kaapic\_end\_parallel} mark
    the start and the end of a parallel region. Regions are used to
    wake-up and suspend the \kaapi system threads so they avoid
    disturbing the application when idle.  This is important if
    another parallel library is being used. Whether threads are
    suspendable or not is controlled according by the \fn{kaapi\_init}
    parameter.
  \end{desc}
  \begin{params}
    \param{falg} if zero, an implicit synchronization is inserted
    before leaving the region.
  \end{params}
  \begin{ret}
    None.
  \end{ret}
  \begin{example}
    \begin{code}
  int main()
  {
    int err = kaapic_init(1);

    kaapic_begin_parallel();
    ...
    kaapic_end_parallel();
    ...

  }
    \end{code}
  \end{example}
\end{apisection}

%%%%%%%%%%%%%%%%%%%%%%%%
\begin{apisection}[sync]{Synchronization}

  \begin{synopsis}
    \begin{code}
void kaapic_sync(void)
    \end{code}
  \end{synopsis}

  \begin{desc}
    Synchronize the sequential with the parallel execution flow. When
    this routine returns, every computation task has been executed and
    memory is consistent for the processor executing the sequential
    flow.
  \end{desc}
  \begin{ret}
    None.
  \end{ret}
  \begin{example}
    Refer to the Fibonacci example in section~\apirefp[example]{dataflow}.
  \end{example}
\end{apisection}

\end{document}

%  LocalWords:  runtime
